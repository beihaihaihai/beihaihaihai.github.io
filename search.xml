<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leecodeWeek1</title>
      <link href="/2025/03/23/leecodeWeek1/"/>
      <url>/2025/03/23/leecodeWeek1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>哈希表，将新的数和哈希表里面的数求和看是否等于target；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p>双指针，慢指针p指向非零数字，快指针i遍历数组找到非零数字和p交换；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p];</span><br><span class="line">                nums[p] = temp;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, right = <span class="number">0</span>, res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) &gt; left)&#123;</span><br><span class="line">                left = map.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, right);</span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(sorted, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(sorted, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p>先排序的做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res1</span> <span class="operator">=</span> <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == temp)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == temp + <span class="number">1</span>)&#123;</span><br><span class="line">                res1++;</span><br><span class="line">                temp = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res2 = res1 &gt; res2 ? res1 : res2;</span><br><span class="line">                res1 = <span class="number">1</span>;</span><br><span class="line">                temp = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> res1 &gt; res2 ? res1 : res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><p>据说每个人都会这道题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftTop</span> <span class="operator">=</span> height[left], rightTop = height[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            leftTop = Math.max(leftTop, height[left]);</span><br><span class="line">            rightTop = Math.max(rightTop, height[right]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rightTop &gt; leftTop) &#123;</span><br><span class="line">                res += leftTop - height[left++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += rightTop - height[right--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>感觉不如接雨水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightTop</span> <span class="operator">=</span> height[right], leftTop = height[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                v = height[left] * (right - left);</span><br><span class="line">                left++;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                v = height[right] * (right - left);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p><p>双指针做法：</p><p>首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p><p>接下来如何移动left 和right呢?</p><p>如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p><p>然后再处理一下第一个元素i的重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length, sum = <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right - <span class="number">1</span>] == nums[right]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left + <span class="number">1</span>] == nums[left]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2><p>前缀和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        prefixSumCount.put(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始前缀和为0出现1次</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="comment">// 查找是否有前缀和等于 sum - k</span></span><br><span class="line">            count += prefixSumCount.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 记录当前前缀和出现次数</span></span><br><span class="line">            prefixSumCount.put(sum, prefixSumCount.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>解释转载评论区：</p><p>要想求区间的和，就只有通过前缀和来计算（否则挨个遍历就会导致时间复杂度过大），这题要维护当前前缀和和最小前缀和</p><ul><li>如果当前前缀和比最小前缀和小就更新最小前缀和</li><li>用当前前缀和与最小前缀和的差值来求当前符合条件的区间，如果比当前ans大的话就对其更新<br>最小前缀和在求完之后再进行更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">10001</span>, min = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            ans = Math.max(sum - min, ans);</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; min)&#123;</span><br><span class="line">                min = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>排序后分类讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="type">int</span> i, len = intervals.length;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt; intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                ans.add(intervals[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span>[] temp = intervals[i];</span><br><span class="line">                <span class="keyword">while</span> (i &lt; len - <span class="number">1</span> &amp;&amp; temp[<span class="number">1</span>] &gt;= intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp[<span class="number">1</span>] &lt; intervals[i + <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                        temp[<span class="number">1</span>] = intervals[i + <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != len) &#123;</span><br><span class="line">            ans.add(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-配置管理</title>
      <link href="/2025/01/18/GoDAY2/"/>
      <url>/2025/01/18/GoDAY2/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="File-Config"><a href="#File-Config" class="headerlink" title="File Config"></a>File Config</h3><h4 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h4><p>cwgo配置文件默认使用YAML格式</p><p>proto下面的结构：</p><ul><li>dev：开发环境配置</li><li>online：生产环境配置</li><li>test：测试环境配置</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><h4 id="TOML"><a href="#TOML" class="headerlink" title="TOML"></a>TOML</h4><h3 id="Env-Config"><a href="#Env-Config" class="headerlink" title="Env Config"></a>Env Config</h3><h4 id="Linux-env"><a href="#Linux-env" class="headerlink" title="Linux env"></a>Linux env</h4><p>例子：修改默认的APP_ENV从test环境到online环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export APP_ENV=online</span><br></pre></td></tr></table></figure><h4 id="env-file"><a href="#env-file" class="headerlink" title=".env file"></a>.env file</h4><p>定义一个.env文件来加载</p><h4 id="Docker-env"><a href="#Docker-env" class="headerlink" title="Docker env"></a>Docker env</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV GO_ENV=online</span><br></pre></td></tr></table></figure><h3 id="MySQL根据环境读取配置"><a href="#MySQL根据环境读取配置" class="headerlink" title="MySQL根据环境读取配置"></a>MySQL根据环境读取配置</h3><p>由于我们使用的是test环境，修改test下的配置，这里用MySQL的配置为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">dsn:</span> <span class="string">&quot;%s:%s@tcp(%s:3306)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br></pre></td></tr></table></figure><p>然后去biz/dal/mysql/init.go里修改读取模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func Init() &#123;</span><br><span class="line">dsn := fmt.Sprintf(conf.GetConf().MySQL.DSN,</span><br><span class="line">os.Getenv(&quot;MYSQL_USER&quot;),</span><br><span class="line">os.Getenv(&quot;MYSQL_PASSWORD&quot;),</span><br><span class="line">os.Getenv(&quot;MYSQL_HOST&quot;),</span><br><span class="line">os.Getenv(&quot;MYSQL_DATABASE&quot;),</span><br><span class="line">)</span><br><span class="line">DB, err = gorm.Open(mysql.Open(dsn),</span><br><span class="line">&amp;gorm.Config&#123;</span><br><span class="line">PrepareStmt:            true,</span><br><span class="line">SkipDefaultTransaction: true,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-开发环境</title>
      <link href="/2025/01/16/Go%E6%A1%86%E6%9E%B6DAY1/"/>
      <url>/2025/01/16/Go%E6%A1%86%E6%9E%B6DAY1/</url>
      
        <content type="html"><![CDATA[<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><h3 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h3><p>go.dev官网下载最新版本</p><h3 id="Hertz框架"><a href="#Hertz框架" class="headerlink" title="Hertz框架"></a>Hertz框架</h3><p>在完成环境准备后，可以按照如下操作快速启动 Hertz Server：</p><ol><li><p>在当前目录下创建 hertz_demo 文件夹，进入该目录中。</p></li><li><p>创建 <code>main.go</code> 文件。</p></li><li><p>在 <code>main.go</code> 文件中添加以下代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/cloudwego/hertz/pkg/app&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/cloudwego/hertz/pkg/app/server&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/cloudwego/hertz/pkg/common/utils&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/cloudwego/hertz/pkg/protocol/consts&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := server.Default()</span><br><span class="line"></span><br><span class="line">    h.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, c *app.RequestContext)</span></span> &#123;</span><br><span class="line">            c.JSON(consts.StatusOK, utils.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.Spin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成 <code>go.mod</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init hertz_demo</span><br></pre></td></tr></table></figure></li><li><p>整理 &amp; 拉取依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></li><li><p>运行示例代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hertz_demo</span><br></pre></td></tr></table></figure><p>如果成功启动，你将看到以下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2022/05/17 21:47:09.626332 engine.go:567: [Debug] HERTZ: Method=GET    absolutePath=/ping   --&gt; handlerName=main.main.func1 (num=2 handlers)</span><br><span class="line">2022/05/17 21:47:09.629874 transport.go:84: [Info] HERTZ: HTTP server listening on address=[::]:8888</span><br></pre></td></tr></table></figure><p>接下来，我们可以对接口进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8888/ping</span><br></pre></td></tr></table></figure><p>如果不出意外，我们可以看到类似如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;pong&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="zsh（次要"><a href="#zsh（次要" class="headerlink" title="zsh（次要"></a>zsh（次要</h3><p>原文章：<a href="https://zhuanlan.zhihu.com/p/199798102">玩转WSL(3)之安装并配置oh-my-zsh - 知乎 (zhihu.com)</a></p><p>WSL(Ubuntu) 默认终端是 bash， zsh 功能比 bash 要强大得多，但是配置起来太难了。国外的一个程序员看不下去一直这么单调的 zsh，就开发了 oh my zsh。配置起来，不要太简单。可谓是高档大气上档次，狂拽炫酷吊炸天。</p><p><strong>① 查看当前系统的 shell</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure><p><strong>② 查看<a href="https://zhida.zhihu.com/search?content_id=132532983&amp;content_type=Article&amp;match_order=1&amp;q=系统安装&amp;zhida_source=entity">系统安装</a>的 shell</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shells</span><br></pre></td></tr></table></figure><p><strong>③ 安装 zsh</strong></p><p>若有 zsh，则切换未 zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s/bin/zsh</span><br></pre></td></tr></table></figure><p>WSL(Ubuntu) 默认是未安装 zsh的，使用以下指令安装并切换:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p><strong>④ 更新 zsh(oh-my-zsh)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">omz update</span><br></pre></td></tr></table></figure><p>使用以下指令下载并安装 oh my zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>输入以下指令，进入 <code>.zshrc</code> <a href="https://zhida.zhihu.com/search?content_id=132532983&amp;content_type=Article&amp;match_order=1&amp;q=配置文件&amp;zhida_source=entity">配置文件</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><blockquote><p>❗ WSL(Ubuntu) 默认安装了 vim，其他若未安装则使用指令 <code>sudo apt-get install vim</code> 安装或使用 <code>vi</code> 进行编辑。</p></blockquote><p>进入 <code>.zshrc</code> 后修改 <code>ZSH_THEME</code> 为指定主题即可。</p><blockquote><p>❌ 注意：<code>ZSH_THEME=</code>与主题名之间没有空格！！！</p></blockquote><p>推荐一些个人觉得好看的主题：robbyrussell, agnoster, <a href="https://zhida.zhihu.com/search?content_id=132532983&amp;content_type=Article&amp;match_order=1&amp;q=muse&amp;zhida_source=entity">muse</a>,af-magic, rkj-repos</p><blockquote><p>❗ 若切换主题的时候，发现主题样式无法正常显示出现乱码，则是字体适配问题。需要下载安装编程字体或者命令行字体。例如 <a href="https://link.zhihu.com/?target=https%3A//github.com/abertsch/Menlo-for-Powerline.git">Mono for powerline</a> 或者 Melso 字体。安装方式在本专栏的 <a href="https://zhuanlan.zhihu.com/p/199748950">WSL(2)</a> 中说明了安装方法。</p></blockquote><p>查看 <a href="https://zhida.zhihu.com/search?content_id=132532983&amp;content_type=Article&amp;match_order=5&amp;q=oh+my+zsh&amp;zhida_source=entity">oh my zsh</a> 自带了哪些主题:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> ~/.oh-my-zsh/themes</span><br></pre></td></tr></table></figure><p>查看当前主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ZSH_THEME</span></span><br></pre></td></tr></table></figure><p>设置为随机主题：<code>ZSH_THEME=random</code> 后，刷到了喜欢的主题，可通过一下命令查看当前主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$RANDOM_THEME</span></span><br></pre></td></tr></table></figure><p>设置为在指定主题间切换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME_RANDOM_CANDIDATES=( <span class="string">&quot;robbyrussell&quot;</span> <span class="string">&quot;agnoster&quot;</span> )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习</title>
      <link href="/2024/10/14/mySQL/"/>
      <url>/2024/10/14/mySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="安装mySQL"><a href="#安装mySQL" class="headerlink" title="安装mySQL"></a>安装mySQL</h2><p>可以安装到任意的盘符，安装包括连接到mySQL服务器，在工作台创建项目</p><p><a href="https://www.bilibili.com/video/BV1jcabemEr7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bdd8551641c485c305190c0dc5e3875e">安装教程</a></p><h2 id="mySQL"><a href="#mySQL" class="headerlink" title="mySQL"></a>mySQL</h2><p>笔记是按照下面的教程学习后整理的，接下来就是整理部分了。</p><p><a href="https://www.bilibili.com/video/BV1UE41147KC?p=7&amp;vd_source=bdd8551641c485c305190c0dc5e3875e">学习教程</a></p><h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><p><code>USE</code>：用来选择数据库</p><p><code>select</code>：用来在数据库中查找</p><p><code>from</code>：搭配在select后，选择数据库中的table</p><p><code>where</code>：指定table中的某些元素，例如customers_id = 1，搜索id为1的</p><p><code>order by</code>：根据某列元素排序。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>在select中可以输出运算后的数据，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT points, points + 10;</span><br></pre></td></tr></table></figure><p>同时输出points这列和每个数据运算后的新的列</p><p><code>AS</code>：列后面接as能给新列命名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT points + 10 AS &#x27;new column&#x27;</span><br></pre></td></tr></table></figure><p><code>distinct</code>： select后面接distinct可以删除列显示数据的重复性，例如address中存在两个shenzhen，运行后address列中只会存在一个shenzhen。</p><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>where语句筛选数据，后面接筛选条件，例如points &gt; 4000等。</p><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>where语句后的条件可以用与或非运算（AND，OR，NOT），类似python语法。</p><p>注意：AND优先级大于OR。</p><h4 id="IN运算符"><a href="#IN运算符" class="headerlink" title="IN运算符"></a>IN运算符</h4><p>获取与某个列表内相匹配的数据，例如我想获得shenzhen，guangzhou和shanwei的用户数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE address IN (&#x27;shenzhen&#x27;, &#x27;guangzhou&#x27;, &#x27;shanwei&#x27;);</span><br></pre></td></tr></table></figure><p>IN前面可以加NOT运算符</p><h4 id="between运算符"><a href="#between运算符" class="headerlink" title="between运算符"></a>between运算符</h4><p>获取某个范围的数据，比如我想获得points值介于1000到3000之间，包括临界值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE points BETWEEN 1000 AND 3000</span><br></pre></td></tr></table></figure><p>字符串也适用，比如获取1990-01-01和2000-01-01之间的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE points BETWEEN &#x27;1990-01-01&#x27; AND &#x27;2000-01-01&#x27; </span><br></pre></td></tr></table></figure><h4 id="LIKE运算符"><a href="#LIKE运算符" class="headerlink" title="LIKE运算符"></a>LIKE运算符</h4><p>like运算符用来匹配字符串，有点像正则，例如我想查找B开头的用户（不区分大小写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE name LIKE &#x27;B%&#x27;</span><br></pre></td></tr></table></figure><p><code>%</code>可以用来代替任意长度的任意字符，<code>_</code>相当于一个占位符，匹配任意一个字符，比如我想匹配Bob，则有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE name LIKE &#x27;B__&#x27;</span><br></pre></td></tr></table></figure><p>同时，这个式子也能匹配Buy之类的单词。</p><h4 id="regexp运算符"><a href="#regexp运算符" class="headerlink" title="regexp运算符"></a>regexp运算符</h4><p>REGEXP运算符也是用来匹配字符串的运算符，更接近正则表达式，例如想要搜索名字里有some的用户时，我们用LIKE运算符，需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE name LIKE &#x27;%some%&#x27;</span><br></pre></td></tr></table></figure><p>而用REGEXP运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE name REGEXP &#x27;some&#x27;</span><br></pre></td></tr></table></figure><p>同时，类似于正则，<code>^</code>代表匹配开头，<code>$</code>代表匹配结尾，<code>|</code>是或，<code>[]</code>内可以写一个匹配范围，[abc]代表匹配abc中的任意一个字符，也可以写成a-c，这里与正则表达式相同。</p><h4 id="IS-NULL运算符"><a href="#IS-NULL运算符" class="headerlink" title="IS NULL运算符"></a>IS NULL运算符</h4><p>查找某个某列数据缺失的用户（一行数据），例如，id为5号的数据缺少phone，我们只需：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE phone IS NULL </span><br></pre></td></tr></table></figure><p>同样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE phone IS NOT NULL </span><br></pre></td></tr></table></figure><p>则可以查找所有有电话号码的用户</p><h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h4><p>在关系型数据库中，每个表格都有一个主键列，这一列中的值要能够唯一识别表里的记录（唯一性）。</p><p>表格会默认按照主键列进行排序。</p><p>用order by加上列表头改变排序的列，默认升序排序，列后加上desc代表降序排序</p><p>可以同时排序多个列，且有先后顺序，先出现的先排，后出现的后排，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORDER BY address, name</span><br><span class="line">-- 1 shenzhen li</span><br><span class="line">-- 2 shenzhen Wang</span><br><span class="line">-- 3 guangzhou liu</span><br></pre></td></tr></table></figure><p>将会排序成：3 1 2，先排shenzhen和guangzhou，guangzhou在前，后排名字。</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>限制输出前n位数据，例如我想输出前三位数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 3</span><br></pre></td></tr></table></figure><p>还可以设置偏移量（offset），例如我想输出7到9位的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 6, 9</span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>当我们需要合并两张表的数据时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM orders</span><br><span class="line">JOIN customers ON orders.customer_id = customers.customer_id</span><br></pre></td></tr></table></figure><p>同时，确保两张表中的顾客id能够对的上。</p><h4 id="隐式转化"><a href="#隐式转化" class="headerlink" title="隐式转化"></a>隐式转化</h4><p>隐式给表头添加别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order o </span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order as o</span><br></pre></td></tr></table></figure><h4 id="跨数据库连接"><a href="#跨数据库连接" class="headerlink" title="跨数据库连接"></a>跨数据库连接</h4><p>只需要给不在当前数据库的表添加前缀即可，例如，我选中数据库sql_store，然后连接其他数据库sql_inventory</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">USE sql_store;</span><br><span class="line">SELECT *</span><br><span class="line">FROM order_items oi</span><br><span class="line">JOIN sql_inventory.products p</span><br><span class="line">ON oi.product_id = p.product_id</span><br></pre></td></tr></table></figure><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>假如有这么一张学生数据的表格，每栏新生数据中都有自己的导生的学号，要如何提取出新生的名字和对应导生的名字呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT n.student_id, n.name, o.name as manager</span><br><span class="line">FROM students n</span><br><span class="line">JOIN students o</span><br><span class="line">ON n.manager_id = o.student_id</span><br></pre></td></tr></table></figure><p>分别给新生和老生取别名，这是就是自连接。</p><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p>可以多次使用JOIN方法。</p><p>练习：整合sql_invoicing中的付款数据，付款人和付款方式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use sql_invoicing;</span><br><span class="line"></span><br><span class="line">select p.date ,p.invoice_id, c.name, p.amount, pm.name as payment_method</span><br><span class="line">FROM payments p</span><br><span class="line">JOIN payment_methods pm</span><br><span class="line">ON p.payment_method = pm.payment_method_id</span><br><span class="line">JOIN clients c</span><br><span class="line">ON c.client_id = p.client_id</span><br></pre></td></tr></table></figure><h4 id="复合连接条件"><a href="#复合连接条件" class="headerlink" title="复合连接条件"></a>复合连接条件</h4><p>用多个条件共同识别唯一数据。用于有复合主键的表格。</p><p>例如，order_items是一个有复合主键的表格，存在order_id 和 product_id两个主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use sql_store</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">From order_items oi</span><br><span class="line">Join order_item_notes oin</span><br><span class="line">ON oi.order_id = oin.order_id</span><br><span class="line">AND oi.product_id = oin.product_id</span><br></pre></td></tr></table></figure><h4 id="隐式连接"><a href="#隐式连接" class="headerlink" title="隐式连接"></a>隐式连接</h4><p>用where子句可以实现隐式连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where 条件语句</span><br></pre></td></tr></table></figure><p>相当于join…on</p><p>不建议使用隐式连接。</p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接有left join和right join。</p><p>当我们使用左连接时，所有左表的记录会被返回，不管条件正确与否，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from customers c</span><br><span class="line">left join orders o</span><br><span class="line">on c.customer_id = o.customer_id</span><br></pre></td></tr></table></figure><p>其中customer是左表，不管有无对应id，customer中的所有用户都会出现在表中，没有数据的部分（即对应不上），用NULL填充。</p><p>right join右连接同理。</p><h4 id="多表外连接"><a href="#多表外连接" class="headerlink" title="多表外连接"></a>多表外连接</h4><p>同理多表内连接。</p><p>注意：当存在多表连接时，尽量避免使用右连接，统一左连接，提高代码可读性。</p><p>练习答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use sql_store;</span><br><span class="line"></span><br><span class="line">select o.order_date, o.order_id, c.first_name as customer,  sh.name as shippr, os.name as status</span><br><span class="line">from orders o</span><br><span class="line">left join customers c</span><br><span class="line">on o.customer_id = c.customer_id</span><br><span class="line">left join shippers sh</span><br><span class="line">on o.shipper_id = sh.shipper_id</span><br><span class="line">join order_statuses as os</span><br><span class="line">on os.order_status_id = o.status</span><br></pre></td></tr></table></figure><p>三表连接，其中发货人这部分实用外连接，因为可以还没发货，不存在发货人，但要保留订单信息。</p><h4 id="自外连接"><a href="#自外连接" class="headerlink" title="自外连接"></a>自外连接</h4><p>略。</p><h4 id="using子句"><a href="#using子句" class="headerlink" title="using子句"></a>using子句</h4><p>假设在join…on的语句中，on后存在两个表中的列名称是<strong>完全一样</strong>的，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from orders o</span><br><span class="line">JOIN customers c</span><br><span class="line">on o.customer_id = c.customer_id</span><br></pre></td></tr></table></figure><p>其中存在相同名称customer_id，我们可以用using子句替换，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from orders o</span><br><span class="line">join customers c</span><br><span class="line">using (customer_id)</span><br></pre></td></tr></table></figure><p>内外连接都能使用者这个子句。</p><p>在复合连接条件这一小节中，对于有复合主键的表格，我们也可以使用这个using子句简化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">From order_items oi</span><br><span class="line">Join order_item_notes oin</span><br><span class="line">ON oi.order_id = oin.order_id</span><br><span class="line">AND oi.product_id = oin.product_id</span><br><span class="line">-- 替换成：</span><br><span class="line">From order_items oi</span><br><span class="line">Join order_item_notes oin</span><br><span class="line">using (order_id, product_id)</span><br></pre></td></tr></table></figure><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>natural join，让数据库引擎直接猜测如何连接，无法外部控制。</p><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><p>交叉连接得到的结果是一个表中的每行数据和另一个表中的每行数据的所有组合，例如123和abc交叉得到9种结果。</p><p>显式语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from ...</span><br><span class="line">cross join ...</span><br></pre></td></tr></table></figure><p>隐式语法，直接在from后面写两个表格的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from first_table, second_table</span><br></pre></td></tr></table></figure><h4 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h4><p>通过union，我们可以合并多段查询的记录（行合并）。合并的查询之间的列的数量一定要一样不然会报错。</p><p>多段查询union中，第一段查询写了什么会被用来决定列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from shippers</span><br><span class="line">union</span><br><span class="line">select first_name</span><br><span class="line">from customers</span><br></pre></td></tr></table></figure><p>如上，列名为name。</p><p>练习答案，根据points给用户分类型：</p><p>低于2000是青铜，2000到3000是白银，大于3000是黄金</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use sql_store;</span><br><span class="line"></span><br><span class="line">select customer_id, first_name, points, &#x27;Bronze&#x27; as type</span><br><span class="line">from customers c</span><br><span class="line">where c.points &lt; 2000</span><br><span class="line">union</span><br><span class="line">select customer_id, first_name, points, &#x27;Silver&#x27; as type</span><br><span class="line">from customers c</span><br><span class="line">where c.points between 2000 and 3000</span><br><span class="line">union</span><br><span class="line">select customer_id, first_name, points, &#x27;Gold&#x27; as type</span><br><span class="line">from customers c</span><br><span class="line">where c.points &gt; 3000</span><br><span class="line">order by first_name</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>打开表格的工具栏，分析每个选项的意思：</p><p>PK：主键，唯一识别</p><p>NN：非空，代表该列不能出现NULL</p><p>AI：自动递增排序，通常被用在主键列，在最后一行递增添加一个id，例如现有9个数据，添加第10个数据时该数据的id默认为10。</p><p>Default：若你没有给某行添加该列数据，默认填充default中指定的数据，可以是NULL，也可以是0，等等。</p><h4 id="插入单行"><a href="#插入单行" class="headerlink" title="插入单行"></a>插入单行</h4><p>如果你要给某个数据插入新的一行，例如给customers插入新行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers</span><br><span class="line">VALUES (</span><br><span class="line">DEFAULT,</span><br><span class="line">&#x27;John&#x27;,</span><br><span class="line">&#x27;Smith&#x27;</span><br><span class="line">    &#x27;1990-01-01&#x27;,</span><br><span class="line">    NULL,</span><br><span class="line">    &#x27;address&#x27;,</span><br><span class="line">    &#x27;city&#x27;,</span><br><span class="line">   &#x27;CA&#x27;,</span><br><span class="line">    DEFAULT</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，DEFAULT代表添加默认值，该值参考表格工具栏中该列的Default中的值。</p><p>这些数据的顺序是按照列的默认顺序排列下来，一一对应的。</p><p>我们也可以改变他们的顺序，同时只提供Default以外的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers (</span><br><span class="line">last_name,</span><br><span class="line">    first_name,</span><br><span class="line">    birth_day,</span><br><span class="line">    address,</span><br><span class="line">    city,</span><br><span class="line">    state</span><br><span class="line">)</span><br><span class="line">VALUES (</span><br><span class="line">&#x27;John&#x27;,</span><br><span class="line">&#x27;Smith&#x27;</span><br><span class="line">    &#x27;1990-01-01&#x27;,</span><br><span class="line">    &#x27;address&#x27;,</span><br><span class="line">    &#x27;city&#x27;,</span><br><span class="line">   &#x27;CA&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如此，表格的列名和填写到该列的数据一一对应，你可以以任何的顺序相照应地排列它们。</p><h4 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h4><p>非常简单，和插入单行一样，在values后面添加多个括号，一个括号代表一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO shippers (name)</span><br><span class="line">VALUES (&#x27;shipper1&#x27;),</span><br><span class="line">   (&#x27;shipper2&#x27;),</span><br><span class="line">   (&#x27;shipper3&#x27;)</span><br></pre></td></tr></table></figure><h4 id="插入分层行"><a href="#插入分层行" class="headerlink" title="插入分层行"></a>插入分层行</h4><p>假设我们有两张表格，一张表格存储订单信息，有着发货人收货人等信息，另一张表格存储订单明细，例如订购了什么产品，价格多少。两张表格是相互关联的，但我们要在订单信息表格插入一行新的数据，比如会在订单明细表格更新相对应的新数据，这时我们就要用插入多行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO orders (customer_id, order_date, status)</span><br><span class="line">VALUES (1, &#x27;2019-01-01&#x27;, 1);</span><br><span class="line"></span><br><span class="line">INSERT INTO order_items</span><br><span class="line">VALUES</span><br><span class="line">(LAST_INSERT_ID(), 1, 1, 2.95)</span><br></pre></td></tr></table></figure><p>这里使用<code>LAST_INSERT_ID()</code>这个内置函数，返回最后一次插入时MySQL生成的那个id，我们就能用这个订单id来更新order_items里的订单明细，对应order里的新行。</p><h4 id="创建表复制"><a href="#创建表复制" class="headerlink" title="创建表复制"></a>创建表复制</h4><p>复制一张表的数据到另外一张<strong>创建的新表</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE order_archived AS</span><br><span class="line">SELECT *FROM orders</span><br></pre></td></tr></table></figure><p>用这个方法创建表格，不会复制主键和自动递增列的选项，单纯只是数据的copy。其中这个SELECT是CREATE语句下的一段子查询，也可以用在INSERT语句下（这里假设我们已经创建了一张新表orders_archived）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO orders_archived</span><br><span class="line">SELECT *</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_date &lt; &#x27;2019-01-01&#x27;</span><br></pre></td></tr></table></figure><p>该例子中，复制所有order_date中日期早于2019年的数据到表orders_archived。</p><h4 id="更新单行"><a href="#更新单行" class="headerlink" title="更新单行"></a>更新单行</h4><p>假设要更新某个发票的支付时间和支付价格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE invoices -- 选择表格</span><br><span class="line">SET payment_total = 10, payment_date = &#x27;date&#x27;</span><br><span class="line">where invoice_id = 1</span><br></pre></td></tr></table></figure><p>update…set语句默认更新整列的数据，我们这里用where加个限制条件，只更新invoice_id = 1的这一行。</p><h4 id="更新多行"><a href="#更新多行" class="headerlink" title="更新多行"></a>更新多行</h4><p>想要一次更新多行在MySQL workbench是不允许的（会有安全保护），可以打开设置 -&gt; MySQL Editor，拉到最下面取消勾选 <code>safe updates</code>。</p><p>然后就能和更新单行一样一次更新多行了，更新多少行，哪些行，取决于where条件语句的设置。</p><h4 id="在更新中使用子查询"><a href="#在更新中使用子查询" class="headerlink" title="在更新中使用子查询"></a>在更新中使用子查询</h4><p>select查询产生的值可以用在update中的条件语句里，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE invoices </span><br><span class="line">SET payment_total = 10, payment_date = &#x27;date&#x27;</span><br><span class="line">where client_id = </span><br><span class="line">(select client_id</span><br><span class="line">             FROM clients</span><br><span class="line">             WHERE name = &#x27;Myworks&#x27;)</span><br></pre></td></tr></table></figure><p>如此，就能找到所有名字为Myworks的用户的id，然后根据这个id来更新。</p><p>如果select语句中产生了多条查询记录，client_id后要用 <code>IN</code> 运算符而不是 <code>=</code>。</p><h4 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELECT FROM table_name</span><br></pre></td></tr></table></figure><p>删除名字为table_name的表格的所有数据，当然你也可以在下面使用where条件语句选择特定的行进行删除，这一切都是自由的。</p><h4 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h4><p>在这一节中修改了很多数据，可以重新执行数据库脚本来重建数据库，恢复数据库到最开始的版本。</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>使用这些函数可以查找或者计算某列的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MAX()</span><br><span class="line">MIN()</span><br><span class="line">AVG() -- 平均</span><br><span class="line">SUM() -- 求和</span><br><span class="line">COUNT() -- 计算记录数</span><br></pre></td></tr></table></figure><p>只运行非空值，如果列中有空值NULL，则不会参与计算。</p><p>如果你想count表格有多少行的记录，可以用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT(*)</span><br></pre></td></tr></table></figure><p>同样的，这些函数后面也可以添加where选择语句， 函数后面一般用AS取个列名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">MAX(invoice_total) AS highest</span><br><span class="line">FROM invoices</span><br><span class="line">WHERE invoice_data &gt; &#x27;2019-07-01&#x27;</span><br></pre></td></tr></table></figure><p>如果在COUNT记录时不想获取到重复记录，例如有多个重复的用户id，但只想记录一次，则可以用distinct关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT(DISTINCT client_id) AS total_records</span><br></pre></td></tr></table></figure><h4 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h4><p>单列分组：</p><p>GROUP BY语句可以帮助我们给数据分组，只需要在groupby后面加上分组的依据列的名字，比如加上client_id，MySQL就会自动根据client_id分类。</p><p>假如我们不同的client_id对应多个订单，我们想要计算每个用户的总订单金额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select client_id, sum(invoice_total) as total_sales</span><br><span class="line">from invoices</span><br><span class="line">where invoice_date &gt;= &#x27;2019-07-01&#x27;</span><br><span class="line">group by client_id</span><br><span class="line">order by total_sales desc</span><br></pre></td></tr></table></figure><p>如上，筛选并计算最后排序，语句要按照这个顺序写下来，不然会报错。</p><p>多列分组：</p><p>只要在 group by 后面加上多个列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">state,</span><br><span class="line">city,</span><br><span class="line">sum(invoice_total) as total_sales</span><br><span class="line">from invoices i</span><br><span class="line">join clients using (client_id)</span><br><span class="line">group by state, city</span><br></pre></td></tr></table></figure><p>先连接两表，再用州和城市来给订单总金额分组；</p><p>练习答案（用日期和付款方式给总付款分组）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use sql_invoicing;</span><br><span class="line"></span><br><span class="line">select p.date, pm.name as payment_method, sum(amount) as total_payments</span><br><span class="line">from payments p</span><br><span class="line">join payment_methods pm </span><br><span class="line">ON pm.payment_method_id = p.payment_method</span><br><span class="line">group by p.date, payment_method</span><br><span class="line">order by date; </span><br></pre></td></tr></table></figure><h4 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="HAVING子句"></a>HAVING子句</h4><p>用having子句，我们得以在分组后进行数据筛选，比如在分组求总金额后筛选出金额大于500的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select client_id, sum(invoice_total) as total_sales</span><br><span class="line">from invoices</span><br><span class="line">group by client_id</span><br><span class="line">having total_sales &gt; 500</span><br></pre></td></tr></table></figure><p>having后面也可以加复合搜索条件，用and连接即可。</p><p>注意：having后面用到的列名必须是select里出现过的。</p><h4 id="with-rollup"><a href="#with-rollup" class="headerlink" title="with rollup"></a>with rollup</h4><p>计算分组后，每一列所有数据的总和（计算聚合值），字符串等的总和会输出NULL，不是一个标准的SQL语句，仅能用于MySQL。</p><p>一般添加在group by语句后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select payment_method, sum(amount) as total</span><br><span class="line">-- ...(省略from等语句)</span><br><span class="line">group by payment_method with rollup</span><br></pre></td></tr></table></figure><p>根据支付方式分组后，rollup求total的总和作为新的一行。</p><h3 id="编写复杂查询"><a href="#编写复杂查询" class="headerlink" title="编写复杂查询"></a>编写复杂查询</h3><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>之前介绍过，用小括号括起来的，子查询（或者叫内查询）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE invoices </span><br><span class="line">SET payment_total = 10, payment_date = &#x27;date&#x27;</span><br><span class="line">where client_id = </span><br><span class="line">(select client_id</span><br><span class="line">             FROM clients</span><br><span class="line">             WHERE name = &#x27;Myworks&#x27;)</span><br></pre></td></tr></table></figure><p>这段代码来自在更新中使用子查询这一节，其中client_id后面的语句就是一个子查询，MySQL执行时会先执行子查询。</p><p>练习答案（外部有IN的子查询，找到没有发票的用户）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use sql_invoicing;</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from clients</span><br><span class="line">where client_id NOT IN </span><br><span class="line">(select distinct client_id</span><br><span class="line">from invoices)</span><br></pre></td></tr></table></figure><h4 id="ALL关键字"><a href="#ALL关键字" class="headerlink" title="ALL关键字"></a>ALL关键字</h4><p> 子查询返回一列值时，用ALL关键字就会逐一取子查询中的值出来操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoice_total &gt; ALL(111, 222, 333);</span><br></pre></td></tr></table></figure><p>只有当左值大于右边的每个值时，才会时true。</p><h4 id="ANY关键字"><a href="#ANY关键字" class="headerlink" title="ANY关键字"></a>ANY关键字</h4><p>ANY代表任意一个，跟在子查询前代表任意一个。例如 = ANY 等价于 IN，意思是等于（子查询）里面的任意一个。</p><h4 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h4><p>子查询内存在和外查询有关联的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from invoices i</span><br><span class="line">where invoice_total &gt; (</span><br><span class="line">select avg(invoice_total)</span><br><span class="line">    from invoices</span><br><span class="line">    where client_id = i.client_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>i.client_id是外查询的值，只有当内查询的id符合外查询的id时，才会求其平均值，实际上就是根据id分组求平均值。</p><p>不难发现，这个相关子查询每次执行内查询都要访问一次外查询，因此运行较慢。</p><h4 id="EXISTS关键字"><a href="#EXISTS关键字" class="headerlink" title="EXISTS关键字"></a>EXISTS关键字</h4><p>该关键字能直接检查某个子查询中，是否有符合某个条件的行，而不会返回查询到的具体结果，对于某些返回结果较多的数据库能提高查询速度。</p><h4 id="select子句中的子查询"><a href="#select子句中的子查询" class="headerlink" title="select子句中的子查询"></a>select子句中的子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">...</span><br><span class="line">(子查询)</span><br><span class="line">from ...</span><br></pre></td></tr></table></figure><h4 id="from子句中的子查询"><a href="#from子句中的子查询" class="headerlink" title="from子句中的子查询"></a>from子句中的子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from(</span><br><span class="line">...</span><br><span class="line">) AS origin</span><br></pre></td></tr></table></figure><p>注意：必须要取一个别名</p><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><p>round函数，四舍五入函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">round(5.712, 2)</span><br></pre></td></tr></table></figure><p>例如把5.712四舍五入，保留2位。</p><p>truncate函数，截断函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate(5.212, 2)</span><br></pre></td></tr></table></figure><p>直接截断成2位</p><p>ceiling函数，返回大于等于这个数的最小整数。</p><p>floor函数，返回小于或等于这个数的最大整数。</p><p>abs函数，返回绝对值。</p><p>rand函数，返回0-1的随机数。</p><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p>length函数，返回字符串长度，</p><p>upper函数，返回全大写字符串，</p><p>lower函数，返回全小写字符串，</p><p>ltrim函数，左修整，移除左边空格等预定字符，rtrim同理，trim则是前后都修整。</p><p>left函数，返回从左边开始前n个字符，right函数同理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left(&#x27;string&#x27;, n)</span><br></pre></td></tr></table></figure><p>substring，截断函数，传入起始下标n和截断长度m，不传入长度默认到字符串结尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substring(&#x27;string&#x27;, n, m)</span><br></pre></td></tr></table></figure><p>locate函数，返回查找字符的小标，不区分大小写，搜索不到返回0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate(&#x27;s&#x27;, &#x27;string&#x27;) -- 返回1</span><br></pre></td></tr></table></figure><p>replace函数传入一个字符串并传入被替换的字符串和替换的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(&#x27;abc&#x27;, &#x27;ab&#x27;, &#x27;ba&#x27;) -- 返回bac</span><br></pre></td></tr></table></figure><p>concat函数，合并两个字符串；</p><h4 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h4><p>now函数，返回当前日期和时间，curdate只返回日期，curtime只返回时间；</p><p>extract函数，能从now函数中提取时间数据，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract(year from now()) -- 返回当前年数</span><br></pre></td></tr></table></figure><p>mysql语句中还有简化的语句，直接用对应的数据英语，传入now函数就好了，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">year(now()) -- 返回当前年数</span><br></pre></td></tr></table></figure><h4 id="格式化日期函数"><a href="#格式化日期函数" class="headerlink" title="格式化日期函数"></a>格式化日期函数</h4><p>date_format函数，能格式化返回日期的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATE_FORMAT(now(), &#x27;%y %m %d&#x27;) -- 返回当前年月日</span><br></pre></td></tr></table></figure><p>除了这些格式化字母，还有其他的格式化字母，<a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html">查询网址</a></p><p>还有time_format函数，返回格式化的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIME_FORMAT(now(), &#x27;%H:%i %p&#x27;) -- 12:00 PM</span><br></pre></td></tr></table></figure><h4 id="计算日期和时间"><a href="#计算日期和时间" class="headerlink" title="计算日期和时间"></a>计算日期和时间</h4><p>date_add函数，假如我们要增加一年：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date_sub(now(), interval -1 year)</span><br><span class="line">date_add(now(), interval 1 year)</span><br></pre></td></tr></table></figure><p>datediff函数，返回两日期之间的差值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datediff(&#x27;&#x27;, &#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>time_to_sec函数，返回从0点开始流逝的秒数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_to_sec(&#x27;9:00&#x27;) -- 32400</span><br></pre></td></tr></table></figure><p>用两个time_to_sec函数的表达式相减，就能得到两时间之差了。</p><h4 id="IFNULL-COALESCE"><a href="#IFNULL-COALESCE" class="headerlink" title="IFNULL COALESCE"></a>IFNULL COALESCE</h4><p>ifnull函数，如果检测到某个数据是null，就用传入的字符串替换，</p><p>例如，顾客id是空值，则全用”未注册“替换；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(customer_id, &#x27;Not assigned&#x27;)</span><br></pre></td></tr></table></figure><p>coalesce函数，可以传入一堆值，返回众多值中的第一个非空值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coalesce(customer_id, comments, &#x27;Not assigned&#x27;) as cs_id</span><br></pre></td></tr></table></figure><p>解释：如果customer_id是null，则返回comments，若comments也是null，则返回最后的字符串（因为不是null）。</p><h4 id="IF表达式"><a href="#IF表达式" class="headerlink" title="IF表达式"></a>IF表达式</h4><p>传入三个参数，第一个是测试表达式，第二个是表达式为真时返回的值，第三个是表达式为假时返回的值。</p><h4 id="case运算符"><a href="#case运算符" class="headerlink" title="case运算符"></a>case运算符</h4><p>case运算符一般接若干个when子句，当when子句的条件成立时，执行该when子句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">when 表达式1 THEN &#x27;返回的值&#x27;</span><br><span class="line">when ...</span><br><span class="line">when ...</span><br><span class="line">else &#x27; &#x27;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>最后用end闭合case语句。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是把查询单独封装起来的操作，就像创建了一张<strong>虚拟的表</strong>（依赖基础表的数据），我们可以随时调用这个查询（查询的结果是一张表）语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_name as</span><br><span class="line">select </span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建后的视图能直接调用，有点像封装好的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from view_name</span><br></pre></td></tr></table></figure><h4 id="删除修改视图"><a href="#删除修改视图" class="headerlink" title="删除修改视图"></a>删除修改视图</h4><p>删除视图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view view_name</span><br></pre></td></tr></table></figure><h4 id="更改视图"><a href="#更改视图" class="headerlink" title="更改视图"></a>更改视图</h4><p>可以重新更改或者创建视图（如果该视图不存在）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create or replace view view_name</span><br></pre></td></tr></table></figure><p>可以把视图放在sql文件夹中，创建git仓库方便管理。</p><h4 id="可更新视图"><a href="#可更新视图" class="headerlink" title="可更新视图"></a>可更新视图</h4><p>如果一个视图没有以下成分，那么它是一个可更新视图：</p><p>1、<code>distinct</code>关键字</p><p>2、聚合函数（sum，min，max等）</p><p>3、group by 和 having 等排序语句</p><p>4、<code>union</code>联合关键字；</p><p>如果是一个可更新视图，我们可以insert, update, delete。</p><p>如果需要在视图中插入新行，需要当前视图返回的表中有原来的表的全部的列，例如基础表中有日期列，视图里没有select这个列，那就没法插入新行。</p><h4 id="with-check-option"><a href="#with-check-option" class="headerlink" title="with check option"></a>with check option</h4><p>我们在操作可更新视图时可能会把视图中的某些行删除掉（例如某些在操作后不符合创建视图中where语句的行）。</p><p>为了防止这些行被意外删除，只要在创建视图的语句末尾加上<code>with check option</code>语句，当我们意外删除掉视图中的行时，会出现报错提示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WITH CHECK OPTION</span><br></pre></td></tr></table></figure><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p> 存储是一个打包SQL语句的过程，能够打包后直接调用。</p><h4 id="创建一个存储过程"><a href="#创建一个存储过程" class="headerlink" title="创建一个存储过程"></a>创建一个存储过程</h4><p>创建一个从begin开始到end结束的完整存储过程。</p><p>其中有几个要注意的点，先在一开始用<code>delimiter</code>语句修改分隔符（任意的，习惯用两个美元符号），这样就能把begin到end之间的存储看成一个整体，最后记得把默认分隔符改回分号；（后面的代码都忽略这个转变分隔符的操作，自己知道就好）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure get_client()</span><br><span class="line">begin</span><br><span class="line">select * from clients;</span><br><span class="line">...</span><br><span class="line">end$$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>存储不同于视图，有点像封装起来的快捷指令，封装完后可以直接调用；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL get_client()</span><br></pre></td></tr></table></figure><h4 id="在mysql-workbench直接创建存储"><a href="#在mysql-workbench直接创建存储" class="headerlink" title="在mysql workbench直接创建存储"></a>在mysql workbench直接创建存储</h4><p>在每个数据库中有个叫Stored Procedures的文件夹，右键创建新存储，这时候我们只需要填入mysql语句，然后会自动生成存储。</p><h4 id="删除存储"><a href="#删除存储" class="headerlink" title="删除存储"></a>删除存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure if exists procedure_name</span><br></pre></td></tr></table></figure><h4 id="有传参的存储"><a href="#有传参的存储" class="headerlink" title="有传参的存储"></a>有传参的存储</h4><p>只需要在create pro语句后的存储名字的括号内添加传入的参数名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure get_clients_by_state(state CHAR(2))</span><br><span class="line">begin</span><br><span class="line">...</span><br><span class="line">end$$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>这里的state类型是cha(2)，代表两个字符。</p><h4 id="带默认值的传参"><a href="#带默认值的传参" class="headerlink" title="带默认值的传参"></a>带默认值的传参</h4><p>在存储中添加一个传参判断语句来实现默认传参，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">if state is null then</span><br><span class="line">set state = &#x27;cA&#x27;</span><br><span class="line">end if;</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以上小节的例子为基础，如果没有传参state，则这里默认set为CA，记得if语句要用end if的结束标志。</p><p>如果我们默认值想设置为数据库里的所有的state，巧用IFNULL可以简洁实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">select *from clients c</span><br><span class="line">where c.state = IFNULL(state, c.state);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>之前我们知道IFNULL语句时如果第一个参数为NULL就返回第二个参数，如果传参state为NULL，这个语句就变成c.state = c.state，自然对于clients中所有的state值都成立。</p><h4 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h4><p>当一个参数传入是非法时，我们可以通过if语句和报错设置来提醒用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ... then</span><br><span class="line">signal sqlstate &#x27;&#x27;</span><br><span class="line">set MESSAGE_TEXT = &#x27;error&#x27;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure><p>其中signal sqlstate是设置错误码，每个错误的详细的错误码可以在官网查找：<a href="https://www.ibm.com/docs/en/db2/10.1.0?topic=messages-sqlstate">传送门</a></p><h4 id="输出参数（返回值）"><a href="#输出参数（返回值）" class="headerlink" title="输出参数（返回值）"></a>输出参数（返回值）</h4><p>在传入参数前面加上OUT关键字就是输出参数，例如下面例子中的out_name：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure get_clients_by_state(state CHAR(2), OUT out_name INT)</span><br><span class="line">begin</span><br><span class="line">...</span><br><span class="line">end$$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>可以在存储中用select…into…语句给输出参数赋值。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>user变量，会在整个客户会话过程中被保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @variables_name = 0</span><br></pre></td></tr></table></figure><p>本地变量，在存储或者函数内定义的，存储或者函数完成就会被清空：</p><p>使用declare关键字声明本地变量，例如，声明一个int变量默认值为0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare variables_name INT default 0</span><br></pre></td></tr></table></figure><p>也可以不给本地变量设置默认值，用select … into …给变量赋值，用set语句给变量赋值。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数不同于存储只能返回单一值，没有多行和多列的结果集。</p><p>函数还需要声明<strong>返回值类型</strong>和<strong>函数类型</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create function func_name(client_id INT)</span><br><span class="line">returns integer -- 返回值类型声明</span><br><span class="line">-- 下面是函数类型声明</span><br><span class="line">deterministic -- 确定性的，传入值和返回值一一对应</span><br><span class="line">reads sql data -- 函数中读取了数据</span><br><span class="line">modifies sql data -- 函数中有更新插入删除等</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>函数类型按实际情况选择。</p><p>同理，你最后可以用drop删除函数。</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是在插入，更新和删除语句前后自动执行的一堆sql代码，通常用来增强数据的一致性。</p><h4 id="新建触发器"><a href="#新建触发器" class="headerlink" title="新建触发器"></a>新建触发器</h4><p>触发器能修改别的表，但不能修改触发器所在的表。</p><p>新建的一个触发器在payments表，当插入新收款时，自动更新发票内某人的付款总值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create trigger payments_after_insert</span><br><span class="line">AFTER INSERT ON payments</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">UPDATE invoices</span><br><span class="line">SET payment_toal = payment_total + NEW.amount</span><br><span class="line">WHERE invoice_id = NEW.invoice_id;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure><h4 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGERS</span><br></pre></td></tr></table></figure><p>用LIKE关键字能筛选存在于某个表的触发器。</p><h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER IF EXISTS trigger_name</span><br></pre></td></tr></table></figure><h4 id="用触发器进行审计"><a href="#用触发器进行审计" class="headerlink" title="用触发器进行审计"></a>用触发器进行审计</h4><p>新建一张审计表，触发器内编写一段代码来更新审计表，在插入删除等操作后，记录发生的操作；</p><p>在这个例子里，在插入触发器最后补充这段代码，能自动在审计表里更新客户id，日期，支付金额，操作类型和操作时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO payment_audit</span><br><span class="line">VALUES (</span><br><span class="line">NEW.client_id, NEW.date, NEW.amount, &#x27;Insert&#x27;, NOW()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="事件event"><a href="#事件event" class="headerlink" title="事件event"></a>事件event</h4><p>大部分上，事件是按一定规律执行的sql代码。</p><p>执行事件，得先打开事件调度器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;event%&#x27;; -- 先查看是否开启</span><br><span class="line">SET GLOBAL event_scheduler = ON -- 如果查看后为OFF就执行这个</span><br></pre></td></tr></table></figure><p>打开事件调度器后就能开始编写事件了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create event event_name</span><br><span class="line">ON SCHEDULE </span><br><span class="line">-- AT &#x27;2024-10-01&#x27; -- 仅在国庆节这天执行</span><br><span class="line">EVERY 1 YEARS START &#x27;2024-01-01&#x27; ENDS &#x27;2029-01-01&#x27; -- 一年执行一次</span><br><span class="line">DO begin</span><br><span class="line">...</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure><h4 id="查看事件"><a href="#查看事件" class="headerlink" title="查看事件"></a>查看事件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW EVENTS;</span><br></pre></td></tr></table></figure><p>语法和触发器的基本一致；</p><h4 id="修改事件"><a href="#修改事件" class="headerlink" title="修改事件"></a>修改事件</h4><p>可以暂时启用事件或者禁用事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER EVENT event_name ENABLE;</span><br><span class="line">ALTER EVENT event_name DISABLE;</span><br></pre></td></tr></table></figure><h3 id="事务（搁置）"><a href="#事务（搁置）" class="headerlink" title="事务（搁置）"></a>事务（搁置）</h3><p>事务是代表单个工作单元的一组sql语句；事务是一个整体，密不可分。</p><h4 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h4><p>事务具有一致性，事务内的每个语句不会单独执行，只要有一个错误存在，整个事务都会被退回，不会出现执行了一半的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">...</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>当我们想调试这个事务时，可以把commit改成rollback，这样就会在最后退回事务并撤销所有更改；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">...</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>补充一下，mysql先把事务里执行正确的语句自动提交（commit），由autocommit控制；查看该系统变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br></pre></td></tr></table></figure><h4 id="锁定和并发"><a href="#锁定和并发" class="headerlink" title="锁定和并发"></a>锁定和并发</h4><p>并发操作可能出现的情况：</p><p>当一个事务试图修改某个数据库的一行或多行时，mysql会给数据库上锁，防止其他事务同时修改这些行，出现冲突。只有当第一个事务执行完毕后第二个事务才能继续执行。</p><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>脏读：读取到其他事务还未提交更改的数据；</p><p>重复读：重复读取的数据被其他事务修改导致不一致</p><p>幻读： 某个事务在执行时，其他事务修改了相关该事务的数据，导致该事务结果有误。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>char: 定长字符串，char(10) 相当于30个字节。</p><p>varchar:  65535 characters</p><p> mediumtext：16mb</p><p>longtext:  4GB</p><hr><p>tinytext  ：  255 bytes</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>tinyint 一个字节</p><p>unsigned tinyint 无符号一个字节</p><p>smallint  两个字节</p><p>mediumint 3个字节</p><p>int 4个字节</p><p>bigint 8个字节</p><h4 id="定点数类型"><a href="#定点数类型" class="headerlink" title="定点数类型"></a>定点数类型</h4><p>decimal(p , s)： 最多有p位，小数点后有s位，dec，numeric，fixed都是别名。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>float  4个字节</p><p>double 8个字节</p><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>bool，boolean</p><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>语法结构：enum（），括号里填入枚举的字符串，之后这一栏填写的数据只能从这里面挑选。枚举类型也许会导致各种问题，不建议使用。</p><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>date 日期（无时间）</p><p>time 时间（纯时间值）</p><p>datetime 日期和时间（8个字节）</p><p>timestamp 时间戳 （4个字节）</p><p>year</p><h4 id="Blob类型"><a href="#Blob类型" class="headerlink" title="Blob类型"></a>Blob类型</h4><p>二进制长对象，用来存储各种数据。</p><p>不太建议把大型二进制数据存储在数据库中，会导致读取速度变慢等问题。</p><h4 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h4><p>读取json类型，用一个简短的箭头符号：</p><p>假如当前列proper存储的是json类型，json类型下有<code>weight: 10</code>键值对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select proper -&gt; &#x27;$.weight&#x27;</span><br></pre></td></tr></table></figure><p>假如键值对的值是字符串，读取出来会带有引号，修改一下箭头符号能去掉引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select proper -&gt;&gt; &#x27;$.string&#x27;</span><br></pre></td></tr></table></figure><p>修改json，修改weight和string的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE database</span><br><span class="line">SET proper = JSON_SET(</span><br><span class="line">proper,</span><br><span class="line">    &#x27;$.weight&#x27;, 20,</span><br><span class="line">    &#x27;$.string&#x27;, &#x27;sony&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>删除json，删除其中的weight和string：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE database</span><br><span class="line">SET proper = JSON_REMOVE(</span><br><span class="line">proper,</span><br><span class="line">    &#x27;$.weight&#x27;</span><br><span class="line">    &#x27;$.string&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>每个单元格都应该有单一值，且不能出现重复列。</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>一张表仅能代表一种实体，这张表中的每一列都应该用来描述那个实体。</p><p>如果表中有一列描述了其他的实体，我们应该将其单独成表。</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>同一表中的列不应派生自其他列。</p><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">create database if not exists test_db;</span><br><span class="line"></span><br><span class="line">USE test_db;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS EMP;-- EMP表存在DEPT表的外键，因此EMP表要先删除。</span><br><span class="line">DROP TABLE IF EXISTS DEPT;-- 受到外键约束，不能随意删除。</span><br><span class="line"></span><br><span class="line">create table DEPT(</span><br><span class="line">DEPTNO INT primary key,</span><br><span class="line">    DNAME VARCHAR(50) NOT NULL,</span><br><span class="line">    LOC VARCHAR(50) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table EMP(</span><br><span class="line">EMPNO INT primary key,</span><br><span class="line">ENAME VARCHAR(50) NOT NULL,</span><br><span class="line">    JOB VARCHAR(50) NOT NULL,</span><br><span class="line">    MGR INT,</span><br><span class="line">    HIREDATE DATE NOT NULL,</span><br><span class="line">    SAL DECIMAL(7,2),</span><br><span class="line">    COMM INT,</span><br><span class="line">    DEPTNO INT NOT NULL,</span><br><span class="line">    FOREIGN KEY fk_EMP_DEPT (DEPTNO)</span><br><span class="line">REFERENCES DEPT(DEPTNO)</span><br><span class="line">        ON UPDATE CASCADE</span><br><span class="line">        ON DELETE RESTRICT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="更改数据库"><a href="#更改数据库" class="headerlink" title="更改数据库"></a>更改数据库</h4><p>把create换成alter。</p><h4 id="添加具体数据"><a href="#添加具体数据" class="headerlink" title="添加具体数据"></a>添加具体数据</h4><p>用INSERT语句，详见修改章节。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>创建能帮助我们更快找到目标；</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>例如，根据state来创建索引；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_state ON customers (state);</span><br></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEXES IN table_name;</span><br></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>指定字符串列的前几个字符，用其作为区分来设定索引，例如这里取姓氏的前5个字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_state ON customers (last_name(5));</span><br></pre></td></tr></table></figure><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引能根据查找的字符串，计算其<strong>相关性</strong>然后返回相关结果，十分灵活：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create fulltext index idx_title_body on posts(title, body);</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from posts</span><br><span class="line">where match(title, body) against(&#x27;react redux&#x27;)</span><br></pre></td></tr></table></figure><p>例子中，在每篇文章索引包含的是标题和主体；match函数中写入所有索引列，例如这里的title和body，不然mysql会报错；</p><p>关键是against里面的内容，react redux这两个单词用空格分割，是查找的必要条件，这两个单词可以在title和body中以任意顺序、任意形式出现，出现越多相关性越强。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">where match(title, body) against(&#x27;-from +react&#x27; in boolean mode)</span><br></pre></td></tr></table></figure><p>使用boolean mode，我们可以硬性查找某些字符串，例如上述例子中，查找所有包含react但没有from的行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">where match(title, body) against(&#x27;&quot;hello world&quot;&#x27; in boolean mode)</span><br></pre></td></tr></table></figure><p>使用双引号包含的字符串，执行语句后会返回<strong>准确包含这个字符串</strong>的行。</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>mysql只会选择一个索引，我们设定多个Btree索引只会选择其中一个；</p><p>因此需要复合索引，复合索引可以在多列上建立索引，例如，根据顾客所在州和积分建立复合索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_state_points on customers(state, points)</span><br></pre></td></tr></table></figure><h4 id="复合索引中的列顺序"><a href="#复合索引中的列顺序" class="headerlink" title="复合索引中的列顺序"></a>复合索引中的列顺序</h4><p>1、把更常用的列排前面；</p><p>2、把基数更大的列排前面；</p><p>3、根据实际情况更新索引；</p><h3 id="实验笔记"><a href="#实验笔记" class="headerlink" title="实验笔记"></a>实验笔记</h3><p>数据库系统实验一构建数据库代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">create database if not exists test_db;</span><br><span class="line"></span><br><span class="line">USE test_db;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS EMP;</span><br><span class="line">DROP TABLE IF EXISTS DEPT;</span><br><span class="line"></span><br><span class="line">create table DEPT(</span><br><span class="line">DEPTNO INT primary key,</span><br><span class="line">    DNAME VARCHAR(50) NOT NULL,</span><br><span class="line">    LOC VARCHAR(50) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table EMP(</span><br><span class="line">EMPNO INT primary key,</span><br><span class="line">ENAME VARCHAR(50) NOT NULL,</span><br><span class="line">    JOB VARCHAR(50) NOT NULL,</span><br><span class="line">    MGR INT,</span><br><span class="line">    HIREDATE DATE NOT NULL,</span><br><span class="line">    SAL DECIMAL(7,2),</span><br><span class="line">    COMM INT,</span><br><span class="line">    DEPTNO INT NOT NULL,</span><br><span class="line">    FOREIGN KEY fk_EMP_DEPT (DEPTNO)</span><br><span class="line">REFERENCES DEPT(DEPTNO)</span><br><span class="line">        ON UPDATE CASCADE</span><br><span class="line">        ON DELETE RESTRICT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO DEPT(</span><br><span class="line">DEPTNO, DNAME, LOC</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">(&#x27;10&#x27;, &#x27;ACCOUNTING&#x27;, &#x27;LONDON&#x27;),</span><br><span class="line">(&#x27;20&#x27;, &#x27;RESEARCH&#x27;, &#x27;PRESTON&#x27;),</span><br><span class="line">    (&#x27;30&#x27;, &#x27;SALES&#x27;, &#x27;LIVERPOOL&#x27;),</span><br><span class="line">    (&#x27;40&#x27;, &#x27;OPERATIONS&#x27;, &#x27;STAFFORD&#x27;),</span><br><span class="line">    (&#x27;50&#x27;, &#x27;MARKETING &#x27;, &#x27;LUTON&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO EMP(</span><br><span class="line">EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">(7369, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, 7902, &#x27;1990-12-17&#x27;, 13750, NULL, 20),</span><br><span class="line">    (7499, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1989-02-20&#x27;, 19000, 6400, 30),</span><br><span class="line">    (7521, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1993-02-22&#x27;, 18500, 4250, 30),</span><br><span class="line">    (7566, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1889-04-02&#x27;, 26850, NULL, 20),</span><br><span class="line">    (7654, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1997-09-28&#x27;, 15675, 3500, 30),</span><br><span class="line">    (7698, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1990-05-01&#x27;, 24000, NULL, 30),</span><br><span class="line">    (7782, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1988-06-09&#x27;, 27500, NULL, 10),</span><br><span class="line">    (7788, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, 7566, &#x27;1987-04-19&#x27;, 19500, NULL, 20),</span><br><span class="line">    (7839, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, NULL, &#x27;1983-11-17&#x27;, 82500, NULL, 10),</span><br><span class="line">    (7844, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1992-09-08&#x27;, 18500, 6250, 30),</span><br><span class="line">    (7876, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, 7788, &#x27;1996-5-23&#x27;, 11900, NULL, 20),</span><br><span class="line">    (7900, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, 7698, &#x27;1995-12-03&#x27;, 12500, NULL, 30),</span><br><span class="line">    (7902, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, 7566, &#x27;1991-12-03&#x27;, 21500, NULL, 20),</span><br><span class="line">    (7934, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, 7782, &#x27;1995-06-23&#x27;, 13250, NULL, 10),</span><br><span class="line">    (3258, &#x27;GREEN&#x27;, &#x27;SALESMAN&#x27;, 4422, &#x27;1995-07-24&#x27;, 18500, 2750, 50),</span><br><span class="line">    (4422, &#x27;STEVENS&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1994-06-14&#x27;, 24750, NULL, 50),</span><br><span class="line">    (6548, &#x27;BARNES&#x27;, &#x27;CLERK&#x27;, 4422, &#x27;1995-06-16&#x27;, 11950, NULL, 50);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF 7.20 -DosSnake</title>
      <link href="/2024/10/04/DASDCTF-7-20/"/>
      <url>/2024/10/04/DASDCTF-7-20/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-DosSnake"><a href="#0x01-DosSnake" class="headerlink" title="0x01 DosSnake"></a>0x01 DosSnake</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">key = [<span class="number">0x44</span>, <span class="number">0x41</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>]</span><br><span class="line">enc = [<span class="number">0x3F</span>, <span class="number">0x09</span>, <span class="number">0x63</span>, <span class="number">0x34</span>, <span class="number">0x32</span>, <span class="number">0x13</span>, <span class="number">0x2A</span>, <span class="number">0x2F</span>, <span class="number">0x2A</span>, <span class="number">0x37</span>,</span><br><span class="line">         <span class="number">0x3C</span>, <span class="number">0x23</span>, <span class="number">0x00</span>, <span class="number">0x2E</span>, <span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x3A</span>, <span class="number">0x27</span>, <span class="number">0x2F</span>, <span class="number">0x24</span>,<span class="number">0x3A</span>, <span class="number">0x30</span>, <span class="number">0x75</span>, <span class="number">0x67</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i] ^= key[i % <span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#DASCTF&#123;H0wfUnnytheDosSnakeis!!!&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巅峰极客2024-babyre</title>
      <link href="/2024/10/04/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22024re-wp/"/>
      <url>/2024/10/04/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22024re-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-babyre"><a href="#0x01-babyre" class="headerlink" title="0x01 babyre"></a>0x01 babyre</h2><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>输入的字符串经过3个3个的分解，例如flag分解为<code>fla</code>和<code>lag</code>，然后每组字符串经过sha256，再和原来未加密的字符串轮异或，例如，字符串<code>fla</code>经过sha256后生成的32字节的哈希值，每个字节和<code>fla</code>轮异或，得到的新的32字节的值。</p><p>源程序中有1280字节的密文，也就是40个上述的加密后的哈希值，分组爆破出3个3个的flag块，经过首尾相接后组成flag。</p><p>源程序中的40个加密后的哈希值经过随机打乱，不再是<code>fla</code>，<code>lag</code>…，的排列顺序，所以把flag块爆破出来后还需要一个脚本来拼接flag。</p><h3 id="python脚本"><a href="#python脚本" class="headerlink" title="python脚本"></a>python脚本</h3><p>爆破flag块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入的字符串经过3个3个的分解，然后每组字符串经过sha256，再和原来未加密的字符串轮异或</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">enc_list = [<span class="string">&#x27;EB74464F7924C56210CBFFC5A239BE0399ED2C8FB9542BA7C58A7E560F352CA0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;3EE5E00A6EA938CF85F882C799D78BC682225428F4E556D047F15E5766855C04&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;660DC72181954CF9976E5705CBAA483D2AAB5A69283D68E4F74C23CFA8C226D0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;F941E7F4FF9960F1DA677E9DBF9814B5B3E2D799074AC0120F212F3A52C37FE3&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;35D56DB4BD214600049F7F950C01FABD8625065607304F17AEF3C0F0177F9B3E&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;BDE5663346606CB307F1645F006DB088F34F7D44BE9543A1393B29506D1D3181&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;4460FE7BAC48BDBB8E354128E7535CE73B1618C594D9D1B9BF7148A7D77077E9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;A7FFA0BE1CFA9800FE3364F9E7304557974045E0C950B8F3444432C16AB7DDEE&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;371F6026FA2D6FC143598A9EE9E12736EABD515BAE24BB03E4C062DDC263F4A1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;8C3E5C10A4CC88E19B04592B864AC883D8B994EEB2C46496B3416B000C9A344A&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;4F3CF2C30DA6DD57B7D3701CDCB9418EAE8A0470C2AD2668ECF0E3AE6B6A29F6&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;AE3C23E30F42571DFC507171D173F928718E2A5D18C43F7A5B20E125A6421EFB&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;EFA5034BF44B5E66EF90124EE2CFFD9AACE7C49356A64ADFFBA0D44D29B125AB&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;8E98386ED91129B0197AE9A642C173578EFD4784D1EE087CE765A714640F9AA8&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;67A4AD879229F1712037D522B5226B2DC7440EFCB753EC8A52C29CF1FB9BD85F&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;A65FDA70B1261E143F9406D00D90AA0F55310652F3F908D7C1E5A841F77EBD30&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;14FCA23CB223F8915D7730AFC7276F1C0FC7EA33A3083553D2684D964EC7E4A9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;205DEE6FCFEADA8B589CF48326AF2DEBF56DB42A4DFDF74BF9CB0A34BFD97B90&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;B83E17E31FE0A48B54C94AC4175B46302D5E8B38D7CB42E618AEC9197D43B1B3&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;6891A18CDC5CA57F20284187FE6988D860ED46076F779B088D2FA78A798A55DC&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;C6E657E8B101A23B9F8ADE02F696D905F63C626C3E07FD06002B2030B20FAFF0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;2625D9B875A4B74DD421CCB5411CC309EBE7CC75BED408F9F486E6CFFF4F14AC&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;36DFFB643C2721A3AD4CA95415D59CF3C3EE85FF75F2BC6FFD1FC09499544B72&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;18F5937E8B73C7764DEBC840266B14F3D049AE9511AB135CC764C5C6F10C87C0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;87BC8D3181D7470630D4A983FE401F46C99F4A52D81E8D4146211BFA28AE52C9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;D0E3974AFB2D830F443136F4464DDFEFA30688BE27A8A0158A85B8040C2C0459&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;8F2111751D296F862FFEBC2FB50D6530FE6C09D70F54664ED2F2C44365D647B3&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;E6D5BB45707C8B18C8A248B153309605B34ED9CEF42172114F52AE47E8063131&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;EFB2F1AD55868D648722111B00CFE2132463F9659AA1F8298ED2FBD1239071DC&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;3ACF63661C77A5ACBB54410FF3F7CFA1701040BD2D2C8F721A37E310A8460584&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;5E7202DB021B2346A1BB920AE80DD0066F05A0524BC80339ED9932542883473F&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;EFCA18C1C8B8C9B0E31B7169BAC1F1B9697B2799BDB869006C16C49B77525AB7&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;546FE3345E5F01A5E248FB966B7592D2A0DA0BED3E27F6C789647FDE73F59258&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;FFC6A638758661126FC03D24226DA7295EBDF50C52D96631B5804D02CDF2DC89&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;FA6063CA2D00953200BED4BF734CEDBA0C56A185C46CB60ABCDD8C611E4203B4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;E0F217FA14389FB1A49C03180CC616C730FA48B1B96EB17D7B3BDFD9B6A7D646&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;A57C976DD592A3F022A15399A1C37140E1897B231918DC2F2257DD2CC33FADEF&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;99939CE9EB676674458ED487984E9F8D2C7DF23D8093940FEAB586D0E674B6B2&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;416125DED9C2386A247F1D87BAD1CAB640579EAE3050FFD0A8AEDF52254AA5E9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;186F060C97150EC26626CC8451C47569764B281667A54428E096A20A5D81EB4D&#x27;</span>]</span><br><span class="line"></span><br><span class="line">enc0 = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爆！！！！</span></span><br><span class="line"><span class="comment"># sha256每组有32个字节</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    f = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):</span><br><span class="line">            <span class="keyword">if</span> f:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):</span><br><span class="line">                enc1 = [i, j, k]</span><br><span class="line">                enc0 = <span class="built_in">chr</span>(i) + <span class="built_in">chr</span>(j) + <span class="built_in">chr</span>(k)</span><br><span class="line">                hash_data = hashlib.sha256(enc0.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line">                temp = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                    hex_data = enc1[h % <span class="number">3</span>] ^ <span class="built_in">int</span>(hash_data[(<span class="number">2</span> * h): (<span class="number">2</span> * h + <span class="number">2</span>)], <span class="number">16</span>)</span><br><span class="line">                    <span class="keyword">if</span> hex_data &lt;= <span class="number">0xf</span>:</span><br><span class="line">                        temp += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    temp += <span class="built_in">hex</span>(hex_data)[<span class="number">2</span>:].upper()</span><br><span class="line">                <span class="keyword">if</span> temp == enc_list[m]:</span><br><span class="line">                    f = <span class="literal">True</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;\&#x27;&quot;</span> + enc0 + <span class="string">&quot;\&#x27;&quot;</span>, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>拼接flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># flag是上个脚本的输出</span></span><br><span class="line">flag = [<span class="string">&quot;-48&quot;</span>, <span class="string">&quot;-79&quot;</span>,<span class="string">&quot;-80&quot;</span>,<span class="string">&quot;-bf&quot;</span>,<span class="string">&quot;0bd&quot;</span>,<span class="string">&quot;177&quot;</span>,<span class="string">&quot;194&quot;</span>,<span class="string">&quot;29f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;37-&quot;</span>,<span class="string">&quot;39a&quot;</span>,<span class="string">&quot;4-7&quot;</span>,<span class="string">&quot;48f&quot;</span>,<span class="string">&quot;4a3&quot;</span>,<span class="string">&quot;7-4&quot;</span>,<span class="string">&quot;729&quot;</span>,</span><br><span class="line">    <span class="string">&quot;772&quot;</span>,<span class="string">&quot;793&quot;</span>,<span class="string">&quot;80b&quot;</span>,<span class="string">&quot;8a&#125;&quot;</span>,<span class="string">&quot;8fb&quot;</span>,<span class="string">&#x27;937&#x27;</span>,<span class="string">&quot;94a&quot;</span>,<span class="string">&quot;9a4&quot;</span>,<span class="string">&quot;9f8&quot;</span>,<span class="string">&quot;a-8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;a39&quot;</span>,<span class="string">&quot;a4-&quot;</span>,<span class="string">&quot;ag&#123;&quot;</span>,<span class="string">&quot;b-b&quot;</span>,<span class="string">&quot;bd1&quot;</span>,<span class="string">&quot;bfe&quot;</span>,<span class="string">&quot;d17&quot;</span>,<span class="string">&quot;ea-&quot;</span>,</span><br><span class="line">    <span class="string">&quot;f8a&quot;</span>,<span class="string">&quot;fb-&quot;</span>,<span class="string">&quot;fea&quot;</span>,<span class="string">&quot;fla&quot;</span>,<span class="string">&quot;g&#123;1&quot;</span>,<span class="string">&quot;lag&quot;</span>,<span class="string">&quot;&#123;19&quot;</span>]</span><br><span class="line"><span class="built_in">input</span> = <span class="string">&quot;fla&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">if</span> one[:<span class="number">2</span>] == <span class="built_in">input</span>[-<span class="number">2</span>:]:</span><br><span class="line">            <span class="built_in">input</span> += one[-<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">input</span>[-<span class="number">1</span>:] == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>)</span><br><span class="line"><span class="comment">#flag&#123;194a39a4-7937-48fb-bfea-80bd17729f8a&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则匹配</title>
      <link href="/2024/10/04/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
      <url>/2024/10/04/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-正则库re"><a href="#0x01-正则库re" class="headerlink" title="0x01 正则库re"></a>0x01 正则库re</h2><p>运用python自带的正则库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p>设置一个匹配对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在单引号内写正则表达式。</p><p>还可以传入第二个参数，用来指定额外的条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&#x27;</span>, re.I)  <span class="comment">#忽略大小写</span></span><br><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?&#x27;</span>, re.DOTALL) <span class="comment">#句点匹配符匹配换行符</span></span><br><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?&#x27;</span>, re.VERBOSE) <span class="comment">#忽略正则表达式字符串中的空白符和注释</span></span><br></pre></td></tr></table></figure><h2 id="0x02-有关正则的python方法"><a href="#0x02-有关正则的python方法" class="headerlink" title="0x02 有关正则的python方法"></a>0x02 有关正则的python方法</h2><p><code>search()</code></p><p>找到第一个匹配的字符串并返回一个Match对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">r&#x27;123&#x27;</span>)</span><br><span class="line">mo = member.search(<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mo.group())</span><br><span class="line"><span class="comment">#123</span></span><br></pre></td></tr></table></figure><p><code>findall()</code></p><p>找到所有匹配的字符串并返回一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d\d\d-\d\d\d-\d\d\d\d&#x27;</span>)</span><br><span class="line">member.findall(<span class="string">&#x27;Cell: 415-555-9999 Work: 212-555-0000&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[&#x27;415-555-9999&#x27;, &#x27;212-555-0000&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>sub()</code></p><p>找到匹配的字符串并用第一个参数替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = re.<span class="built_in">compile</span>(<span class="string">&#x27;Agent\s\w+&#x27;</span>)</span><br><span class="line">mo = name.sub(<span class="string">&#x27;CENSORED&#x27;</span>, <span class="string">&#x27;Agent Alice gave the secret documents to Agent Bob.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mo)</span><br><span class="line"><span class="comment">#CENSORED gave the secret documents to CENSORED.</span></span><br></pre></td></tr></table></figure><p><code>group()</code>和<code>groups()</code></p><p>当使用括号分隔正则表达式时，<code>group()</code>可以指定返回第几部分，<code>groups()</code>返回一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">phoneNumRegex = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(\d\d\d)-(\d\d\d-\d\d\d\d)&#x27;</span>)</span><br><span class="line">mo = phoneNumRegex.search(<span class="string">&#x27;My number is 415-555-4242.&#x27;</span>)</span><br><span class="line">mo.group(<span class="number">1</span>) <span class="comment">#&#x27;415&#x27;</span></span><br><span class="line">mo.group(<span class="number">2</span>) <span class="comment">#&#x27;555-4242&#x27;</span></span><br><span class="line">mo.group(<span class="number">0</span>) <span class="comment">#&#x27;415-555-4242&#x27;</span></span><br><span class="line">mo.group()  <span class="comment">#&#x27;415-555-4242&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-文件读写"><a href="#0x03-文件读写" class="headerlink" title="0x03 文件读写"></a>0x03 文件读写</h2><h3 id="一些os模块"><a href="#一些os模块" class="headerlink" title="一些os模块"></a>一些os模块</h3><p><code>getcwd()</code></p><p>获取当前工作路径</p><p><code>chdir()</code></p><p>修改当前工作路径</p><p><code>makedirs()</code></p><p>新建文件夹</p><p><code>os.listdir(path)</code></p><p>返回路径中文件名字字符串的列表    </p><h3 id="os-path模块"><a href="#os-path模块" class="headerlink" title="os.path模块"></a>os.path模块</h3><p><code>abspath(path)</code></p><p>相对路径转化为绝对路径</p><p><code>isabs(path)</code></p><p>判断是不是绝对路径</p><p><code>relpath(path, start)</code></p><p>返回从 start 路径到 path 的相对路径的字符串，如果没有提供 start，就使用当前工作目录作为开始路径</p><p><code>dirname(path)</code></p><p>返回路径的目录（目录名称）</p><p><code>basename(path)</code></p><p>返回路径的文件名（基本名称）</p><p><code>split()</code></p><p>返回目录名称和基本名称的元组</p><p><code>os.path.sep</code></p><p>这是一个变量，os.path.sep 变量设置为正确的文件夹分割斜杠</p><p><code>getsize(path)</code></p><p>返回 path 参数中文件的字节数</p><p><code>os.path.exists(path)</code></p><p>检测文件或者文件夹是否存在</p><p><code>os.path.isfile(path)</code></p><p>存在文件？</p><p><code>os.path.isdir(path)</code></p><p>存在文件夹？</p><p>更多操作见<a href="http://docs.python.org/3/library/os.path.html">os.path模块的完整文档</a></p><h2 id="0x04-用shelve模块保存变量"><a href="#0x04-用shelve模块保存变量" class="headerlink" title="0x04 用shelve模块保存变量"></a>0x04 用shelve模块保存变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">shelfFile = shelve.<span class="built_in">open</span>(<span class="string">&#x27;mydata&#x27;</span>)</span><br><span class="line">cats = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">shelfFile[<span class="string">&#x27;cats&#x27;</span>] = cats</span><br><span class="line">shelfFile.close()</span><br></pre></td></tr></table></figure><p>导入shelve模块，新建一个mydata文件，用键值对的方法保存数据。</p><h2 id="0x05-JSON"><a href="#0x05-JSON" class="headerlink" title="0x05 JSON"></a>0x05 JSON</h2><p>json是一种文本规范，用来保存树形结构的数据很方便。</p><h3 id="JSON支持的数据类型"><a href="#JSON支持的数据类型" class="headerlink" title="JSON支持的数据类型"></a>JSON支持的数据类型</h3><p>1、字符串：需要包含在一对双引号内，不能是单引号；</p><p>2、数字：可以是整数和浮点数；</p><p>3、布尔值：true和false</p><p>4、null：空值</p><p>注：上述的数据类型不能内嵌其他值。</p><p>5、键值对：需要包含在一对花括号内，用逗号隔开键值对，且键值对的键必须为字符串，但值可以是JSON支持的      任意数据类型中的一种，且无需统一类型。</p><p>6、数组：需要包含在一对中括号内，用逗号隔开，且值同上一样，无需统一类型。</p><p>上述两种数据类型可以内切其他值，使得JSON能够表示树形结构的数据。</p><p>JSON中的空格和换行不会有实际影响。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫理论笔记</title>
      <link href="/2024/10/04/%E7%88%AC%E8%99%AB/"/>
      <url>/2024/10/04/%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="web请求过程剖析"><a href="#web请求过程剖析" class="headerlink" title="web请求过程剖析"></a>web请求过程剖析</h2><h3 id="服务器渲染"><a href="#服务器渲染" class="headerlink" title="服务器渲染"></a>服务器渲染</h3><p>服务器直接整合数据和html文件，并返回</p><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>服务器先返回一个html骨架，之后请求再次返回需要的数据，在浏览器客户端整合成页面（页面源代码没有数据）。</p><p>通过Network实时查看服务器对请求的返回，可以抓包到数据。</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议，Hyper Text Transfer Protocol（超文本传输协议），服务器和浏览器之间的数据交互遵守的就是HTTP协议。</p><p>请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求行 -&gt; 请求方式（get/post）  请求URL地址   协议</span><br><span class="line">请求头 -&gt; 服务器要使用的附加信息</span><br><span class="line">请求体 -&gt; 一般是请求参数（例如搜索框输入的东西）</span><br></pre></td></tr></table></figure><p>响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">状态行 -&gt; 协议 状态码（404等）</span><br><span class="line">响应头 -&gt; 放一些客户端要使用的附加信息（例如安全密钥，加密数据等）</span><br><span class="line">响应体 -&gt; 服务器返回的真正的客户端要使用的内容（HTML, json等）</span><br></pre></td></tr></table></figure><p>请求头中的常见重要内容：</p><p> 1、<code>User-Agent</code>：请求载体的身份标识（用什么发送的请求）</p><p>2、<code>Referer</code>：防盗链（ 这次请求是从哪个页面来的？反爬使用）</p><p>3、<code>cookie</code>：本地字符串数据信息（用户登录信息，反爬的token）</p><p>响应头的重要内容：</p><p>1、<code>cookie</code>：本地字符串数据信息（用户登录信息，反爬的token）</p><p>2、<code>token</code>字样的各种反爬和反攻击的字符串</p><p>请求方式：</p><p>1、<code>GET</code>：显示提交</p><p>2、<code>POST</code>：隐式提交</p><h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><p>用requests发送请求，用GET的方式发送请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.get(Url)</span><br></pre></td></tr></table></figure><p>关于User-Agent的反爬：</p><p>有时候网页服务器会检测你的身份标识（User-Agent）,来判断你是正常浏览器访问还是通过爬虫手段。可以先正常访问一下浏览器，然后复制正常访问时的身份标识，创建一个字典来伪造身份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;your message&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个信息可以通过，检查 -&gt; 网络  -&gt; 查看发送成功的请求，然后查看他的请求头，里面有你的User-Agent信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(Url, headers = headers)</span><br></pre></td></tr></table></figure><p>获取后直接进行替换headers。 </p><h3 id="指定字符集"><a href="#指定字符集" class="headerlink" title="指定字符集"></a>指定字符集</h3><p>request模块默认的编码字符集是UTF-8，对于有些用GBK编码的网站，爬出数据后可能会是乱码，我们可以更改指定的编码字符集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#resp = requests.get(URL)</span></span><br><span class="line">resp.encoding = <span class="string">&quot;GBK&quot;</span></span><br></pre></td></tr></table></figure><h3 id="案例：百度搜索框搜索"><a href="#案例：百度搜索框搜索" class="headerlink" title="案例：百度搜索框搜索"></a>案例：百度搜索框搜索</h3><p>通过百度等搜索引擎搜索，发送的请求基本都是GET（查看页面请求头可知），那只要在程序中发送GET请求就好了。实现过于简单不赘叙。</p><h3 id="案例：百度翻译单词"><a href="#案例：百度翻译单词" class="headerlink" title="案例：百度翻译单词"></a>案例：百度翻译单词</h3><p>通过请求调试发现，百度翻译的数据结果来源于sug页面，在Payload的data项下可以看到请求的内容，比如我输入一个dog，data下就会出现kw ： dog，这个kw就是keyword。</p><p>所以通过修改sug的kw，然后来进行翻译内容爬取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;https://fanyi.baidu.com/sug&quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">&quot;kw&quot;</span> : <span class="string">&quot;dog&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#发送post请求，发送的数据必须存放在字典里，通过data参数进行传递</span></span><br><span class="line">resp = requests.post(url, data = data)</span><br><span class="line"><span class="built_in">print</span>(resp.json()) <span class="comment">#将服务器放回的内容直接处理成json</span></span><br></pre></td></tr></table></figure><h3 id="案例：豆瓣电影排行榜"><a href="#案例：豆瓣电影排行榜" class="headerlink" title="案例：豆瓣电影排行榜"></a>案例：豆瓣电影排行榜</h3><p>电影排行榜的渲染，属于上述的客户端渲染，html框架和数据是分开响应的（框架一般不变而排行榜内容可能会变），此时我们需要的电影数据就不是从网页源代码中寻找。</p><p>通过抓包，筛选出XHR格式的响应，里面存储着用于和html框架整合的数据。</p><p>一个URL中，问号分割网址和参数，问号后面的是参数类型及其数值。在写程序时，对于较长的URL，可以通过重新封装参数来分离参数和网址地址。</p><p>（这里放一张图片）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URL = <span class="string">&quot;your website&quot;</span></span><br><span class="line"><span class="comment">#重新封装参数</span></span><br><span class="line">param = &#123;</span><br><span class="line">    <span class="comment">#参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#独属于get请求的，发送参数的选项是params，不同于POST请求的data</span></span><br><span class="line">resp = requests.get(url = url, params = param)</span><br></pre></td></tr></table></figure><p>补充：记得在完成请求和响应后，在程序的最后，关掉responds，防止过多的请求挂载着，使得访问服务器堵塞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp.close()</span><br></pre></td></tr></table></figure><h2 id="正则匹配Re模块"><a href="#正则匹配Re模块" class="headerlink" title="正则匹配Re模块"></a>正则匹配Re模块</h2><h3 id="正则库re"><a href="#正则库re" class="headerlink" title="正则库re"></a>正则库re</h3><p>运用python自带的正则库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p>设置一个匹配对象，<strong>预加载正则表达式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>在单引号内写正则表达式。</p><p>还可以传入第二个参数，用来指定额外的条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&#x27;</span>, re.I)  <span class="comment">#忽略大小写</span></span><br><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?&#x27;</span>, re.DOTALL) <span class="comment">#句点匹配符匹配换行符，或者用re.S</span></span><br><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?&#x27;</span>, re.VERBOSE) <span class="comment">#忽略正则表达式字符串中的空白符和注释</span></span><br></pre></td></tr></table></figure><h3 id="有关正则的python方法"><a href="#有关正则的python方法" class="headerlink" title="有关正则的python方法"></a>有关正则的python方法</h3><p><code>search()</code></p><p>找到第一个匹配的字符串并返回一个Match对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">r&#x27;123&#x27;</span>)</span><br><span class="line">mo = member.search(<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mo.group())</span><br><span class="line"><span class="comment">#123</span></span><br></pre></td></tr></table></figure><p><code>match</code></p><p>从头开始匹配，类似于正则表达式开头的^。</p><p><code>findall()</code></p><p>找到所有匹配的字符串并返回一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">member = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d\d\d-\d\d\d-\d\d\d\d&#x27;</span>)</span><br><span class="line">member.findall(<span class="string">&#x27;Cell: 415-555-9999 Work: 212-555-0000&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[&#x27;415-555-9999&#x27;, &#x27;212-555-0000&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>finditer</code></p><p>匹配字符串中所有内容，返回一个迭代器（Match对象组），用for循环一个一个提出出来后.group( )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it = member.finditer(<span class="string">r&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span>(i.group())</span><br></pre></td></tr></table></figure><p><code>sub()</code></p><p>找到匹配的字符串并用第一个参数替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = re.<span class="built_in">compile</span>(<span class="string">&#x27;Agent\s\w+&#x27;</span>)</span><br><span class="line">mo = name.sub(<span class="string">&#x27;CENSORED&#x27;</span>, <span class="string">&#x27;Agent Alice gave the secret documents to Agent Bob.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mo)</span><br><span class="line"><span class="comment">#CENSORED gave the secret documents to CENSORED.</span></span><br></pre></td></tr></table></figure><p>从正则匹配出的字符串中提取需要内容：</p><p><code>group()</code>和<code>groups()</code></p><p>当使用括号分隔正则表达式时，<code>group()</code>可以指定返回第几部分，<code>groups()</code>返回一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">phoneNumRegex = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(\d\d\d)-(\d\d\d-\d\d\d\d)&#x27;</span>)</span><br><span class="line">mo = phoneNumRegex.search(<span class="string">&#x27;My number is 415-555-4242.&#x27;</span>)</span><br><span class="line">mo.group(<span class="number">1</span>) <span class="comment">#&#x27;415&#x27;</span></span><br><span class="line">mo.group(<span class="number">2</span>) <span class="comment">#&#x27;555-4242&#x27;</span></span><br><span class="line">mo.group(<span class="number">0</span>) <span class="comment">#&#x27;415-555-4242&#x27;</span></span><br><span class="line">mo.group()  <span class="comment">#&#x27;415-555-4242&#x27;</span></span><br></pre></td></tr></table></figure><p>  或者，我们可以给每一部分的匹配内容命名，设定一个组别，然后把组名传入给<code>.group(&quot;name&quot;)</code>来提取数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式：    (?P&lt;组名&gt;正则式子)</span></span><br><span class="line"><span class="comment">#打印：    print(mo.group(&quot;组名&quot;))</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">&quot;&lt;div class=&#x27;西游记&#x27;&gt;&lt;span id=&#x27;10010&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">obj= re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;span id=&#x27;(?P&lt;id&gt;\d+)&#x27;&gt;(?P&lt;name&gt;\w+)&lt;/span&gt;&quot;</span>, re.S)</span><br><span class="line"></span><br><span class="line">result = obj.search(s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result.group()) <span class="comment">#结果:&lt;span id=&#x27;10010&#x27;&gt;中国联通&lt;/span&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result.group(<span class="string">&quot;id&quot;</span>)) <span class="comment"># 结果:10010 # 获取id组的内容</span></span><br><span class="line"><span class="built_in">print</span>(result.group(<span class="string">&#x27;name&quot;)) # 结果:中国联通 # 获取name组的内容</span></span><br></pre></td></tr></table></figure><h3 id="python读写JSON数据"><a href="#python读写JSON数据" class="headerlink" title="python读写JSON数据"></a>python读写JSON数据</h3><p>读（load）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = json.load(load_f)</span><br></pre></td></tr></table></figure><p>写（dump）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.dump(data, dump_f)</span><br></pre></td></tr></table></figure><p>总结如图：</p><div class="table-container"><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>json.dumps()</code></td><td>将python对象编码成<code>json</code>字符串</td></tr><tr><td><code>json.loads()</code></td><td>将<code>json</code>字符串解码成python对象</td></tr><tr><td><code>json.dump()</code></td><td>将python中的对象转化成<code>json</code>储存到文件中</td></tr><tr><td><code>json.load()</code></td><td>将文件中的<code>json</code>的格式转化成python对象提取出来</td></tr></tbody></table></div><h3 id="提取HTML内嵌的子页面（超链接）"><a href="#提取HTML内嵌的子页面（超链接）" class="headerlink" title="提取HTML内嵌的子页面（超链接）"></a>提取HTML内嵌的子页面（超链接）</h3><p>当我们用正则爬取内嵌在html代码里的数据时，有时候要提取出子页面的URL，这些URL一般被放在超链接中，和一串文字相呼应，在html中超链接的格式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href = &#x27;URL&#x27; title = &quot;浮动标题&quot;&gt;一串文字&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>用a标签来表示超链接。</p><h2 id="bs4解析"><a href="#bs4解析" class="headerlink" title="bs4解析"></a>bs4解析</h2><h3 id="html标记语言"><a href="#html标记语言" class="headerlink" title="html标记语言"></a>html标记语言</h3><p>html作为一种超文本标记语言，大体上有以下两种标签格式：</p><p>两端闭合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span> <span class="attr">属性</span> = <span class="string">”属性值“</span>&gt;</span>被标记的内容<span class="tag">&lt;/<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 自带闭合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用Beautiful-Soup解析数据"><a href="#用Beautiful-Soup解析数据" class="headerlink" title="用Beautiful Soup解析数据"></a>用Beautiful Soup解析数据</h3><p>安装bs4模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install bs4</span><br></pre></td></tr></table></figure><p>把页面源代码交给Beautiful Soup进行处理，生成bs对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>) <span class="comment">#指定为html解析器</span></span><br></pre></td></tr></table></figure><p>从bs对象中查找数据</p><p><code>find(标签, 属性 = 值)</code></p><p><code>find_all(标签, 属性 = 值)</code></p><p>关键字冲突问题：</p><p>当html的属性和python语法的关键字冲突时，可能会出现语法错误，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, <span class="keyword">class</span> = <span class="string">&quot;hq_table&quot;</span>) <span class="comment">#calss是python的关键字</span></span><br><span class="line"><span class="comment">#上述代码必定报错，class冲突了，可以用下划线解决歧义</span></span><br><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, class_ = <span class="string">&quot;hq_table&quot;</span>)</span><br><span class="line"><span class="comment">#或者用字典的方式传入属性-值对 </span></span><br><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, attrs = &#123;<span class="string">&quot;class&quot;</span> : <span class="string">&quot;hq_table&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>通过find和find_all函数，我们可以嵌套寻找标签内的内容，比如先找到A标签的内容，然后再在A标签里面找到B标签的内容，最后通过<code>.text</code>函数拿到<strong>被标签标记的内容</strong></p><p>当我们想要A标签里的属性值时，我们可以用get函数获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member = A.get(<span class="string">&#x27;属性&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="X-path解析"><a href="#X-path解析" class="headerlink" title="X path解析"></a>X path解析</h2><h3 id="安装模块和基础解析"><a href="#安装模块和基础解析" class="headerlink" title="安装模块和基础解析"></a>安装模块和基础解析</h3><p>x path是在XML文档中搜索内容的一门语言，兼容html（html是xml的一个子集）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><p>使用x path模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">form xpath <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;...&quot;&quot;&quot;</span> <span class="comment">#内容</span></span><br><span class="line"></span><br><span class="line">tree = etree.XML(xml)  <span class="comment">#生成一个对象</span></span><br><span class="line">tree = etree.parse(<span class="string">&quot;A.html&quot;</span>) <span class="comment">#解析文件并生成一个对象</span></span><br><span class="line">tree = etree.HTML(resp.text) <span class="comment">#解析HTML源码并生成一个对象</span></span><br><span class="line"></span><br><span class="line">result = tree.xpath()  <span class="comment">#使用xpath功能</span></span><br></pre></td></tr></table></figure><p>在x path解析里，用层级嵌套来寻找内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;book&gt;</span></span><br><span class="line"><span class="string">        &lt;name&gt;名字&lt;/name&gt;</span></span><br><span class="line"><span class="string">        &lt;nick&gt;东西1&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;author&gt;</span></span><br><span class="line"><span class="string">        &lt;nick, id = &quot;1&quot;&gt;周&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick, id = &quot;2&quot;&gt;陶&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick, id = &quot;3&quot;&gt;王&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;nick, id = &quot;4&quot;&gt;林&lt;/nick&gt;</span></span><br><span class="line"><span class="string">     &lt;/div&gt;</span></span><br><span class="line"><span class="string">     &lt;span&gt;</span></span><br><span class="line"><span class="string">     &lt;nick, id = &quot;5&quot;&gt;刘&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/span&gt;</span></span><br><span class="line"><span class="string">        author&gt;</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book&quot;</span>)  <span class="comment">#/表示层级关系，第一个/是根节点</span></span><br><span class="line"><span class="comment">#一个迭代器指向book</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/name/text()&quot;</span>)  <span class="comment">#text()拿文本</span></span><br><span class="line"><span class="comment">#[&#x27;名字&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book//nick/text()&quot;</span>)  <span class="comment">#//表示后代，之间有任意路径</span></span><br><span class="line"><span class="comment">#[&#x27;东西1&#x27;，&#x27;周&#x27;,&#x27;陶&#x27;,&#x27;王&#x27;,&#x27;林&#x27;,&#x27;刘&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/*/nick/text()&quot;</span>)   <span class="comment"># *是通配符，代表任意节点</span></span><br><span class="line"><span class="comment">#[&#x27;林&#x27;,&#x27;刘&#x27;]</span></span><br></pre></td></tr></table></figure><p>由上述例子：</p><p><code>text()</code>，用该函数提取文本</p><p><code>/</code>代表层级关系</p><p><code>*</code>代表通配符，能代表任意节点</p><p><code>//</code>代表任意后代，即任意层节点</p><h3 id="节点索引"><a href="#节点索引" class="headerlink" title="节点索引"></a>节点索引</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot; &quot;</span>&gt;</span>one<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot; &quot;</span>&gt;</span>two<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot; &quot;</span>&gt;</span>three<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;one&quot;</span>&gt;</span>小<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;two&quot;</span>&gt;</span>叶<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;three&quot;</span>&gt;</span>子<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>    </span><br></pre></td></tr></table></figure><p>对于上述的html，当我们想提取其中<code>&lt;li&gt;</code>标签下的内容时，会一次性提取三个，我们可以用索引来只提取某个。<strong>注意：索引从1开始</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree = etree.parse(<span class="string">&quot;A.html&quot;</span>)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/body/li[1]/a/text()&quot;</span>)</span><br><span class="line"><span class="comment">#[&#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure><p>而当我们想提取某个固定属性值的节点的内容，比如上述例子中的<code>href</code>为one的节点时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = tree.xpath(<span class="string">&quot;/body/li[@href = &quot;</span>one<span class="string">&quot;]/a/text()&quot;</span>)</span><br><span class="line"><span class="comment">#[&#x27;小&#x27;]</span></span><br></pre></td></tr></table></figure><p>用符号<code>@</code>加上属性 = 属性值，来索引特定的内容。</p><p><code>@</code>符号用来代表属性，使用<code>@属性</code>来拿到属性值</p><p><code>.</code>句点号在x path解析里代表当前节点，在相对查找时，一般用<code>./</code>加相对路径。</p><p>由此，通过循环提取出<code>href</code>内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li_list = tree.xpath(<span class="string">&quot;/body/li&quot;</span>) <span class="comment">#先查找到所用li节点</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">    <span class="built_in">print</span>(li.xpath(<span class="string">&quot;./a/@href&quot;</span>)) <span class="comment">#通过相对查找提取出a中的href</span></span><br><span class="line"><span class="comment">#[&#x27;one&#x27;]</span></span><br><span class="line">    <span class="comment">#[&#x27;two&#x27;]</span></span><br><span class="line">    <span class="comment">#[&#x27;three&#x27;]</span></span><br></pre></td></tr></table></figure><p> 注：通过检查元素能快速复制x path，右键 -&gt; copy -&gt; copy x path</p><h2 id="requests进阶"><a href="#requests进阶" class="headerlink" title="requests进阶"></a>requests进阶</h2><h3 id="处理cookie-登录网站"><a href="#处理cookie-登录网站" class="headerlink" title="处理cookie 登录网站"></a>处理cookie 登录网站</h3><p>有些网址的数据必须要在登录后才会出现马，想要爬取这些数据，我们就要模拟登录的过程。</p><p>登录的过程实际上是从服务器得到一串cookie，之后客户端带着cookie去请求服务器时，服务器就会发送对应cookie的数据到客户端，简化后就是：</p><p>1、登录 -&gt; 得到cookie</p><p>2、带着cookie -&gt; 请求内容</p><p>使用session进行请求，使得第一个请求到第二个请求之间的cookie不会丢失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成一个会话对象</span></span><br><span class="line">session = requests.session()</span><br><span class="line"><span class="comment">#登录</span></span><br><span class="line">url_login = <span class="string">&quot;//login&quot;</span></span><br><span class="line">url_for_data = <span class="string">&quot; &quot;</span></span><br><span class="line">data = &#123;用户名和密码&#125;</span><br><span class="line">session.post(url, data = data)</span><br><span class="line">resp = session.get(url_for_data)  <span class="comment">#两个操作在同一个会话对象上进行！！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了会话，在network里直接抓包请求头里的cookie，然后用字典的方式传入headers，同样实现了一样的效果，实际上会话操作也是带着有cookie的请求头去请求到data的。</p><h3 id="防盗链Referer"><a href="#防盗链Referer" class="headerlink" title="防盗链Referer"></a>防盗链<code>Referer</code></h3><p>防盗链：回溯本次请求的上一级请求是什么</p><p>防盗链是为了防止URL的不正常访问顺序存在的，例如URL2中存在防盗链URL1，那么当我们访问URL2时，就会对它进行一个溯源，若发现URL2的访问不源自于URL1，那么就会报错。</p><p>应对这个问题，简单的只需要将<code>Referer</code>的信息传入headers里就好了。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p> 代理：通过第三方的IP去发送请求</p><h2 id="提高爬虫效率"><a href="#提高爬虫效率" class="headerlink" title="提高爬虫效率"></a>提高爬虫效率</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>第一种写法：</p><p>导入多线程的线程类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">form threading <span class="keyword">import</span> Thread</span><br></pre></td></tr></table></figure><p>之后就可以开始编写自己的线程子类了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Mythread()</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>继承线程类后，改写run函数，将里面改写成要执行的内容。然后start函数提示线程开始工作（只是提醒可以开始工作了，具体工作时间由CPU决定）</p><p>在main函数创建一个线程对象，然后和main函数里的print一起工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">world!</span><br><span class="line">world!hello!</span><br><span class="line">hello!</span><br><span class="line">world!</span><br><span class="line">hello!</span><br><span class="line"></span><br><span class="line">world!hello!</span><br><span class="line">hello!</span><br></pre></td></tr></table></figure><p>就会出现这种异步的打印结果，说明多线程成功实现了。</p><p>第二种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">...</span><br><span class="line">t = Thread(target = func) <span class="comment">#创建线程并给线程安排任务</span></span><br></pre></td></tr></table></figure><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import process</span><br></pre></td></tr></table></figure><p>python里的写法和多线程基本一致。</p><h3 id="线程池（和进程池）"><a href="#线程池（和进程池）" class="headerlink" title="线程池（和进程池）"></a>线程池（和进程池）</h3><p>线程池：一次性开辟一些线程，直接给线程池提交任务，线程任务的调度交给线程池来完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br></pre></td></tr></table></figure><p>开辟一个线程池：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            t.submit(func, name = <span class="string">f&quot;线程<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Over!!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里创建了一个50个线程的线程池，提交<code>func</code>任务，由线程池来进行调度，部分结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程98</span><br><span class="line">线程97线程94</span><br><span class="line">线程90</span><br><span class="line"></span><br><span class="line">线程98</span><br><span class="line">线程97线程94</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程94</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程：当程序遇见了IO操作之类的阻塞时，可以选择性的切换到其他任务上。</p><p>在单线程的情况下，实现多任务异步操作，进行任务之间的切换实现CPU的无缝工作。</p><h3 id="python实现多任务异步"><a href="#python实现多任务异步" class="headerlink" title="python实现多任务异步"></a>python实现多任务异步</h3><p>带有<code>async</code>关键字的函数是一个协程函数，协程对象可以实现多任务异步操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fun1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fun2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fun3</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;!!&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = [fun1(), fun2(), fun3()]</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(t2 - t1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果大约为4秒钟，在异步条件下由最长的睡眠4秒决定程序运行时间，说明程序是并发运行。</span></span><br></pre></td></tr></table></figure><p><code>asyncio.run()</code>：运行协程函数。（一般用来运行最高层级的入口点 “main()” 函数）</p><p><code>await</code>：用于挂起阻塞的异步调用接口，一般放在协程对象前面</p><p><code>asyncio.wait()</code>：并发地运行传入的可迭代对象，比如我们传入一个协程函数列表</p><h3 id="新版python异步协程方法wait的改动"><a href="#新版python异步协程方法wait的改动" class="headerlink" title="新版python异步协程方法wait的改动"></a>新版python异步协程方法wait的改动</h3><p>python3.8后，协程对象要手动包装成task对象，方法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tasks = [</span><br><span class="line">asyncio.create_task(fun1()),</span><br><span class="line">asyncio.create_task(fun2()),</span><br><span class="line">asyncio.create_task(fun3())</span><br><span class="line">]    </span><br></pre></td></tr></table></figure><p>在上述例子中，要将协程对象fun1封装，然后再放到task列表里。</p><h3 id="aiohttp模块实现异步请求"><a href="#aiohttp模块实现异步请求" class="headerlink" title="aiohttp模块实现异步请求"></a><code>aiohttp</code>模块实现异步请求</h3><p>在之前的程序中，<code>request.get()</code>是同步操作的请求，要实现异步操作的请求，就要用到<code>aiohttp</code>模块。</p><p>创建一个<code>aiohttp.ClientSession()</code>对象，相当于requests模块的requests对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">aiodownload</span>(<span class="params">url</span>):</span><br><span class="line">    name = <span class="string">&quot;yours&quot;</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment">#创建一个异步对象session</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:   <span class="comment">#相当于resp = session.get(url)</span></span><br><span class="line">            <span class="comment">#等待请求后，写入到一个文件</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(name, mode = <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment">#读取内容是异步的，需要await挂起</span></span><br></pre></td></tr></table></figure><p>这个是一个大致的模板，然后将这个异步函数传入URL放到tasks列表里，用<code>asyncio.wait()</code>启动，再用<code>asyncio.run()</code>运行就大功告成了。</p><h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><p>selenium是一款自动化测试工具，可以打开浏览器然后像人一样去操作浏览器，程序员因此可以直接从selenium中直接提取网页数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>然后需要安装浏览器驱动，我的浏览器用的是Edge，所以直接去Edge官网下载浏览器驱动。</p><p><a href="https://developer.microsoft.com/zh-cn/microsoft-edge/tools/webdriver/?form=MA13LH">下载地址</a></p><p>下载完后，将压缩包解压到python解释器所在的文件夹。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">web = Edge()</span><br><span class="line"></span><br><span class="line">web.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用这个代码测试一下，如果能正常打开浏览器然后进入百度就说明可以使用了，不过这时候窗口顶部，会出现一行提示受自动化工具控制的字样，这个字样会影响我们爬取资源，之后再解决。</p><h3 id="用xpath提取数据"><a href="#用xpath提取数据" class="headerlink" title="用xpath提取数据"></a>用<code>xpath</code>提取数据</h3><p> selenium工具一般使用<code>xpath</code>来寻找各种元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web = Edge()</span><br><span class="line">web.find_element_by_xpath(&quot; &quot;)</span><br></pre></td></tr></table></figure><p>导入键盘模块可以模拟键盘输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line">web.find_element_by_xpath(<span class="string">&quot;搜索框的xpath&quot;</span>).send_keys(<span class="string">&quot;input&quot;</span>, Keys.ENTER)</span><br><span class="line"><span class="comment">#输入后回车</span></span><br></pre></td></tr></table></figure><h3 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#selenium中不会主动切换窗口，需要我们手动切换</span></span><br><span class="line"><span class="comment">#这里代表切换到窗口排列顺序中最后一个窗口的位置</span></span><br><span class="line">web.switch_to.window(web.windows_handles[-<span class="number">1</span>])</span><br><span class="line"><span class="comment">#在新窗口中提取内容</span></span><br><span class="line">content = web.find_element_by_xpath(<span class="string">&quot;&quot;</span>).text</span><br><span class="line"><span class="comment">#关闭窗口</span></span><br><span class="line">web.close()</span><br></pre></td></tr></table></figure><h3 id="下拉列表select"><a href="#下拉列表select" class="headerlink" title="下拉列表select"></a>下拉列表select</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"><span class="comment">#定位到下拉列表</span></span><br><span class="line">sel_el = web.find_element_by_xpath(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#对元素进行包装，包装成下拉菜单</span></span><br><span class="line">sel = Select(sel_el)</span><br><span class="line"><span class="comment">#让浏览器进行调整选项</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sel.options)):</span><br><span class="line">    <span class="comment">#按照索引进行切换</span></span><br><span class="line">    sel.select_by_index (i)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>除了根据索引切换，还能根据value值和文本text进行切换，如<code>select_by_visible_text()</code>和<code>select_by_value</code>。</p><h3 id="配置无头不显示浏览器"><a href="#配置无头不显示浏览器" class="headerlink" title="配置无头不显示浏览器"></a>配置无头不显示浏览器</h3><p>我们正常在使用selenium的时候会打开一个浏览器窗口，配置一下浏览器能够使窗口不显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.edge.options <span class="keyword">import</span> Options</span><br><span class="line">opt = Options()</span><br><span class="line">opt.add_argument(<span class="string">&quot;--headless&quot;</span>)</span><br><span class="line">opt.add_argument(<span class="string">&quot;--disable&quot;</span>)</span><br><span class="line">web = Edge(options = opt)</span><br></pre></td></tr></table></figure><h3 id="拿到页面Elements"><a href="#拿到页面Elements" class="headerlink" title="拿到页面Elements"></a>拿到页面Elements</h3><p>Elements是经过数据加载以及<code>js</code>等执行后，产生的html内容（大部分时不是页面源代码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(web.page_source)</span><br></pre></td></tr></table></figure><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的基础使用</title>
      <link href="/2024/07/16/git/"/>
      <url>/2024/07/16/git/</url>
      
        <content type="html"><![CDATA[<h2 id="Git的下载安装"><a href="#Git的下载安装" class="headerlink" title="Git的下载安装"></a>Git的下载安装</h2><p><a href="https://git-scm.com/download/win">windows版的git下载</a></p><p>我直接下载64位安装程序了，按需求下载。</p><p>之后就一直next就好了。</p><h2 id="Git初始化配置"><a href="#Git初始化配置" class="headerlink" title="Git初始化配置"></a>Git初始化配置</h2><h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config (可选) user.name &quot;your name&quot;</span><br><span class="line">git config (可选) user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure><p>可选选项指定了配置的范围：</p><p>省略（Local）：本地配置，只对本地仓库有效</p><p>—global：全局配置，对所有仓库有效</p><p>—system：系统配置，对所有用户有效（一般不会使用这个）</p><h3 id="保存用户名配置"><a href="#保存用户名配置" class="headerlink" title="保存用户名配置"></a>保存用户名配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><h3 id="列出配置信息"><a href="#列出配置信息" class="headerlink" title="列出配置信息"></a>列出配置信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><h2 id="Git新建仓库"><a href="#Git新建仓库" class="headerlink" title="Git新建仓库"></a>Git新建仓库</h2><h3 id="本地创建"><a href="#本地创建" class="headerlink" title="本地创建"></a>本地创建</h3><p>选择一个空的文件夹来创建本地仓库：</p><p>（可以在命令末尾指定仓库名字，会新建一个文件夹来存放.git）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>回显：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initialized empty Git repository in D:/learn-git/.git/</span><br></pre></td></tr></table></figure><p>这里的.git是一个隐藏目录，用普通的ls命令无法查看到，添加参数-a就能查看到。</p><p>进去之后能查看到git仓库的重要组成部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\learn-git\.git&gt;ls -altr</span><br><span class="line">total 20</span><br><span class="line">drwxrwxr-x    4 beiha    beiha            0 Jul 14 13:26 refs</span><br><span class="line">drwxrwxr-x    4 beiha    beiha            0 Jul 14 13:26 objects</span><br><span class="line">drwxrwxr-x    2 beiha    beiha            0 Jul 14 13:26 info</span><br><span class="line">drwxrwxr-x    2 beiha    beiha         4096 Jul 14 13:26 hooks</span><br><span class="line">-rw-rw-r--    1 beiha    beiha           73 Jul 14 13:26 description</span><br><span class="line">-rw-rw-r--    1 beiha    beiha          130 Jul 14 13:26 config</span><br><span class="line">-rw-rw-r--    1 beiha    beiha           23 Jul 14 13:26 HEAD</span><br><span class="line">drwxrwxr-x    3 beiha    beiha            0 Jul 14 13:26 ..</span><br><span class="line">drwxrwxr-x    6 beiha    beiha         4096 Jul 14 13:26 .</span><br></pre></td></tr></table></figure><h3 id="远程克隆"><a href="#远程克隆" class="headerlink" title="远程克隆"></a>远程克隆</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure><p>从github上克隆仓库到本地</p><h2 id="Git工作区域和文件状态"><a href="#Git工作区域和文件状态" class="headerlink" title="Git工作区域和文件状态"></a>Git工作区域和文件状态</h2><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>工作区working directory : 实际操作的目录，工作的目录。（.git所在的目录）</p><p>暂存区 staging area : 临时存储区域，用于保存即将提交到git仓库的内容。（.git/index）</p><p>本地仓库 Local respository : 包含完整代码和版本信息。（.git/objects）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add      工作区 -&gt; 暂存区</span><br><span class="line">git commit   暂存区 -&gt; 本地仓库</span><br></pre></td></tr></table></figure><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>未跟踪untrack</p><p>还未被git管理起来的文件，通过add指令可以管理到暂存区</p><p>未修改unmodified</p><p>已经被git管理起来的文件，rm指令可以删除。</p><p>已修改modified</p><p>被git管理起来后，修改的文件，通过add指令可以添加到暂存区，可以用checkout恢复文件</p><p>已暂存staged</p><p>已经到暂存区的文件，通过commit能更新到本地仓库，reset指令能重置暂存区（使用默认参数）。</p><h3 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h3><p>查看当前状态，添加-s参数能查看简略状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>在工作区新建一个文件，然后添加到暂存区</p><p>查看暂存区内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files</span><br></pre></td></tr></table></figure><p>git add命令支持通配符，诸如 . * 之类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>提交暂存区的所有文件到仓库，用-m参数指定提交信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot; &quot;</span><br></pre></td></tr></table></figure><p>最后可以用log命令查看提交记录信息。可以使用—oneline来参看简洁的提交记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure><h3 id="git回退版本"><a href="#git回退版本" class="headerlink" title="git回退版本"></a>git回退版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset 版本号</span><br></pre></td></tr></table></figure><p>git回退版本有三个参数可以选择：</p><p>—soft：回退版本并保存所有工作区和暂存区的所有修改内容</p><p>—hard：回退版本并丢弃所有工作区和暂存区的所有修改内容</p><p>—mixed：回退版本，但保留工作区的修改内容，不保存暂存区的内容</p><p>假如我们的回退操作是误操作，可以参看操作记录并回退到操作前的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset 之前的版本号</span><br></pre></td></tr></table></figure><p>但我们想要回退到之前的版本时，可以使用reset命令，或者时当你觉得多个操作可以统一成以此commit时，可以用混合或软回退版本，然后一次性提交工作区的文件。</p><h3 id="git比较文件差异"><a href="#git比较文件差异" class="headerlink" title="git比较文件差异"></a>git比较文件差异</h3><p>比较工作区与暂存区的文件差异</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>比较工作区与版本库的文件差异</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><p>比较暂存区和版本库的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p>比较两个特定版本之间的差异</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 两个版本库的id（可以使用HEAD）</span><br></pre></td></tr></table></figure><p>HEAD是git里面一个重要的概念，他指向分支的最新提交节点（最晚提交的）</p><p>特定的，我们经常比较当前版本和上一个版本的差异，git有特定的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD~ HEAD</span><br><span class="line">git diff HEAD^ HEAD</span><br></pre></td></tr></table></figure><p>额外的，波浪线后面添加数字n可以指定前n个版本</p><p>命令后还能添加特定的文件名字，比较特定的文件之间差异</p><p>命令后添加两个分支名比较分支之间的差异。</p><h3 id="git从版本库中删除文件"><a href="#git从版本库中删除文件" class="headerlink" title="git从版本库中删除文件"></a>git从版本库中删除文件</h3><h4 id="直接删除文件后提交"><a href="#直接删除文件后提交" class="headerlink" title="直接删除文件后提交"></a>直接删除文件后提交</h4><p>直接删除工作区中的文件，然后更新到暂存区再提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm file1.txt</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p>检查当前状态，提示你将工作区的修改更新到暂存区并提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add/rm file1.txt</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><h4 id="git-rm命令来删除文件"><a href="#git-rm命令来删除文件" class="headerlink" title="git rm命令来删除文件"></a>git rm命令来删除文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm filename</span><br></pre></td></tr></table></figure><p>git rm命令能一次性将文件从工作区和暂存区中同时删除，记得要提交到版本库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure><p>添加—cached参数能够将文件仅从<strong>版本库</strong>中删除。</p><h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h3><h4 id="忽略特定文件"><a href="#忽略特定文件" class="headerlink" title="忽略特定文件"></a>忽略特定文件</h4><p>作用：忽略掉不应该被加入到版本库中的文件，使得仓库体积更小。只要被该文件过滤的文件，将不会再被git检测到，并纳入版本控制中。</p><p>一般情况下，应该忽略以下这些文件：</p><p>1、系统或者软件自动生成的文件</p><p>2、编译产生的中间文件和结果文件</p><p>3、运行时产生的日志文件、缓存文件和临时文件</p><p>4、涉及身份密码等敏感文件</p><p>如何使用？</p><p>我们只要在该文件中列出需要忽略的文件的模式。</p><p>忽略某类文件的全部，一般都是使用通配符，比如忽略所有的.txt文件，只要在.gitignore文件里添加*.txt就好了。</p><p>注意：.gitignore文件对于已经存在于版本库中的文件是没有忽略作用的！！！！</p><h4 id="忽略文件夹"><a href="#忽略文件夹" class="headerlink" title="忽略文件夹"></a>忽略文件夹</h4><p>附：git默认不会将空的文件夹纳入到版本控制中</p><p>.gitignore文件还能忽略特定的文件夹，文件夹的格式是以斜线结尾的。</p><h4 id="gitignore的匹配规则’"><a href="#gitignore的匹配规则’" class="headerlink" title=".gitignore的匹配规则’"></a>.gitignore的匹配规则’</h4><p>1、#开头的表示注释</p><p>2、使用Blob模式匹配（简化的正则表达式）</p><p>3、感叹号！表示取反</p><p>4、**代表任意的中间目录</p><p><a href="github.com/github/gitignore">github上忽略文件的模板</a></p><h2 id="远程仓库github"><a href="#远程仓库github" class="headerlink" title="远程仓库github"></a>远程仓库github</h2><h3 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h3><p>通过在github上配置本地的SSH公钥，能够实现从本地push代码到github仓库的操作。</p><p>在用户的文件夹，输入以下命令生成rsa密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure><p>指定生成4096字节大小的rsa密钥。</p><p>注意：之后系统会提示你输入文件名称，如果你是第一次配置，可以直接跳过，文件名字默认是id_rsa；如果不是，输入特定的名称防止覆盖掉之前的密钥！！！</p><p>之后cd进.ssh文件，会有id_rsa和id_rsa.pub两个文件，第一个文件是私钥文件，第二个是公钥，复制公钥文件内容。</p><p>之后打开github的settings -&gt; SSH and GPG keys，配置一个新的SSHkeys。 </p><p>之后可以用git clone来克隆github上的仓库到本地了。（第一次clone会提示你这是一个未知的用户的密钥，需要你确认，输入yes就好了，然后你的.ssh文件夹会生成两个known_hosts文件）</p><h3 id="配置config文件"><a href="#配置config文件" class="headerlink" title="配置config文件"></a>配置config文件</h3><p>在.ssh文件夹中创建一个config文件输入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">Hostname github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>意思是，当我们访问githu.com时，指定使用.ssh文件夹下的id_rsa这个密钥。（之前电脑没配置好像也能用）</p><h3 id="提交到远程仓库"><a href="#提交到远程仓库" class="headerlink" title="提交到远程仓库"></a>提交到远程仓库</h3><p>推送本地仓库到远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>拉取远程仓库到本地仓库（省略分支名就默认拉main分支）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gti pull &lt;shortname&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; </span><br></pre></td></tr></table></figure><h3 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h3><p>先在github上创建一个空的仓库。</p><p>在本地仓库的终端输入（github中有提示）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>指定分支的名称为main</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main</span><br></pre></td></tr></table></figure><p>关联本地仓库的main和远程仓库的main</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u &lt;shortname&gt; main:main</span><br></pre></td></tr></table></figure><p>查看远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="git与vscode"><a href="#git与vscode" class="headerlink" title="git与vscode"></a>git与vscode</h2><p>将vscode配置到系统或者用户环境变量中后，可以在终端的任何地方使用以下命令来进入vscode代码编辑器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>在vscode中打开git管理的仓库后，点击侧边栏的源代码管理，可以看到仓库当前的状态。只要工作区的文件发生了修改，源代码管理就能检测到更改，在这里可以比较修改前后的代码（打开工作树），放弃修改（返回图标），添加到暂存区（加号图标），commit文件，还有查看文件的状态，以下列出各种状态的缩写：</p><p><code>??</code>（Untracked）：未跟踪</p><p><code>M</code>（Modified）：已修改</p><p><code>A</code>（Added）：已添加到暂存</p><p><code>D</code>（Deleted）：已删除</p><p><code>R</code>（Renamed）：已重命名</p><p><code>U</code>（Updated）：已更新未合并</p><p> vscode还能同步本地仓库和远程仓库，在源代码管理里都能查看到。</p><h2 id="git与branch"><a href="#git与branch" class="headerlink" title="git与branch"></a>git与branch</h2><p>git仓库里的分支是为了集成开发而存在的，在共同管理的项目中，每个人负责某个分支的开发，最终再集成到main中，高效且不会互相干扰。</p><p>以下命令创建分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><p>查看分支状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>切换分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch 分支名</span><br></pre></td></tr></table></figure><p>这些新建的分支是独立于main分支而存在的，本身的修改不会影响到main分支。</p><h3 id="合并分支merge"><a href="#合并分支merge" class="headerlink" title="合并分支merge"></a>合并分支merge</h3><p>假如我们处在main分支，要将dev分支合并到main分支时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>我们当时所处在的复制为目标分支，merge后面的分支名为将要合并到目标分支的分支。</p><p>合并后git会默认产生一次提交，需要输入提交的消息。</p><p> 查看分支图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure><p>删除已经完成合并的无用分支：</p><p>注意：一定是合并后的分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><p>我们也可以强制删除任意分支，包括未合并的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D branch_name</span><br></pre></td></tr></table></figure><h3 id="合并分支时的冲突"><a href="#合并分支时的冲突" class="headerlink" title="合并分支时的冲突"></a>合并分支时的冲突</h3><p>当我们合并的两个分支之间修改了同一份文件，会发生合并分支冲突。</p><p>这时我们需要手工编辑这个文件之后再重新提交。提交之后会自动完成合并的过程。</p><p>如果我们在编辑过程时不想合并了，我们可以终止合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><h3 id="回退和rebase"><a href="#回退和rebase" class="headerlink" title="回退和rebase"></a>回退和rebase</h3><p>rebase也能进行合并操作，但不同于merge，我们可以在任意分支上进行合并操作。</p><p>当我们在main分支上时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase dev</span><br></pre></td></tr></table></figure><p>当我们在dev分支上时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p>rabase 的原理是变基：</p><p>每个分支的最新提交记录都有一个HEAD指针，rebase操作会先找到这两个分支的共同祖先，然后把当前分支上HEAD指向的最新提交记录到共同祖先之间的所有提交移动到目标分支的最新提交后面。</p><p>由此可见，上面两种操作虽然都能够将两个分支的文件合并，但是顺序略有不同，直观反映为HEAD指针的指向。</p><p>假如一个分支已经删除，可以使用checkout命令回退到分支存在时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch_name&gt; &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><p>如果不写入提交记录的哈希值，这个指令默认创建一个新分支。</p><h3 id="合并方法之间的差异"><a href="#合并方法之间的差异" class="headerlink" title="合并方法之间的差异"></a>合并方法之间的差异</h3><h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><p>优点：不会破坏原分支的提交历史，方便回溯和查看</p><p>缺点：会产生额外的提交节点，分支图变得复杂</p><h4 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h4><p>优点：不会新增额外的提交记录，形成线性历史，比较直观和干净</p><p>缺点：会改变提交历史，避免在公共的分支使用（一般在集成开发不使用）。</p><h3 id="git分支的工作流"><a href="#git分支的工作流" class="headerlink" title="git分支的工作流"></a>git分支的工作流</h3><h4 id="给提交记录打标签"><a href="#给提交记录打标签" class="headerlink" title="给提交记录打标签"></a>给提交记录打标签</h4><p>附注标签，包含具体的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a -a &lt;tag_name&gt; -m &lt;tag_message&gt; </span><br></pre></td></tr></table></figure><p>轻量标签，本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><p>后期打标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tag_name&gt; &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin &lt;tagname&gt;</code>。</p><h4 id="分支命名规范"><a href="#分支命名规范" class="headerlink" title="分支命名规范"></a>分支命名规范</h4><p>版本发布分支：使用tag来区分</p><p>功能分支：feature</p><p>修复bug分支：hotfix</p><p>开发分支：develop</p><p>……</p><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>1、定期合并已经成功验证的分支，及时删除已经合并的分支</p><p>2、保持合适的分支数量</p><p>3、为分支设置合适的管理权限</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析Cache访存模式对系统性能的影响</title>
      <link href="/2024/07/16/%E5%88%86%E6%9E%90Cache%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%BC%8F%E5%AF%B9%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2024/07/16/%E5%88%86%E6%9E%90Cache%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%BC%8F%E5%AF%B9%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="分析Cache访存模式对系统性能的影响"><a href="#分析Cache访存模式对系统性能的影响" class="headerlink" title="分析Cache访存模式对系统性能的影响"></a>分析Cache访存模式对系统性能的影响</h2><p>表1、普通矩阵乘法与及优化后矩阵乘法之间的性能对比</p><div class="table-container"><table><thead><tr><th>矩阵大小</th><th>100</th><th>500</th><th>1000</th><th>1500</th><th>2000</th><th>2500</th><th>3000</th></tr></thead><tbody><tr><td>一般算法执行时间</td><td>0.005</td><td>0.622</td><td>5.177</td><td>25.763</td><td>51.578</td><td>116.024</td><td>193.515</td></tr><tr><td>优化算法执行时间</td><td>0.004</td><td>0.384</td><td>3.070</td><td>12.480</td><td>22.462</td><td>49.304</td><td>82.696</td></tr><tr><td>加速比speedup</td><td>1.337</td><td>1.620</td><td>1.686</td><td>2.064</td><td>2.296</td><td>2.353</td><td>2.340</td></tr></tbody></table></div><p>加速比定义：加速比=优化前系统耗时/优化后系统耗时；</p><p>所谓加速比，就是优化前的耗时与优化后耗时的比值。加速比越高，表明优化效果越明显</p><h4 id="分析原因："><a href="#分析原因：" class="headerlink" title="分析原因："></a>分析原因：</h4><p>传统的矩阵乘法算法通过遍历结果矩阵 c 的每一行和每一列来计算每个元素的值。在这种访问模式下，矩阵 a 的访问步长为 1，表现出良好的空间局部性，即连续访问的内存地址相邻，有利于缓存命中。</p><p>然而，矩阵 b 的访问步长为 size，意味着每次访问的内存地址间隔较大，导致缓存命中率较低。</p><p><img src="/Images/image-20240614144958987.png" alt="image-20240614144958987"></p><p>为了优化缓存性能，我们可以采用一种改进的访问模式。通过遍历矩阵 a 的每个元素，将每个元素对结果矩阵 c 的贡献累加到对应位置，从而实现对矩阵 b 的连续访问，即步长为 1 的访问模式。这种优化策略有效地提高了矩阵 b 的缓存命中率，从而显著提升矩阵乘法的性能。</p><p>从这个矩阵乘法的例子中，我们可以看出访问模式对缓存性能具有非常显著影响。</p><h2 id="Cache层次和L1cacheline测试代码"><a href="#Cache层次和L1cacheline测试代码" class="headerlink" title="Cache层次和L1cacheline测试代码"></a>Cache层次和L1cacheline测试代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::random_device rd; <span class="comment">// 随机数生成</span></span><br><span class="line"><span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; sizes&#123;<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">384</span>, <span class="number">512</span>, <span class="number">768</span>, <span class="number">1024</span>, <span class="number">1536</span>, <span class="number">2048</span>, <span class="number">3072</span>, <span class="number">4096</span>, <span class="number">5120</span>, <span class="number">6144</span>, <span class="number">7168</span>, <span class="number">8192</span>, <span class="number">10240</span>, <span class="number">12288</span>, <span class="number">16384</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; strides&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">96</span>,<span class="number">128</span>,<span class="number">192</span>,<span class="number">256</span>,<span class="number">512</span>,<span class="number">1024</span>,<span class="number">1536</span>,<span class="number">2048</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_cache</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = size / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="type">char</span> *arr = <span class="keyword">new</span> <span class="type">char</span>[n];  <span class="comment">//申请存储空间</span></span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">1</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>) * n); <span class="comment">//初始化为 1 </span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">0</span>, n - <span class="number">1</span>)</span></span>; <span class="comment">// 0-n-1的随机数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; position;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span> &lt;&lt; <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">        position.<span class="built_in">push_back</span>(<span class="built_in">num</span>(gen));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">        sum += arr[position[i]]; <span class="comment">// 随机访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; t = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> total = t.<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; (size &gt;&gt; <span class="number">10</span>) &lt;&lt; <span class="string">&quot;KB, time = &quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_cache_line</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size = (<span class="number">1</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">    <span class="type">int</span> n = size / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="type">char</span> *arr = <span class="keyword">new</span> <span class="type">char</span>[n];</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">1</span>, n * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : strides)&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += s)&#123;</span><br><span class="line">                sum += arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>&gt; t = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">        <span class="type">double</span> total = t.<span class="built_in">count</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;stride = &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;Byte, time = &quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : sizes)&#123;</span><br><span class="line">        <span class="built_in">test_cache</span>(s * <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">test_cache_line</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Images/image-20240614145125146.png" alt="image-20240614145125146"></p><p><img src="/Images/image-20240614145134331.png" alt="image-20240614145134331"></p><p>对于缓存大小，很容易发现，在128kb到384kb之间时间发生断层，1024kb到2048kb之间的时间差距相比其他也较大，4096kb到5120kb之间发生断层，之后的时间差距普遍较大，推测是储存空间超出缓存后直接访问主存导致的。</p><p>对于cache行测试，发现步长大于32byte后变化较大，推测L1的cacheline为32B</p><p><img src="/Images/image-20240614145151076.png" alt="image-20240614145151076"></p><p>发现L3缓存的大小和计算结果有较大出入，换了别人的新电脑测试代码后无较大出入，猜测是本人电脑L3缓存硬件老化或者其他原因导致的。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>通过本次实验，我们加深了对Cache工作原理的理解，体验了程序中访存模式变化对Cache效率和程序性能的影响。同时，通过实际的测试和分析，我们获得了关于X86机器上Cache层次结构和容量的信息。这些实验结果对于优化程序性能和了解计算机体系结构有着重要的指导意义。</p><p>通过实验，我们得出了以下结论和分析：</p><ol><li>分析Cache访存模式对系统性能的影响：</li></ol><p>通过对矩阵乘法算法的优化，我们发现访存模式对系统性能有显著影响。通过改变矩阵大小，我们记录了不同大小下的执行时间，并计算了加速比。优化后的算法在大部分情况下都显著提升了性能，加速比较高，说明优化后的访存模式能够更好地利用缓存，提高缓存命中率，从而提升程序性能。</p><ol><li>测量分析出Cache的层次结构、容量以及L1 Cache行的大小：</li></ol><p>通过设计方案并编写代码，我们成功测量了X86机器上的Cache层次结构和容量，并推断出L1 Cache行的大小。通过测量不同访问步长下的内存访问速度变化，我们观察到了缓存的局部性和缓存行的影响。根据实验数据，我们推测出L1 Cache行的大小约为32-64字节，与经验结果相吻合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实验报告 </tag>
            
            <tag> 系统 </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置docker和拉取镜像源</title>
      <link href="/2024/07/16/%E9%85%8D%E7%BD%AEdocker/"/>
      <url>/2024/07/16/%E9%85%8D%E7%BD%AEdocker/</url>
      
        <content type="html"><![CDATA[<h2 id="配置docker"><a href="#配置docker" class="headerlink" title="配置docker"></a>配置docker</h2><h3 id="download-docker"><a href="#download-docker" class="headerlink" title="download docker"></a>download docker</h3><p><a href="https://www.docker.com/">docker</a>下载</p><h3 id="配置docker-hub-mirror"><a href="#配置docker-hub-mirror" class="headerlink" title="配置docker hub mirror"></a>配置docker hub mirror</h3><p>有时候可能因为网络波动导致拉取docker失败，可以尝试把镜像源换成国内的。</p><p>打开docker右上角的设置图标，然后选择docker Engine，将下面代码复制到框里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;builder&quot;: &#123;</span><br><span class="line">    &quot;gc&quot;: &#123;</span><br><span class="line">      &quot;defaultKeepStorage&quot;: &quot;20GB&quot;,</span><br><span class="line">      &quot;enabled&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;experimental&quot;: false,</span><br><span class="line">  &quot;features&quot;: &#123;</span><br><span class="line">    &quot;buildkit&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">//这里放国内镜像源</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有些暂时可以用的源，不过建议去网上查找最新的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;https://hub.uuuadc.top&quot;,</span><br><span class="line">&quot;https://docker.anyhub.us.kg&quot;,</span><br><span class="line">&quot;https://dockerhub.jobcher.com&quot;,</span><br><span class="line">&quot;https://dockerhub.icu&quot;,</span><br><span class="line">&quot;https://docker.ckyl.me&quot;,</span><br><span class="line">&quot;https://docker.awsl9527.cn&quot;</span><br></pre></td></tr></table></figure><h3 id="拉取镜像源"><a href="#拉取镜像源" class="headerlink" title="拉取镜像源"></a>拉取镜像源</h3><p>右键鼠标打开powershell，输入docker检测docker是否安装成功。</p><p>然后就可以通过pull指令来拉取docker仓库的镜像源了。</p><p>举例我这里要拉去编译原理学习的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull maxxing/compiler-dev</span><br></pre></td></tr></table></figure><p>如果出现unexpected EOF，大概率是网络波动，多试几次就好了。</p><h3 id="docker的基本用法"><a href="#docker的基本用法" class="headerlink" title="docker的基本用法"></a>docker的基本用法</h3><p>这里只介绍怎么创建容器，启动容器，删除容器。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run maxxing/compiler-dev ls -l /</span><br></pre></td></tr></table></figure><p>用这条指令执行了下面步骤：</p><p>1、使用compiler-dev这个镜像创建一个临时的容器</p><p>2、启动这个临时容器</p><p>3、在容器里执行ls -l /</p><p>4、关闭容器</p><p>关闭了容器但是并不会删除它，使用下面指令可以查看所有容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>使用下面命令删除容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器编号</span><br></pre></td></tr></table></figure><p>上述操作可以一步到位，从创建执行到删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm maxxing/compiler-dev ls -l /</span><br></pre></td></tr></table></figure><p>另一种用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm maxxing/compiler-dev bash</span><br></pre></td></tr></table></figure><p>这条命令会使用 <code>compiler-dev</code> 创建容器, 并在其中执行 <code>bash</code>——这是许多 Linux 发行版的默认 Shell, 也就是大</p><p>家启动终端后看到的命令行界面. 为了能在 Shell 中操作, 我们使用了 <code>-it</code> 参数, 这个参数会开启容器的 <code>stdin</code> 以</p><p>便我们输入 (<code>-i</code>), 同时 Docker 会为容器分配一个终端 (<code>-t</code>)</p><p>执行完这条命令之后, 你会发现你进入了容器的 Shell, 你可以在其中执行任何命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@38bd65234ad2:~#</span><br></pre></td></tr></table></figure><p>如需退出, 你可以执行 <code>exit</code>, 或者按下 <code>Ctrl + D</code>. 因为我们添加了 <code>--rm</code> 选项, Docker 会在退出后删除刚刚的容</p><p>器, 所以在这种情况下请一定不要在容器里保存重要的内容</p><p>关于docker访问宿主机中文件的操作：</p><p>在许多情况下, 我们需要让 Docker 容器访问宿主系统中的文件. 比如你的编译器存放在宿主机的 </p><p><code>/home/max/compiler</code> 目录下, 你希望 Docker 容器也能访问到这个目录里的内容, 这样你就可以使用容器中的</p><p>测试脚本测试你的编译器了. 你可以执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v /home/max/compiler:/root/compiler maxxing/compiler-dev bash</span><br></pre></td></tr></table></figure><p>这条命令和之前的命令相比多了一个 <code>-v /home/max/compiler:/root/compiler</code> 选项, 这个选项代表: 我希望把</p><p>宿主机的 <code>/home/max/compiler</code> 目录, 挂载 (mount) 到容器的 <code>/root/compiler</code> 目录. 这样, 在进入容器之后, 我</p><p>们就可以通过访问 <code>/root/compiler</code> 来访问宿主机的 <code>/home/max/compiler</code> 目录了</p><p><a href="https://docs.docker.com/reference/cli/docker/">docker官方文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划刷题1</title>
      <link href="/2024/06/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98/"/>
      <url>/2024/06/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="P1216-USACO1-5-IOI1994-数字三角形-Number-Triangles"><a href="#P1216-USACO1-5-IOI1994-数字三角形-Number-Triangles" class="headerlink" title="P1216 [USACO1.5] [IOI1994]数字三角形 Number Triangles"></a>P1216 [USACO1.5] [IOI1994]数字三角形 Number Triangles</h2><p>该题的思路是，从底层数开始，逐渐向上更新。</p><p>例如：<br>         1</p><p>​    2         3</p><p>5         6        7</p><p>经过一次更新后，从倒数第二层开始，对于2，它的两个孩子5和6中6更大，于是2更新为2+6=8，同理3更新为10之后就有：</p><p>​         1</p><p>​    8         10</p><p>5         6        7</p><p>层数向上移动一层，接着从第一层继续执行上述操作，1+10=11，所以有：</p><p>​         11</p><p>​    8         10</p><p>5         6        7</p><p>输出第一个数就是最大路径和，1 + 3 + 7 = 11</p><p>很容易发现，每一次更新，把被更新的数变成由它向下辐射的三角中的，最大路径和。例如上例中的三角3 6 7, 3经过更新后变成三角3 6 7的最大路径和，3 + 7 = 10。采用这种分治的思想，从小到大，递归得到由第一个数向下辐射的三角的最大路径和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">500510</span>];</span><br><span class="line"><span class="type">int</span> r, j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; r;</span><br><span class="line">    <span class="type">int</span> cnt = r * (r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt -= r;<span class="comment">//从倒数第二层开始更新</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;<span class="comment">//&#x27;i&#x27; is floor</span></span><br><span class="line">        j = i;</span><br><span class="line">        cnt -= i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            f[cnt + j] += std::<span class="built_in">max</span>(f[cnt + j + i], f[cnt + j + i + <span class="number">1</span>]);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int c = 1;</span></span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= r; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= i; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         std::cout &lt;&lt; f[c] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//         c++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//输出样例测试，打印出更新后的三角塔</span></span><br><span class="line">    std::cout &lt;&lt; f[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1048-NOIP2005-普及组-采药"><a href="#P1048-NOIP2005-普及组-采药" class="headerlink" title="P1048 [NOIP2005 普及组] 采药"></a>P1048 [NOIP2005 普及组] 采药</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> time, num, t, value;</span><br><span class="line">    std::cin &gt;&gt; time &gt;&gt; num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; t &gt;&gt; value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = time; j &gt;= t; j--)&#123;</span><br><span class="line">            f[j] = std::<span class="built_in">max</span>(f[j], f[j - t] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; f[time];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2196-NOIP1996-提高组-挖地雷"><a href="#P2196-NOIP1996-提高组-挖地雷" class="headerlink" title="P2196 [NOIP1996 提高组] 挖地雷"></a>P2196 [NOIP1996 提高组] 挖地雷</h2><p>有向无边权，有点权的图。</p><p>思路是，设置一个数组max，存储第 i 个节点前最大地雷和，同理于上述背包问题里的数组 f。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num, t, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;, max[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> path[<span class="number">30</span>][<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> pre[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= num; j++)&#123;</span><br><span class="line">            std::cin &gt;&gt; path[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num; j++)&#123;</span><br><span class="line">            <span class="comment">//遍历每条路径</span></span><br><span class="line">            <span class="keyword">if</span>(path[j][i] &amp;&amp; max[j] &gt; max[i])&#123;</span><br><span class="line">                max[i] = max[j];</span><br><span class="line">                pre[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max[i] += f[i];</span><br><span class="line">        <span class="keyword">if</span>(max[i] &gt; ans)&#123;</span><br><span class="line">            ans = max[i];</span><br><span class="line">            t = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = t; i != <span class="number">0</span>; i = pre[i], cnt++)&#123;</span><br><span class="line">        f[cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        std::cout &lt;&lt; f[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>&lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1434-SHOI2002-滑雪"><a href="#P1434-SHOI2002-滑雪" class="headerlink" title="P1434[SHOI2002] 滑雪"></a>P1434[SHOI2002] 滑雪</h2><p>这是一道深度搜索问题，DFS。</p><p>通过遍历每个节点，然后往深处搜索最大路径，其中搜索过的路径会被数组f[] []记录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> map[<span class="number">110</span>][<span class="number">110</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[<span class="number">110</span>][<span class="number">110</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> r, c, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y])&#123;&#125;<span class="comment">//如果搜过</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        f[x][y] = <span class="number">1</span>;<span class="comment">//最小也有一格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x0 = x + dx[i], y0 = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x0 &gt; <span class="number">0</span> &amp;&amp; y0 &gt;<span class="number">0</span> &amp;&amp; x0 &lt;= r &amp;&amp; y0 &lt;= c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[x][y] &gt; map[x0][y0])&#123;</span><br><span class="line">                    f[x][y] = std::<span class="built_in">max</span>(f[x][y], <span class="built_in">dfs</span>(x0, y0) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)&#123;</span><br><span class="line">            std::cin &gt;&gt; map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)&#123;</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深大计系1实验四--点格棋</title>
      <link href="/2024/06/10/%E8%AE%A1%E7%B3%BB1%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
      <url>/2024/06/10/%E8%AE%A1%E7%B3%BB1%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h2><h3 id="一、实验目的与要求"><a href="#一、实验目的与要求" class="headerlink" title="一、实验目的与要求"></a>一、实验目的与要求</h3><p>使用LC3汇编语言实现点格棋，根据英文指导文档实现各各模块之后再组合。</p><p>什么是点格棋？</p><p>Dots and Boxes is a two-player game played on a variable-size grid of dots. For this assignment, the playing board is a 4x4 grid of dots, and the two players are denoted by two symbols: 1 and 2</p><p>简单来说，就是使用连接点与点之间来实现圈地的游戏，谁最后将某个方块圈起来，那个方块就归谁，一个方块记一分，直到4x4下16个方块全都有所属时游戏结束。</p><h3 id="二、实验步骤与过程"><a href="#二、实验步骤与过程" class="headerlink" title="二、实验步骤与过程"></a>二、实验步骤与过程</h3><h4 id="主要函数罗列："><a href="#主要函数罗列：" class="headerlink" title="主要函数罗列："></a>主要函数罗列：</h4><p>大体在main函数里实现以下几个函数：</p><p>1、print_map()：打印每次下棋后的地图</p><p>2、display_prompt()：更新玩家控制权，控制棋子坐标输入和退出游戏</p><p>3、is_input_valid()：检测坐标输入是否合法</p><p>4、is_occupied()：检测输入的坐标是否已经被之前输入的占用</p><p>5、apply_move()：实现棋子在地图上的更新</p><p>6、fill_box()：重中之重，检测每次输入是否导致了玩家得分，并且将被圈起来的方块的占位符更新为队友玩家的编号</p><p>7、is_gameover()：检测游戏是否达成结束条件</p><p><img src="/Images/wps1-1718034849873-1.jpg" alt="img"></p><h4 id="实现步骤一：C语言代码逻辑框架实现"><a href="#实现步骤一：C语言代码逻辑框架实现" class="headerlink" title="实现步骤一：C语言代码逻辑框架实现"></a>实现步骤一：C语言代码逻辑框架实现</h4><p>LC3汇编语言属于机器语言，有多个函数的大工程不便于直接实现。在流程图的基础上，先用C语言写出了点格棋游戏。</p><p><img src="/Images/wps2.png" alt="img"></p><p><img src="/Images/wps3-1718034956526-4.jpg" alt="img"></p><h4 id="实现步骤二：分模块化实现LC3程序"><a href="#实现步骤二：分模块化实现LC3程序" class="headerlink" title="实现步骤二：分模块化实现LC3程序"></a>实现步骤二：分模块化实现LC3程序</h4><p>在C语言的框架下，我们一步一步翻译成LC3。</p><p><img src="/Images/wps4-1718034983367-6.jpg" alt="img"></p><h4 id="实现步骤三：编译和调试LC3代码"><a href="#实现步骤三：编译和调试LC3代码" class="headerlink" title="实现步骤三：编译和调试LC3代码"></a>实现步骤三：编译和调试LC3代码</h4><p>通过asm-&gt;编译代码，一开始出现了不少error，诸如未定义的label，语法错误等，有些错误是等到运行时才知道的，需要通过一步步debug来发现问题。</p><p><img src="/Images/wps5-1718035005044-8.jpg" alt="img"></p><p>调试并排除完错误后，运行程序，得到正确结果：</p><p><img src="/Images/wps6-1718035019052-10.jpg" alt="img"></p><h3 id="三、实验结论或体会"><a href="#三、实验结论或体会" class="headerlink" title="三、实验结论或体会"></a>三、实验结论或体会</h3><p>通过此次实验，我学到了：</p><p>1、通过LC3仿真器运行和调试LC3代码，通过ide编写可执行的LC3代码。</p><p>2、磨炼了自己的心性，耐心地编写LC3汇编代码，并调试出错误。</p><p>3、通过阅读英语lab指导，提高了阅读计算机类英语文档的水平。</p><p>4、通过C-&gt;LC3的代码编写过程，熟悉了C语言在LC3框架上的底层实现。</p><p>5、对LC3的各种伪操作和命令有了更深入的理解。</p><h2 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h2><h3 id="点格棋c语言实现"><a href="#点格棋c语言实现" class="headerlink" title="点格棋c语言实现"></a>点格棋c语言实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*data defination*/</span></span><br><span class="line"><span class="type">int</span> member = <span class="number">1</span>, current_mem = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r0, r1, r2, r3, r4;</span><br><span class="line"><span class="type">int</span> score[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> row_number, column_letter = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> map[<span class="number">49</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*function of every step*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++)&#123;</span><br><span class="line">            map[<span class="number">7</span> * i + j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j += <span class="number">2</span>)&#123;</span><br><span class="line">            map[<span class="number">7</span> * i + j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d : %d\n&quot;</span>, score[<span class="number">1</span>], score[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ABCDEFG\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, map[<span class="number">7</span> * i + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_prompt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    current_mem = member;</span><br><span class="line">    <span class="keyword">if</span>(member == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Player 1, input a move  (or &#x27;Q&#x27; to quit):&quot;</span>);</span><br><span class="line">        member = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Player 2, input a move  (or &#x27;Q&#x27; to quit):&quot;</span>);</span><br><span class="line">        member = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    row_number = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(row_number == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        column_letter = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_input_valid</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*r0 contains row number 0-6, r1 contains column letter A-G*/</span></span><br><span class="line">    r0 = row_number - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    r1 = column_letter - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(((r0 % <span class="number">2</span>) &amp;&amp; !(r1 % <span class="number">2</span>)) || (!(r0 % <span class="number">2</span>) &amp;&amp; (r1 % <span class="number">2</span>)))&#123;</span><br><span class="line">        r3 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        r3 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translate_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*it was implemented in &quot;is_input_valid&quot; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_occupied</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map[<span class="number">7</span> * r0 + r1] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">        r3 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        r3 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_address</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apply_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r0 % <span class="number">2</span>)&#123;</span><br><span class="line">        map[<span class="number">7</span> * r0 + r1] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        map[<span class="number">7</span> * r0 + r1] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill_box</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map[<span class="number">7</span> * r0 + r1] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r1 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[<span class="number">7</span> * r0 + r1 - <span class="number">2</span>] == <span class="string">&#x27;|&#x27;</span> &amp;&amp; map[<span class="number">7</span> * (r0 - <span class="number">1</span>) + r1 - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; map[<span class="number">7</span> * (r0 + <span class="number">1</span>) + r1 - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                map[<span class="number">7</span> * r0 + r1 - <span class="number">1</span>] = current_mem + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                r3 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r1 != <span class="number">6</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[<span class="number">7</span> * r0 + r1 + <span class="number">2</span>] == <span class="string">&#x27;|&#x27;</span> &amp;&amp; map[<span class="number">7</span> * (r0 - <span class="number">1</span>) + r1 + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; map[<span class="number">7</span> * (r0 + <span class="number">1</span>) + r1 + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                map[<span class="number">7</span> * r0 + r1 + <span class="number">1</span>] = current_mem + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                r3 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(map[<span class="number">7</span> * r0 + r1] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r0 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[<span class="number">7</span> * (r0 - <span class="number">2</span>) + r1] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; map[<span class="number">7</span> * (r0 - <span class="number">1</span>) + r1 - <span class="number">1</span>] == <span class="string">&#x27;|&#x27;</span> &amp;&amp; map[<span class="number">7</span> * (r0 - <span class="number">1</span>) + r1 + <span class="number">1</span>] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                map[<span class="number">7</span> * (r0 - <span class="number">1</span>) + r1] = current_mem + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                r3 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r0 != <span class="number">6</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[<span class="number">7</span> * (r0 + <span class="number">2</span>) + r1] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; map[<span class="number">7</span> * (r0 + <span class="number">1</span>) + r1 - <span class="number">1</span>] == <span class="string">&#x27;|&#x27;</span> &amp;&amp; map[<span class="number">7</span> * (r0 + <span class="number">1</span>) + r1 + <span class="number">1</span>] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                map[<span class="number">7</span> * (r0 + <span class="number">1</span>) + r1] = current_mem + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                r3 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    score[current_mem] += r3;</span><br><span class="line">    sum += r3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_gameover</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">16</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(score[<span class="number">1</span>] &gt; score[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Game over. Player 1 is the winner!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Game over. Player 2 is the winner!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="built_in">initialize_map</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">print_map</span>();</span><br><span class="line">        <span class="built_in">display_prompt</span>();</span><br><span class="line">        <span class="built_in">is_input_valid</span>();</span><br><span class="line">        <span class="keyword">if</span>(r3 == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;invalid input&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">is_occupied</span>();</span><br><span class="line">        <span class="keyword">if</span>(r3 == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;invalid input&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">apply_move</span>();</span><br><span class="line">        <span class="built_in">fill_box</span>();</span><br><span class="line">        <span class="built_in">is_gameover</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC3源代码"><a href="#LC3源代码" class="headerlink" title="LC3源代码"></a>LC3源代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">AND R5 R5 #0  ;R5存储游戏控制权，0是player1，1是player2</span><br><span class="line">LOOP0JSR print_map</span><br><span class="line">JSR display_prompt</span><br><span class="line"></span><br><span class="line">JSR is_input_valid</span><br><span class="line">AND R0 R0 #0</span><br><span class="line">ADD R0 R3 #1</span><br><span class="line">BRz invalid_R3</span><br><span class="line"></span><br><span class="line">JSR is_occupied</span><br><span class="line">AND R0 R0 #0</span><br><span class="line">ADD R0 R3 #1</span><br><span class="line">BRz invalid_R3</span><br><span class="line"></span><br><span class="line">JSR apply_move</span><br><span class="line">JSR fill_box</span><br><span class="line">JSR is_gameover</span><br><span class="line">BRnzp DONE0</span><br><span class="line">invalid_R3 LEA R0 invalid_input</span><br><span class="line">PUTS</span><br><span class="line">DONE0BRnzp LOOP0</span><br><span class="line"></span><br><span class="line">HALT</span><br><span class="line">invalid_input .STRINGZ &quot;\ninvalid_input\n&quot;</span><br><span class="line"></span><br><span class="line">is_gameover AND R6 R6 #0</span><br><span class="line">ADD R6 R6 R7</span><br><span class="line">LD R0 sum</span><br><span class="line">ADD R0 R0 #-16</span><br><span class="line">BRz over</span><br><span class="line">AND R7 R7 #0</span><br><span class="line">ADD R7 R7 R6</span><br><span class="line">ret</span><br><span class="line">overLD R3 score2</span><br><span class="line">LD R0 score1</span><br><span class="line">NOT R3 R3</span><br><span class="line">ADD R3 R3 #1</span><br><span class="line">ADD R0 R0 R3</span><br><span class="line">BRp _1dayu2</span><br><span class="line">LEA R0 p1_win</span><br><span class="line">BRnzp _2dayu1</span><br><span class="line">_1dayu2LEA R0 p1_win</span><br><span class="line">_2dayu1PUTS</span><br><span class="line">HALT</span><br><span class="line">p1_win .STRINGZ &quot;\nGame over. Player 1 is the winner!\n&quot;</span><br><span class="line">p2_win .STRINGZ &quot;\nGame over. Player 2 is the winner!\n&quot;</span><br><span class="line"></span><br><span class="line">display_prompt AND R6 R6 #0</span><br><span class="line">ADD R6 R6 R7</span><br><span class="line">AND R5 R5 R5</span><br><span class="line">BRz player1</span><br><span class="line">BRp player2 </span><br><span class="line">ret</span><br><span class="line">player1 LEA R0 p1</span><br><span class="line">PUTS</span><br><span class="line">ADD R5 R5 #1</span><br><span class="line">BRnzp Getchar</span><br><span class="line">player2 LEA R0 p2</span><br><span class="line">PUTS</span><br><span class="line">ADD R5 R5 #-1</span><br><span class="line">Getchar GETC;R1 R2 分别存储数字和字母</span><br><span class="line">LD R1 char</span><br><span class="line">ADD R1 R1 R0</span><br><span class="line">BRz quit</span><br><span class="line">AND R1 R1 #0</span><br><span class="line">ADD R1 R1 R0</span><br><span class="line">GETC</span><br><span class="line">AND R2 R2 #0</span><br><span class="line">ADD R2 R2 R0</span><br><span class="line"> AND R7 R7 #0</span><br><span class="line">ADD R7 R7 R6</span><br><span class="line">ret</span><br><span class="line">quitHALT</span><br><span class="line"></span><br><span class="line">char .FILL #-81</span><br><span class="line">p1 .STRINGZ &quot;Player 1, input a move  (or &#x27;Q&#x27; to quit):\n&quot;</span><br><span class="line">p2 .STRINGZ &quot;Player 2, input a move  (or &#x27;Q&#x27; to quit):\n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apply_move AND R6 R6 #0</span><br><span class="line">ADD R6 R6 R1</span><br><span class="line">ADD R6 R6 R6</span><br><span class="line">ADD R6 R6 R6</span><br><span class="line">ADD R6 R6 R6</span><br><span class="line">ADD R6 R6 R1</span><br><span class="line">ADD R6 R6 R2</span><br><span class="line"></span><br><span class="line">AND R0 R1 #1</span><br><span class="line">BRp jishu</span><br><span class="line">LD R0 henggang</span><br><span class="line">BRnzp oushu</span><br><span class="line">jishuLD R0 shugang</span><br><span class="line">oushuADD R6 R6 R4</span><br><span class="line">ST R6 address</span><br><span class="line">STI R0 address</span><br><span class="line">ret</span><br><span class="line">shugang .FILL #124</span><br><span class="line">henggang .FILL #45</span><br><span class="line">_shugang .FILL #-124</span><br><span class="line">_henggang .FILL #-45</span><br><span class="line">sum .FILL #0</span><br><span class="line">score1 .FILL #0</span><br><span class="line">score2 .FILL #0</span><br><span class="line"></span><br><span class="line">fill_box AND R3 R3 #0</span><br><span class="line">ST R7 ret_address</span><br><span class="line">ST R1 R_1 ;保存R1R2</span><br><span class="line">ST R2 R_2</span><br><span class="line">AND R0 R0 #0</span><br><span class="line">ADD R0 R0 R1</span><br><span class="line">ADD R0 R0 R0</span><br><span class="line">ADD R0 R0 R0   ;同理R4[9 * R1 + R2]</span><br><span class="line">ADD R0 R0 R0</span><br><span class="line">ADD R0 R0 R1</span><br><span class="line">ADD R0 R0 R2 ;R1R2到此步骤已经没有作用了，偏移已经存在R0</span><br><span class="line">ADD R0 R0 R4</span><br><span class="line"></span><br><span class="line">ST R0 address</span><br><span class="line">LDI R6 address  ;R6存变量上述的R4[]</span><br><span class="line">LD R1 _shugang</span><br><span class="line">ADD R1 R1 R6 </span><br><span class="line">BRz situation1</span><br><span class="line">BRnzp situation2</span><br><span class="line"></span><br><span class="line">situation1 LD R2 R_2</span><br><span class="line">ADD R1 R2 #0</span><br><span class="line">BRnp situation1_1</span><br><span class="line">ADD R1 R2 #-6</span><br><span class="line">BRnp situation1_2</span><br><span class="line">situation1_1  LD R2 _henggang  ;R2存横杠，R6存竖杆</span><br><span class="line">LD R6 _shugang</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #-2</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R6 R1</span><br><span class="line">BRnp end1</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #-10</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R2 R1</span><br><span class="line">BRnp end1</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #8</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R2 R1</span><br><span class="line">BRnp end1</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #-1</span><br><span class="line">ST R1 address</span><br><span class="line">JSR apply_get_score</span><br><span class="line">ADD R3 R3 #1</span><br><span class="line">end1LD R1 R_1</span><br><span class="line">ADD R1 R1 #-6</span><br><span class="line">BRz situation1_2</span><br><span class="line">BRnzp DONE2</span><br><span class="line">situation1_2  LD R2 _henggang  ;R2存横杠，R6存竖杆</span><br><span class="line">LD R6 _shugang</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #2</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R6 R1</span><br><span class="line">BRnp end2</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #-8</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R2 R1</span><br><span class="line">BRnp end2</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #10</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R2 R1</span><br><span class="line">BRnp end2</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #1</span><br><span class="line">ST R1 address</span><br><span class="line">JSR apply_get_score</span><br><span class="line">ADD R3 R3 #1</span><br><span class="line"></span><br><span class="line">end2BRnzp DONE2</span><br><span class="line">situation2 LD R1 R_1</span><br><span class="line">ADD R2 R1 #0</span><br><span class="line">BRnzp situation2_1</span><br><span class="line">ADD R2 R1 #-6</span><br><span class="line">BRnzp situation2_2</span><br><span class="line">situation2_1  LD R2 _henggang  ;R2存横杠，R6存竖杆</span><br><span class="line">LD R6 _shugang</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #-9</span><br><span class="line">ADD R1 R1 #-9</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R2 R1</span><br><span class="line">BRnp end3</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #-10</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R6 R1</span><br><span class="line">BRnp end3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ADD R1 R0 #-8</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R6 R1</span><br><span class="line">BRnp end3</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #-9</span><br><span class="line">ST R1 address</span><br><span class="line">JSR apply_get_score</span><br><span class="line">ADD R3 R3 #1</span><br><span class="line"></span><br><span class="line">end3LD R2 R_2</span><br><span class="line">ADD R2 R2 #-6</span><br><span class="line">BRz situation2_1</span><br><span class="line">BRnzp DONE2</span><br><span class="line">situation2_2  LD R2 _henggang  ;R2存横杠，R6存竖杆</span><br><span class="line">LD R6 _shugang</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #9</span><br><span class="line">ADD R1 R1 #9</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R2 R1</span><br><span class="line">BRnp DONE2</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #8</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R6 R1</span><br><span class="line">BRnp DONE2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ADD R1 R0 #10</span><br><span class="line">ST R1 address</span><br><span class="line">LDI R1 address</span><br><span class="line">ADD R1 R6 R1</span><br><span class="line">BRnp DONE2</span><br><span class="line"></span><br><span class="line">ADD R1 R0 #9</span><br><span class="line">ST R1 address</span><br><span class="line">JSR apply_get_score</span><br><span class="line">ADD R3 R3 #1</span><br><span class="line"></span><br><span class="line">DONE2 LD R7 ret_address</span><br><span class="line">LD R0 sum</span><br><span class="line">ADD R0 R3 R0</span><br><span class="line">ST R0 sum</span><br><span class="line">AND R5 R5 R5</span><br><span class="line">BRz player1_get_score</span><br><span class="line">BRnzp player2_get_score</span><br><span class="line">player1_get_score LD R0 score1</span><br><span class="line">ADD R0 R3 R0</span><br><span class="line">ST R0 score1</span><br><span class="line">ret</span><br><span class="line">player2_get_score LD R0 score2</span><br><span class="line">ADD R0 R3 R0</span><br><span class="line">ST R0 score2</span><br><span class="line">ret</span><br><span class="line">;关键函数fillbox，R0 R3 R6可用，R3暂时用来存分数，R0用来存偏移后的地址</span><br><span class="line">;R1 R2存行列，R4是map首地址，R5控制权，R7返回地址</span><br><span class="line">map .STRINGZ &quot; ABCDEFG\n0*#*#*#*\n1#######\n2*#*#*#*\n3#######\n4*#*#*#*\n5#######\n6*#*#*#*\n&quot;</span><br><span class="line">address .FILL #0</span><br><span class="line">ret_address .FILL #0</span><br><span class="line">R_1 .FILL #0</span><br><span class="line">R_2 .FILL #0</span><br><span class="line"></span><br><span class="line">is_input_valid AND R6 R6 #0</span><br><span class="line">ADD R6 R6 R7</span><br><span class="line"></span><br><span class="line">LD R0 num1</span><br><span class="line">ADD R1 R1 R0</span><br><span class="line">LD R0 char1</span><br><span class="line">ADD R2 R2 R0</span><br><span class="line"></span><br><span class="line">AND R0 R2 #1</span><br><span class="line">AND R4 R1 #1</span><br><span class="line"></span><br><span class="line">NOT R3 R0    ;异或操作</span><br><span class="line">AND R3 R3 R4</span><br><span class="line">NOT R4 R4</span><br><span class="line">AND R0 R0 R4 ;R4释放掉</span><br><span class="line">AND R4 R4 #0</span><br><span class="line">NOT R0 R0</span><br><span class="line">NOT R3 R3</span><br><span class="line">AND R0 R0 R3</span><br><span class="line">AND R3 R3 #0 ;R3赋值为0，有意义</span><br><span class="line">NOT R0 R0</span><br><span class="line">BRz invalid</span><br><span class="line">AND R7 R7 #0</span><br><span class="line">ADD R7 R7 R6</span><br><span class="line">ret</span><br><span class="line">invalidADD R3 R3 #-1</span><br><span class="line">AND R7 R7 #0</span><br><span class="line">ADD R7 R7 R6</span><br><span class="line">ret</span><br><span class="line">num1 .FILL #-48</span><br><span class="line">char1 .FILL #-65</span><br><span class="line"></span><br><span class="line">is_occupied AND R6 R6 #0  ;9 * 8 的地图</span><br><span class="line">ADD R6 R6 R7</span><br><span class="line">LEA R4 map</span><br><span class="line">ADD R4 R4 #10</span><br><span class="line"></span><br><span class="line">AND R7 R7 #0</span><br><span class="line">ADD R7 R1 R7</span><br><span class="line">ADD R7 R7 R7</span><br><span class="line">ADD R7 R7 R7</span><br><span class="line">ADD R7 R7 R7</span><br><span class="line">ADD R7 R7 R1  ;实现R1乘以10</span><br><span class="line">ADD R7 R7 R2</span><br><span class="line"></span><br><span class="line">ADD R7 R7 R4</span><br><span class="line">ST R7 address</span><br><span class="line">LDI R0 address</span><br><span class="line">LD R7 space</span><br><span class="line">ADD R0 R7 R0</span><br><span class="line"></span><br><span class="line">BRz not_occupy</span><br><span class="line">AND R3 R3 #0</span><br><span class="line">ADD R3 R3 #-1</span><br><span class="line">BRnzp DONE1</span><br><span class="line">not_occupy AND R3 R3 #0</span><br><span class="line"></span><br><span class="line">DONE1AND R7 R7 #0</span><br><span class="line">ADD R7 R7 R6</span><br><span class="line">ret</span><br><span class="line">space .FILL #-35</span><br><span class="line"></span><br><span class="line">print_map AND R6 R6 #0</span><br><span class="line">ADD R6 R6 R7</span><br><span class="line">LEA R0 map</span><br><span class="line">PUTS</span><br><span class="line"> AND R7 R7 #0</span><br><span class="line">ADD R7 R7 R6</span><br><span class="line">ret</span><br><span class="line">apply_get_score AND R5 R5 R5</span><br><span class="line">BRz apply_player1</span><br><span class="line">LD R1 pl2</span><br><span class="line">STI R1 address</span><br><span class="line">ret</span><br><span class="line">apply_player1 LD R1 pl1 </span><br><span class="line">STI R1 address</span><br><span class="line">ret</span><br><span class="line">pl1 .FILL x31</span><br><span class="line">pl2 .FILL x32</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2024/06/01/%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/06/01/%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>01背包问题是最经典的背包问题，给定几个物品的价值和体积，给定背包容量，求解背包价值最值。</p><p>基础思想是构造一个动态规划数组，下标 i 表示可容纳的体积，值代表剩余 i 体积时，最大可存储的物品价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;, v[<span class="number">100</span>], w[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)&#123;</span><br><span class="line">            f[j] = std::<span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; f[m];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下核心代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)&#123;</span><br><span class="line">        f[j] = std::<span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从最大剩余容量m（j=m）开始，向前查找，看放入一个w[ i ]后，f的总价值是否变大。第一个物品，第二个物品依次放入。。。</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>在01背包问题的基础，加上条件：任何物品个数无限</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">std::cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v; j &lt;= m; j++)&#123;</span><br><span class="line">        f[j] = std::<span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>和01背包的代码块不一样的地方在于，这里的内层循环是从小到大的，这样做的目的是，使得一个物品可以被放入多次。</p><p>举个例子，现在有物品2 5，在j = 2时，f[j] = f[0] + 5 = 5，当j = 4时，f[j] = f[2] + 5 = 10也是存在的，自然而然满足了完全背包问题的附加条件。</p><p>回来看01背包问题时的内层循环，同样是物品2 5，假如m（背包容量）为4，j = 4时，f[j] = f[2] + 5 = 5，当j = 2时，f[j] = f[0] + 2 = 5，可见f[4] = f[2] 都为5，一个物品无法在一轮循环中被放入多次。</p><p>正常来说，完全背包问题中，放入物品体积不超过容量；假设题目条件是放入物品体积要恰好为容量，只需把除了f[0] 以外的 f[j] 都初始化为负无穷。</p><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>本质上还是01背包问题，加上条件：给定物品的个数。</p><p>只需要在01背包的基础上，再加上一层循环，来检查一次放入k个物品时，f[j] 是否会变大。</p><p>和完全背包不同的是，多重背包问题的个数有限制，因此不能通过内层循环从小到大来实现：完全背包实现的是一次放一个物品，但是可以放多次；而多重背包在code时的思想时，一个物品放一次，但是可以一次性放多个（由一层循环限制）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    std::cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">        <span class="comment">//这里j &gt;= 0不影响，下面还有一层判读</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s &amp;&amp; k * v &lt;= j; k++)&#123;</span><br><span class="line">            <span class="comment">//k代表放入物品个数</span></span><br><span class="line">     f[j] = std::<span class="built_in">max</span>(f[j], f[j - k * v] + k * w);          </span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01展开优化"><a href="#01展开优化" class="headerlink" title="01展开优化"></a>01展开优化</h3><p>可以将多重背包问题看成01背包问题来解决，把物品的个数展开，每个都是01背包的一种输入。</p><p>展开亦有技巧，用二进制方式展开能最大程度的节省资源，假如s为8，展开为1 4 2 1，受到二进制01思想的启发，在这种展开方式中，通过特定的组合，能完全表示数字1到8。</p><p>设置一个objects结构以及对应容器vector，用来存放体积与价值。</p><p>展开方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k *= <span class="number">2</span>)&#123;</span><br><span class="line">s -= k;</span><br><span class="line">    objects.<span class="built_in">emplace_back</span>(v * k, w * k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">objects.<span class="built_in">emplace</span>(v * s, w * s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><p>多重背包问题是分组背包问题的一种特殊情况。</p><p>分组背包问题就是，将某些物品分到一组，一组中最多选一个物品。</p><p>为什么说多重背包问题是分组的特殊情况呢？</p><p>假设将分组看多重背包的各种情况，例如4个a物品，看成分组背包中的a，2a，3a，4a四种价值的物品，仅能取其中之一。于是乎，我们就可以用多重背包的一般思想来解决分组背包问题。</p><p>假设分组背包中有4个物品，abcd，类似于多重背包中的，a2a3a4a，一样的解决思路，每组物品中的物品间没有倍数关系了而已。所以我们可以用多重背包的一般思想解决分组背包问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; s; j++)&#123;</span><br><span class="line">     <span class="comment">//分组读取数据</span></span><br><span class="line">        std::cin &gt;&gt; v[j] &gt;&gt; v[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)&#123;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; s &amp;&amp; v[k] &lt; j; k++)&#123;      </span><br><span class="line">            <span class="comment">//对比多重背包k*w用w[k]代替，k*v用v[k]代替</span></span><br><span class="line">     f[j] = std::<span class="built_in">max</span>(f[j], f[j - v[k]] + w[k]);          </span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深大计系2实验三</title>
      <link href="/2024/05/28/%E6%B7%B1%E5%A4%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/05/28/%E6%B7%B1%E5%A4%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p><strong>一、</strong> <strong>实验目标：</strong></p><ol><li>理解程序函数调用中参数传递机制；</li><li>掌握缓冲区溢出攻击方法；</li><li>进一步熟练掌握GDB调试工具和objdump反汇编工具。</li></ol><p><strong>二、实验环境：</strong></p><ol><li>计算机（Intel CPU）</li><li>Linux 64位操作系统</li><li>GDB调试工具</li><li>objdump反汇编工具</li></ol><p><strong>三、实验内容</strong></p><p>本实验设计为一个黑客利用缓冲区溢出技术进行攻击的游戏。我们仅给黑客（同学）提供一个二进制可执行文件bufbomb和部分函数的C代码，不提供每个关卡的源代码。程序运行中有3个关卡，每个关卡需要用户输入正确的缓冲区内容，否则无法通过管卡！</p><p>要求同学查看各关卡的要求，运用<strong><em>\</em>GDB调试工具和objdump反汇编工具**</strong>，通过分析汇编代码和相应的栈帧结构，通过缓冲区溢出办法在执行了getbuf()函数返回时作攻击，使之返回到各关卡要求的指定函数中。第一关只需要返回到指定函数，第二关不仅返回到指定函数还需要为该指定函数准备好参数，最后一关要求在返回到指定函数之前执行一段汇编代码完成全局变量的修改。</p><p>实验代码bufbomb和相关工具（sendstring/makecookie）的更详细内容请参考“实验四 缓冲区溢出攻击实验.pptx”。</p><p>本实验要求解决关卡1、2、3，给出实验思路，通过截图把实验过程和结果写在实验报告上。</p><p><strong>四、实验步骤和结果</strong></p><p><strong>因为本次实验用到的可执行文件是</strong>32位，而实验环境是64位的，需要先安装一个32位的库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bufbomb &gt;&gt; 1.txt</span><br></pre></td></tr></table></figure><p>首先利用反汇编命令查看getbuf函数的汇编代码，以便分析getbuf在调用<Gets>时的栈帧结构</p><p><strong>步骤1</strong> <strong>返回到**</strong>smoke()**</p><p><strong>解题思路</strong></p><p>本实验中，bufbomb中的test()函数将会调用getbuf()函数，getbuf()函数再调用gets()从标准输入设备读入字符串。</p><p>系统函数gets()未进行缓冲区溢出保护。其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的目标是使getbuf()返回时，不返回到test()，而是直接返回到指定的smoke()函数。</p><p>为此，我们可以通过构造并输入大于getbuf()中给出的数据缓冲区的字符串而破坏getbuf()的栈帧，替换其返回地址，将返回地址改成smoke()函数的地址。</p><p><strong>解题过程</strong></p><p>分析getbuf()函数的汇编代码，可以发现，getbuf()在保存%ebp的旧值后，将%ebp指向%esp所指的位置，然后将栈指针减去0x28来分配额外的20个字节的地址空间。字符数组buf的位置用%ebp下0x18(即24)个字节来计算。然后调用Gets（）函数，读取的字符串返回到%ebp-0x18，即%ebp-24。</p><p><strong>具体的栈帧结构如下：</strong></p><div class="table-container"><table><thead><tr><th><strong>栈帧</strong></th><th></th></tr></thead><tbody><tr><td>返回地址</td><td>属于调用者的栈帧</td></tr><tr><td>保存的%ebp旧值</td><td>%ebp</td></tr><tr><td>20-23</td><td></td></tr><tr><td>16-19</td><td></td></tr><tr><td>12-15</td><td></td></tr><tr><td>[11]  [10] [9] [8]</td><td></td></tr><tr><td>[7]  [6]  [5]  [4]</td><td></td></tr><tr><td>[3]  [2]  [1]  [0]</td><td>buf,%ebp-0x18</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td>%esp，%ebp-0x24</td></tr></tbody></table></div><p>从以上分析可得，只要输入不超过11个字符，gets返回的字符串（包括末尾的null）就能够放进buf分配的空间里。长一些的字符串就会导致gets覆盖栈上存储的某些信息。</p><p>随着字符串变长，下面的信息会被破坏：</p><div class="table-container"><table><thead><tr><th><strong>输入的字符数量</strong></th><th><strong>附加的被破坏的状态</strong></th></tr></thead><tbody><tr><td><strong>0-11</strong></td><td><strong>无</strong></td></tr><tr><td><strong>12-23</strong></td><td><strong>分配后未使用的空间</strong></td></tr><tr><td><strong>24-27</strong></td><td><strong>保存的%ebp旧值</strong></td></tr><tr><td><strong>28-31</strong></td><td><strong>返回地址</strong></td></tr><tr><td><strong>32+</strong></td><td><strong>调用者test()中保存的状态</strong></td></tr></tbody></table></div><p>因此，我们要替换返回地址，需要构造一个长度至少为32的字符串，其中的第0~11个字符放进buf分配的空间里，第12~23个字符放进程序分配后未使用的空间里，第24~27个字符覆盖保存的%ebp旧值，第28-31个字符覆盖返回地址。</p><p>由于替换掉返回地址后，getbuf()函数将不会再返回到test()中，所以覆盖掉test()的%ebp旧值并不会有什么影响。也就是说我们构造的长度为32的字符串前28个字符随便是啥都行，而后面四个字符就必须能表示smoke()函数的地址。所以我们要构造的字符串就是“28个任意字符+smoke()地址”。任意的28个字符都用十六进制数00填充就行。</p><p><strong>最终结果截图</strong></p><p>通过在0.txt中传入以下数据</p><p>00112233445566778899001122334455667788990011223344556677b08e0408</p><p>成功通过栈溢出改变了返回地址，调用了smoke( )函数</p><p><img src="/image-20240528134901835.png" alt="image-20240528134901835"></p><p><strong>步骤2</strong> <strong>返回到fizz()并准备相应参数</strong></p><p><strong>2.1</strong> <strong>解题思路</strong></p><p>这一关要求返回到fizz()并传入自己的cookie值作为参数，破解的思路和第一关是类似的，构造一个超过缓冲区长度的字符串将返回地址替换成fizz()的地址，只是增加了一个传入参数，所以在读入字符串时，要把fizz()函数读取参数的地址替换成自己的cookie值，具体细节见解题过程。</p><p><strong>2.2</strong> <strong>解题过程</strong></p><p>首先还是利用objdunp查看并分析fizz()函数的汇编代码</p><p>从汇编代码可知，fizz()函数被调用时首先保存%ebp旧值并分配新的空间，然后读取%ebp-0x8地址处的内容作为传入的参数，要求传入的参数是自己的cookie值。也就是说传入的参数其实是存在%ebp-0x8处的，具体的栈帧结构如下：</p><div class="table-container"><table><thead><tr><th><strong>栈帧</strong></th><th></th></tr></thead><tbody><tr><td>传入的参数</td><td>%ebp+0x8</td></tr><tr><td></td><td>%ebp+0x4</td></tr><tr><td>保存的%ebp旧值</td><td>%ebp</td></tr><tr><td></td><td></td></tr><tr><td></td><td>%esp</td></tr></tbody></table></div><p>对应到getbuf()函数中的栈帧结构如下：</p><div class="table-container"><table><thead><tr><th><strong>栈帧</strong></th><th></th></tr></thead><tbody><tr><td></td><td>需要替换成cookie传入fizz()</td></tr><tr><td></td><td>任意替换</td></tr><tr><td>返回地址</td><td>属于调用者的栈帧</td></tr><tr><td>保存的%ebp旧值</td><td>%ebp，需要替换成fizz()的地址</td></tr><tr><td></td><td>任意替换</td></tr><tr><td></td><td>任意替换</td></tr><tr><td></td><td>任意替换</td></tr><tr><td>[11]  [10]  [9]  [8]</td><td></td></tr><tr><td>[7]  [6]  [5]  [4]</td><td></td></tr><tr><td>[3 ] [2] [1] [0]</td><td>buf,%ebp-0x18</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td>%esp，%ebp-0x24</td></tr></tbody></table></div><p>由以上结构不难判断出，我们需要读入buf的字符串为“28个任意字符+fizz()的地址+4个任意的字符+自己的cookie值”，每个字符还是用十六进制数表示。</p><p><strong>2.3</strong> <strong>最终结果截图</strong></p><p>输入</p><p>00112233445566778899001122334455667788990011223344556677608e0408001122330032ae6d</p><p><img src="/Images/wps1-1716875420723-1.jpg" alt="img"> </p><p><strong>步骤3</strong> <strong>返回到bang()且修改global_value</strong></p><p><strong>解题思路</strong></p><p>这一关要求先修改全局变量global_value的值为自己的cookie值，再返回到band()。为此需要先编写一段代码，在代码中把global_value的值改为自己的cookie后返回到band()函数。将这段代码通过GCC产生目标文件后读入到buf数组中，并使getbuf函数的返回到buf数组的地址，这样程序就会执行我们写的代码，修改global_value的值并调用band()函数。具体细节见解题过程。</p><p><strong>解题过程</strong></p><p>首先，为了能精确地指定跳转地址，先在root权限下关闭Linux的内存地址随机化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">sysctl -w kernel.randomize_va_space=0</span><br><span class="line">su beihai</span><br></pre></td></tr></table></figure><p>用objdump查看bang()函数的汇编代码如下：</p><p><img src="/Images/wps2.jpg" alt="img"> </p><p>很明显，bang()函数首先读取0x804a1c4和0x804a1d4的地址的内容并进行比较，要求两个地址中的内容相同：</p><p><img src="/Images/wps3.jpg" alt="img"> </p><p>​    用gdb调试命令查看：</p><p><img src="/Images/wps4.jpg" alt="img"> </p><p>可以发现，0x804a1c4就是全局变量global_value的地址，0x804a1d4是cookie的地址。因此，我们只要在自己写的代码中，把地址0x804a1d4的内容存到地址0x804a1c4就行了。</p><p>再利用objdump得到bang()函数的入口地址为0x08048e10:</p><p><img src="/Images/wps5.jpg" alt="img"> </p><p>到这里，就可以确定我们自己写的代码要干的事情了。首先是将global_value的值设置为cookie的值，也就是将0x804a1c4的值设置为0x804a1d4的值，然后将bang()函数的入口地址0x08048e10压入栈中，这样当函数返回的时候，就会直接取栈顶作为返回地址，从而调用bang()函数。接着函数返回，此时返回的地址就是上一条语句中压入栈中的地址，也就是bang()函数的入口地址了。</p><p>根据上述思路，可以写出以下代码来调用bang( )函数</p><p><img src="/Images/wps6.jpg" alt="img"> </p><p>以上代码是在编译再反编译呈现出来的，复制代码的十六进制表示，填入0.txt的输入文件中，由于getbuf( )函数里从ebp-0x18位置开始读取字符串，经过计算后，这里的20字节的代码，再加上8字节的占用字符串，然后就可以填入4字节的返回地址，返回地址则填入buf数组的首地址，用来调用buf数组里的，上述自己写的可执行代码，代码执行完后自然会返回到bang( )</p><p>0.txt中填入：</p><p>8b1425d4a10408891425c4a1040868108e0408c31122334455667788c0b1ffff</p><p>最后四个字节是栈帧地址，每个用户都是不同的。</p><p> <strong>最终结果截图</strong></p><p><img src="/Images/wps7.jpg" alt="img"></p><p><strong>五、实验总结与体会</strong></p><p><strong>通过这次实验我收获了以下几点：</strong></p><p>1、<strong>进一步掌握objdump反汇编和gdb调试，学会还原栈帧和分析运行时栈的组成。</strong></p><p>2、<strong>学会了如何通过栈溢出来实现非法的函数调用，学会了如何防止此类栈溢出造成的安全隐患问题。</strong></p><p>3、<strong>学会分析全局变量和在栈溢出中用十六进制传入自己写的代码。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA里反编译后出现的宏</title>
      <link href="/2024/05/27/IDA%E9%87%8C%E7%9A%84%E5%AE%8F/"/>
      <url>/2024/05/27/IDA%E9%87%8C%E7%9A%84%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-不同编译器下数据类型宏"><a href="#0x01-不同编译器下数据类型宏" class="headerlink" title="0x01 不同编译器下数据类型宏"></a>0x01 不同编译器下数据类型宏</h2><h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defined(__GNUC__)</span><br><span class="line">  <span class="keyword">typedef</span>          <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> __int64 long long</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> __int32 int</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> __int16 short</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> __int8  char</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> MAKELL(num) num ## LL</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> FMT_64 <span class="string">&quot;ll&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="MSC-VER"><a href="#MSC-VER" class="headerlink" title="_MSC_VER"></a>_MSC_VER</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defined(_MSC_VER)</span><br><span class="line">  <span class="keyword">typedef</span>          __int64 ll;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">unsigned</span> __int64 ull;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> MAKELL(num) num ## i64</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> FMT_64 <span class="string">&quot;I64&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="BORLANDC"><a href="#BORLANDC" class="headerlink" title=" BORLANDC "></a><strong> BORLANDC </strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defined (__BORLANDC__)</span><br><span class="line">  <span class="keyword">typedef</span>          __int64 ll;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">unsigned</span> __int64 ull;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> MAKELL(num) num ## i64</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> FMT_64 <span class="string">&quot;L&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="无法识别编译器"><a href="#无法识别编译器" class="headerlink" title="无法识别编译器"></a>无法识别编译器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;unknown compiler&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> ushort;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">char</span>   int8;</span><br><span class="line"><span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">char</span>   sint8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>   uint8;</span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">short</span>  int16;</span><br><span class="line"><span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">short</span>  sint16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  uint16;</span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">int</span>    int32;</span><br><span class="line"><span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">int</span>    sint32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    uint32;</span><br><span class="line"><span class="keyword">typedef</span> ll              int64;</span><br><span class="line"><span class="keyword">typedef</span> ll              sint64;</span><br><span class="line"><span class="keyword">typedef</span> ull             uint64;</span><br></pre></td></tr></table></figure><h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Partially defined types:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BYTE  uint8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WORD  uint16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DWORD uint32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _QWORD uint64</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_MSC_VER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LONGLONG __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WINDOWS_</span></span><br><span class="line"><span class="keyword">typedef</span> int8 BYTE;</span><br><span class="line"><span class="keyword">typedef</span> int16 WORD;</span><br><span class="line"><span class="keyword">typedef</span> int32 DWORD;</span><br><span class="line"><span class="keyword">typedef</span> int32 LONG;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">typedef</span> int64 QWORD;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;       <span class="comment">// we want to use bool in our C programs</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="0x02-表示字节的宏"><a href="#0x02-表示字节的宏" class="headerlink" title="0x02 表示字节的宏"></a>0x02 表示字节的宏</h2><p>经常有各种byte，这里给出了准确的宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Some convenience macros to make partial accesses nicer</span></span><br><span class="line"><span class="comment">// first unsigned macros:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOBYTE(x)   (*((_BYTE*)&amp;(x)))   <span class="comment">// low byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWORD(x)   (*((_WORD*)&amp;(x)))   <span class="comment">// low word</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LODWORD(x)  (*((_DWORD*)&amp;(x)))  <span class="comment">// low dword</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIBYTE(x)   (*((_BYTE*)&amp;(x)+1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIWORD(x)   (*((_WORD*)&amp;(x)+1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDWORD(x)  (*((_DWORD*)&amp;(x)+1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTEn(x, n)   (*((_BYTE*)&amp;(x)+n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORDn(x, n)   (*((_WORD*)&amp;(x)+n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE1(x)   BYTEn(x,  1)         <span class="comment">// byte 1 (counting from 0)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE2(x)   BYTEn(x,  2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE3(x)   BYTEn(x,  3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE4(x)   BYTEn(x,  4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE5(x)   BYTEn(x,  5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE6(x)   BYTEn(x,  6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE7(x)   BYTEn(x,  7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE8(x)   BYTEn(x,  8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE9(x)   BYTEn(x,  9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE10(x)  BYTEn(x, 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE11(x)  BYTEn(x, 11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE12(x)  BYTEn(x, 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE13(x)  BYTEn(x, 13)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE14(x)  BYTEn(x, 14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE15(x)  BYTEn(x, 15)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORD1(x)   WORDn(x,  1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORD2(x)   WORDn(x,  2)         <span class="comment">// third word of the object, unsigned</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORD3(x)   WORDn(x,  3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORD4(x)   WORDn(x,  4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORD5(x)   WORDn(x,  5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORD6(x)   WORDn(x,  6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORD7(x)   WORDn(x,  7)</span></span><br></pre></td></tr></table></figure><p>和上面一样的功能，有时候会有以下的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// now signed macros (the same but with sign extension)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLOBYTE(x)   (*((int8*)&amp;(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLOWORD(x)   (*((int16*)&amp;(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLODWORD(x)  (*((int32*)&amp;(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHIBYTE(x)   (*((int8*)&amp;(x)+1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHIWORD(x)   (*((int16*)&amp;(x)+1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHIDWORD(x)  (*((int32*)&amp;(x)+1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTEn(x, n)   (*((int8*)&amp;(x)+n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWORDn(x, n)   (*((int16*)&amp;(x)+n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE1(x)   SBYTEn(x,  1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE2(x)   SBYTEn(x,  2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE3(x)   SBYTEn(x,  3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE4(x)   SBYTEn(x,  4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE5(x)   SBYTEn(x,  5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE6(x)   SBYTEn(x,  6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE7(x)   SBYTEn(x,  7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE8(x)   SBYTEn(x,  8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE9(x)   SBYTEn(x,  9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE10(x)  SBYTEn(x, 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE11(x)  SBYTEn(x, 11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE12(x)  SBYTEn(x, 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE13(x)  SBYTEn(x, 13)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE14(x)  SBYTEn(x, 14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE15(x)  SBYTEn(x, 15)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWORD1(x)   SWORDn(x,  1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWORD2(x)   SWORDn(x,  2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWORD3(x)   SWORDn(x,  3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWORD4(x)   SWORDn(x,  4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWORD5(x)   SWORDn(x,  5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWORD6(x)   SWORDn(x,  6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWORD7(x)   SWORDn(x,  7)</span></span><br></pre></td></tr></table></figure><h2 id="0x03-其他宏（位移与数据操作等宏）"><a href="#0x03-其他宏（位移与数据操作等宏）" class="headerlink" title="0x03 其他宏（位移与数据操作等宏）"></a>0x03 其他宏（位移与数据操作等宏）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper functions to represent some assembly instructions.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill memory block with an integer value</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">memset32</span><span class="params">(<span class="type">void</span> *ptr, uint32 value, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint32 *p = (uint32 *)ptr;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i &lt; count; i++ )</span><br><span class="line">    *p++ = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate a reference to pair of operands 将数据组合high and low</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  int16 __PAIR__( int8  high, T low) &#123; <span class="keyword">return</span> ((( int16)high) &lt;&lt; <span class="keyword">sizeof</span>(high)*<span class="number">8</span>) | uint8(low); &#125;</span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  int32 __PAIR__( int16 high, T low) &#123; <span class="keyword">return</span> ((( int32)high) &lt;&lt; <span class="keyword">sizeof</span>(high)*<span class="number">8</span>) | uint16(low); &#125;</span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  int64 __PAIR__( int32 high, T low) &#123; <span class="keyword">return</span> ((( int64)high) &lt;&lt; <span class="keyword">sizeof</span>(high)*<span class="number">8</span>) | uint32(low); &#125;</span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> uint16 __PAIR__(uint8  high, T low) &#123; <span class="keyword">return</span> (((uint16)high) &lt;&lt; <span class="keyword">sizeof</span>(high)*<span class="number">8</span>) | uint8(low); &#125;</span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> uint32 __PAIR__(uint16 high, T low) &#123; <span class="keyword">return</span> (((uint32)high) &lt;&lt; <span class="keyword">sizeof</span>(high)*<span class="number">8</span>) | uint16(low); &#125;</span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> uint64 __PAIR__(uint32 high, T low) &#123; <span class="keyword">return</span> (((uint64)high) &lt;&lt; <span class="keyword">sizeof</span>(high)*<span class="number">8</span>) | uint32(low); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate left 循环左移</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T __ROL__(T value, uint count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> uint nbits = <span class="keyword">sizeof</span>(T) * <span class="number">8</span>;</span><br><span class="line">  count %= nbits;</span><br><span class="line"></span><br><span class="line">  T high = value &gt;&gt; (nbits - count);</span><br><span class="line">  value &lt;&lt;= count;</span><br><span class="line">  value |= high;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate right 循环右移</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T __ROR__(T value, uint count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> uint nbits = <span class="keyword">sizeof</span>(T) * <span class="number">8</span>;</span><br><span class="line">  count %= nbits;</span><br><span class="line"></span><br><span class="line">  T low = value &lt;&lt; (nbits - count);</span><br><span class="line">  value &gt;&gt;= count;</span><br><span class="line">  value |= low;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// carry flag of left shift</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> int8 __MKCSHL__(T value, uint count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> uint nbits = <span class="keyword">sizeof</span>(T) * <span class="number">8</span>;</span><br><span class="line">  count %= nbits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (value &gt;&gt; (nbits-count)) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// carry flag of right shift</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> int8 __MKCSHR__(T value, uint count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (value &gt;&gt; (count<span class="number">-1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sign flag 符号位检查</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> int8 __SETS__(T x) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">sizeof</span>(T) == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> int8(x) &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">sizeof</span>(T) == <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> int16(x) &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">sizeof</span>(T) == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> int32(x) &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> int64(x) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overflow flag of subtraction (x-y) 溢出检查</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span> int8 __OFSUB__(T x, U y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">sizeof</span>(T) &lt; <span class="keyword">sizeof</span>(U) )</span><br><span class="line">  &#123;</span><br><span class="line">    U x2 = x;</span><br><span class="line">    int8 sx = __SETS__(x2);</span><br><span class="line">    <span class="keyword">return</span> (sx ^ __SETS__(y)) &amp; (sx ^ __SETS__(x2-y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    T y2 = y;</span><br><span class="line">    int8 sx = __SETS__(x);</span><br><span class="line">    <span class="keyword">return</span> (sx ^ __SETS__(y2)) &amp; (sx ^ __SETS__(x-y2));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overflow flag of addition (x+y) 溢出检查</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span> int8 __OFADD__(T x, U y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">sizeof</span>(T) &lt; <span class="keyword">sizeof</span>(U) )</span><br><span class="line">  &#123;</span><br><span class="line">    U x2 = x;</span><br><span class="line">    int8 sx = __SETS__(x2);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">1</span> ^ sx) ^ __SETS__(y)) &amp; (sx ^ __SETS__(x2+y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    T y2 = y;</span><br><span class="line">    int8 sx = __SETS__(x);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">1</span> ^ sx) ^ __SETS__(y2)) &amp; (sx ^ __SETS__(x+y2));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// carry flag of subtraction (x-y) 进位检查</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span> int8 __CFSUB__(T x, U y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> size = <span class="keyword">sizeof</span>(T) &gt; <span class="keyword">sizeof</span>(U) ? <span class="keyword">sizeof</span>(T) : <span class="keyword">sizeof</span>(U);</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> uint8(x) &lt; uint8(y);</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> uint16(x) &lt; uint16(y);</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> uint32(x) &lt; uint32(y);</span><br><span class="line">  <span class="keyword">return</span> uint64(x) &lt; uint64(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// carry flag of addition (x+y) 进位检查</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span> int8 __CFADD__(T x, U y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> size = <span class="keyword">sizeof</span>(T) &gt; <span class="keyword">sizeof</span>(U) ? <span class="keyword">sizeof</span>(T) : <span class="keyword">sizeof</span>(U);</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> uint8(x) &gt; uint8(x+y);</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> uint16(x) &gt; uint16(x+y);</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> uint32(x) &gt; uint32(x+y);</span><br><span class="line">  <span class="keyword">return</span> uint64(x) &gt; uint64(x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// The following definition is not quite correct because it always returns</span></span><br><span class="line"><span class="comment">// uint64. The above C++ functions are good, though.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PAIR__(high, low) (((uint64)(high)&lt;&lt;sizeof(high)*8) | low)</span></span><br><span class="line"><span class="comment">// For C, we just provide macros, they are not quite correct.可能会不正确</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ROL__(x, y) __rotl__(x, y)      <span class="comment">// Rotate left</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ROR__(x, y) __rotr__(x, y)      <span class="comment">// Rotate right</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CFSHL__(x, y) invalid_operation <span class="comment">// Generate carry flag for (x&lt;&lt;y)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CFSHR__(x, y) invalid_operation <span class="comment">// Generate carry flag for (x&gt;&gt;y)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CFADD__(x, y) invalid_operation <span class="comment">// Generate carry flag for (x+y)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CFSUB__(x, y) invalid_operation <span class="comment">// Generate carry flag for (x-y)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OFADD__(x, y) invalid_operation <span class="comment">// Generate overflow flag for (x+y)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OFSUB__(x, y) invalid_operation <span class="comment">// Generate overflow flag for (x-y)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No definition for rcl/rcr because the carry flag is unknown</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RCL__(x, y)    invalid_operation <span class="comment">// Rotate left thru carry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RCR__(x, y)    invalid_operation <span class="comment">// Rotate right thru carry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MKCRCL__(x, y) invalid_operation <span class="comment">// Generate carry flag for a RCL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MKCRCR__(x, y) invalid_operation <span class="comment">// Generate carry flag for a RCR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SETP__(x, y)   invalid_operation <span class="comment">// Generate parity flag for (x-y)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时候无法识别类型，用宏_UNKNOWN代替</span></span><br><span class="line"><span class="comment">// In the decompilation listing there are some objects declarared as _UNKNOWN</span></span><br><span class="line"><span class="comment">// because we could not determine their types. Since the C compiler does not</span></span><br><span class="line"><span class="comment">// accept void item declarations, we replace them by anything of our choice,</span></span><br><span class="line"><span class="comment">// for example a char:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UNKNOWN char</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> snprintf _snprintf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vsnprintf _vsnprintf</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超级简单排序刷题</title>
      <link href="/2024/05/24/%E6%8E%92%E5%BA%8F%E5%88%B7%E9%A2%98/"/>
      <url>/2024/05/24/%E6%8E%92%E5%BA%8F%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="P1271-【深基9-例1】选举学生会"><a href="#P1271-【深基9-例1】选举学生会" class="headerlink" title="P1271 【深基9.例1】选举学生会"></a>P1271 【深基9.例1】选举学生会</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n, temp;</span><br><span class="line"><span class="type">int</span> vote[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; temp;</span><br><span class="line">        vote[temp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(vote[i]--)&#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1177-【模板】排序"><a href="#P1177-【模板】排序" class="headerlink" title="P1177 【模板】排序"></a>P1177 【模板】排序</h2><p>排序题，写一个快排练练手（填进去后超时了）</p><p>查了一下资料发现经典快排是会超时的（以第一个作为标签元素）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right, key = a[i];</span><br><span class="line">    <span class="comment">//according to key, distinguish size</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= key)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= key)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    <span class="comment">//done one</span></span><br><span class="line">    <span class="keyword">if</span>((i - <span class="number">1</span>) &gt; left)&#123;</span><br><span class="line">        <span class="built_in">qsort</span>(a, left, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &gt; (i + <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">qsort</span>(a, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200000</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qsort</span>(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小改了一下还是有问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">200000</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(a[left], a[(left + right) / <span class="number">2</span>]);</span><br><span class="line">    <span class="type">int</span> i = left, j = right, key = a[i];</span><br><span class="line">    <span class="comment">//according to key, distinguish size</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= key)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= key)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    <span class="comment">//done one</span></span><br><span class="line">    <span class="keyword">if</span>((i - <span class="number">1</span>) &gt; left)&#123;</span><br><span class="line">        <span class="built_in">qsort</span>(left, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &gt; (i + <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">qsort</span>(i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qsort</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1923-【深基9-例4】求第-k-小的数"><a href="#P1923-【深基9-例4】求第-k-小的数" class="headerlink" title="P1923 【深基9.例4】求第 k 小的数"></a>P1923 【深基9.例4】求第 k 小的数</h2><p>这里用std输入流太慢了，会卡时间，故用scanf</p><p>本题的思路是分治，用快排原理，先随便找一个数作为中间值，然后将数依次在中间值左右排开，此时中间值的下标就是确切下标；</p><p>find函数比较中间值和k，k较小则在中间值左边部分寻找，同理右边或者相等时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//according to key, distinguish size</span></span><br><span class="line">    <span class="type">int</span> key = a[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; a[right] &gt;= key)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = a[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= key)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;      </span><br><span class="line">        a[right] = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = key;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="built_in">qsort</span>(left, right);</span><br><span class="line">    <span class="keyword">if</span>(k == temp)&#123;</span><br><span class="line">        std::cout &lt;&lt; a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; temp)&#123;</span><br><span class="line">        <span class="built_in">find</span>(left, temp - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(temp + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">find</span>(<span class="number">0</span>, n<span class="number">-1</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1059-NOIP2006-普及组-明明的随机数"><a href="#P1059-NOIP2006-普及组-明明的随机数" class="headerlink" title="P1059 [NOIP2006 普及组] 明明的随机数"></a>P1059 [NOIP2006 普及组] 明明的随机数</h2><p>用STL的一个库模板会很好写，set就是一个有序的集合，不允许出现重复元素而且会自行从小到大排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, temp;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; m;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; temp;</span><br><span class="line">        s.<span class="built_in">insert</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; *s.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用桶排序，这个排序的时间复杂度是n，适用于序列个数较小的排序。</p><p>桶排序的思路就是设定一个有大小的范围数组，例如此题的随机数不超过1000，于是就设置一个大小不小于1000的数组都初始化为0，然后将下标和输入数相同的元素值+1（重复时忽略），最后根据下标从小到大遍历数组，为1就输出下标，达到从小到大排序的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> m, temp, cnt = <span class="number">0</span>, random[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; m;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(!random[temp])&#123;</span><br><span class="line">            random[temp]++;</span><br><span class="line">            cnt++;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(random[i])&#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1093-NOIP2007-普及组-奖学金"><a href="#P1093-NOIP2007-普及组-奖学金" class="headerlink" title="P1093 [NOIP2007 普及组] 奖学金"></a>P1093 [NOIP2007 普及组] 奖学金</h2><p>设置一个结构体，在里面存储各种成绩信息。</p><p>然后写一个cmp函数来传入sort，重构比较方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">score</span>&#123;</span><br><span class="line">    <span class="type">int</span> chinese, math, english, num, sum;</span><br><span class="line">&#125;stus[<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从大到小*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(score a, score b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.sum &gt; b.sum)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.sum &lt; b.sum)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.chinese &gt; b.chinese)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.chinese &lt; b.chinese)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.num &lt; b.num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= number; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; stus[i].chinese &gt;&gt; stus[i].math &gt;&gt; stus[i].english;</span><br><span class="line">        stus[i].sum = stus[i].chinese + stus[i].math + stus[i].english;</span><br><span class="line">        stus[i].num = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(stus + <span class="number">1</span>, stus + number + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">5</span> ; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; stus[i].num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stus[i].sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1781-宇宙总统"><a href="#P1781-宇宙总统" class="headerlink" title="P1781 宇宙总统"></a>P1781 宇宙总统</h2><p>和上题的思路差不多，也是重构比较函数，这里由于票数数字太大用字符串存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::string votes;</span><br><span class="line">&#125;president[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(person a, person b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.votes.<span class="built_in">length</span>() &gt; b.votes.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.votes.<span class="built_in">length</span>() &lt; b.votes.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.votes.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.votes[i] &gt; b.votes[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.votes[i] &lt; b.votes[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; president[i].votes;</span><br><span class="line">        president[i].number = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(president + <span class="number">1</span>, president + n + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; president[<span class="number">1</span>].number &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; president[<span class="number">1</span>].votes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="USACO07DEC-Bookshelf-B"><a href="#USACO07DEC-Bookshelf-B" class="headerlink" title="[USACO07DEC] Bookshelf B"></a>[USACO07DEC] Bookshelf B</h2><p>很简单的题但是很长阅读理解，一开始以为是什么背包问题，呃呃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cows_high[<span class="number">20010</span>];</span><br><span class="line"><span class="type">int</span> N, B, sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; N &gt;&gt; B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; cows_high[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(cows_high + <span class="number">1</span>, cows_high + N + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum &lt; B)&#123;</span><br><span class="line">        sum += cows_high[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="车厢重组"><a href="#车厢重组" class="headerlink" title="车厢重组"></a>车厢重组</h2><p>一道冒泡排序题，输出交换的次数就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> carriages[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; carriages[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(carriages[j] &gt; carriages[j + <span class="number">1</span>])&#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(carriages[j], carriages[j + <span class="number">1</span>]);</span><br><span class="line">                cnt++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; carriages[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// putchar(&#x27;\n&#x27;);</span></span><br><span class="line">    std::cout &lt;&lt; cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欢乐的跳"><a href="#欢乐的跳" class="headerlink" title="欢乐的跳"></a>欢乐的跳</h2><p>计算前后差然后排序，若是从1到n-1的公差为1的等差数列，则为jolly</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, temp_a = <span class="number">0</span>, temp_b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sub[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        temp_b = temp_a;</span><br><span class="line">        std::cin &gt;&gt; temp_a;</span><br><span class="line">        sub[i] = <span class="built_in">fabs</span>(temp_a - temp_b);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(sub + <span class="number">1</span>, sub + n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sub[i] != i)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Not jolly&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Jolly&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1068-NOIP2009-普及组-分数线划定"><a href="#P1068-NOIP2009-普及组-分数线划定" class="headerlink" title="P1068 [NOIP2009 普及组] 分数线划定"></a>P1068 [NOIP2009 普及组] 分数线划定</h2><p>这题有个小坑，是先根据排名推断出分数，再根据分数划分人，我先入为主直接根据排名划分人了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">per</span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;pers[<span class="number">5010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(per a, per b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score &gt; b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.score &lt; b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number &lt; b.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    m = m * <span class="number">1.5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; pers[i].number &gt;&gt; pers[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(pers + <span class="number">1</span>, pers + <span class="number">1</span> + n, cmp);</span><br><span class="line">    <span class="comment">//找出分数线</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, line_score = pers[m].score;</span><br><span class="line">    <span class="comment">//测算出大于分数线的人数</span></span><br><span class="line">    <span class="keyword">while</span>(pers[m+<span class="number">1</span>].score == line_score)&#123;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; line_score &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(pers[i].score &gt;= line_score)&#123;</span><br><span class="line">        std::cout &lt;&lt; pers[i].number &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pers[i].score;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P5143-攀爬者"><a href="#P5143-攀爬者" class="headerlink" title="P5143 攀爬者"></a>P5143 攀爬者</h2><p>很无聊的计算题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> temp, sum = <span class="number">0</span>, x, y, z;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;points[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a, point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; points[i].x &gt;&gt; points[i].y &gt;&gt; points[i].z;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(points + <span class="number">1</span>, points + <span class="number">1</span> + n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        x = <span class="built_in">pow</span>((points[i].x - points[i+<span class="number">1</span>].x), <span class="number">2</span>);</span><br><span class="line">        y = <span class="built_in">pow</span>((points[i].y - points[i+<span class="number">1</span>].y), <span class="number">2</span>);</span><br><span class="line">        z = <span class="built_in">pow</span>((points[i].z - points[i+<span class="number">1</span>].z), <span class="number">2</span>);</span><br><span class="line">        temp = <span class="built_in">sqrt</span>(x + y + z);</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1012-NOIP1998-提高组-拼数"><a href="#P1012-NOIP1998-提高组-拼数" class="headerlink" title="P1012 [NOIP1998 提高组] 拼数"></a>P1012 [NOIP1998 提高组] 拼数</h2><p>一开始以为是从大到小排个序然后组合，后来发现是按照高位优先排序的。</p><p>正常来说把数字看成字符串然后遍历比较排序就好了。</p><p>有个特殊情况就是，两个数的前几项都相同，比如321 和 32，组合成32321时大</p><p>但是329 和 32 则是组成 32932比较大，究其原因就是长的那个数最后一项是否大于短的那个数的第一项，若是则长的数较大，反之，由于长短数的第一项相同，直接比较长数的第一项和最后一项就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::string a[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(std::string a, std::string b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len_a = a.<span class="built_in">length</span>(), len_b = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len = std::<span class="built_in">min</span>(len_a, len_b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; b[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len_a &gt; len_b)&#123;</span><br><span class="line">        <span class="comment">//这里代表a大于b时，a的最后一项要大</span></span><br><span class="line">        <span class="keyword">return</span> a[len_a - <span class="number">1</span>] &gt; a[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len_a &lt; len_b)&#123;</span><br><span class="line">        <span class="comment">//这里代表a大于b时，b最后一项要小，b大于a是false，与上面相反</span></span><br><span class="line">        <span class="keyword">return</span> b[len_a - <span class="number">1</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【buuctf】DontEatMe</title>
      <link href="/2024/05/01/DontEatMe/"/>
      <url>/2024/05/01/DontEatMe/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01反调试"><a href="#0x01反调试" class="headerlink" title="0x01反调试"></a>0x01反调试</h2><p>拿到<code>Ntdll</code>的模块句柄，从句柄中查找<code>ZwSetInformationThread</code>的地址，然后调用这个函数去检查当前线程是否处于<code>Debug</code>模式下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ModuleHandleA = GetModuleHandleA(<span class="string">&quot;Ntdll&quot;</span>);</span><br><span class="line"> ZwSetInformationThread = GetProcAddress(ModuleHandleA, <span class="string">&quot;ZwSetInformationThread&quot;</span>);</span><br><span class="line"> CurrentThread = GetCurrentThread();</span><br><span class="line"> ((<span class="type">void</span> (__stdcall *)(HANDLE, _DWORD, _DWORD, _DWORD))ZwSetInformationThread)(CurrentThread, <span class="number">17</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>关于<code>ZwSetInformationThread</code>的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(NTAPI* pZwSetInformationThread)</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE ThreadHandle,                            <span class="comment">// 线程对象句柄</span></span></span><br><span class="line"><span class="params">    IN THREAD_INFO_CLASS ThreadInformaitonClass,    <span class="comment">// 线程信息类型</span></span></span><br><span class="line"><span class="params">    IN PVOID ThreadInformation,                        <span class="comment">// 线程信息指针</span></span></span><br><span class="line"><span class="params">    IN ULONG ThreadInformationLength                <span class="comment">// 线程信息大小</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>重点查看这个线程信息类型，是一个枚举类型，根据传入参数调用特定函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">THREADINFOCLASS</span> &#123;</span></span><br><span class="line">    ThreadBasicInformation,</span><br><span class="line">    ThreadTimes,</span><br><span class="line">    ThreadPriority,</span><br><span class="line">    ThreadBasePriority,</span><br><span class="line">    ThreadAffinityMask,</span><br><span class="line">    ThreadImpersonationToken,</span><br><span class="line">    ThreadDescriptorTableEntry,</span><br><span class="line">    ThreadEnableAlignmentFaultFixup,</span><br><span class="line">    ThreadEventPair,</span><br><span class="line">    ThreadQuerySetWin32StartAddress,</span><br><span class="line">    ThreadZeroTlsCell,</span><br><span class="line">    ThreadPerformanceCount,</span><br><span class="line">    ThreadAmILastThread,</span><br><span class="line">    ThreadIdealProcessor,</span><br><span class="line">    ThreadPriorityBoost,</span><br><span class="line">    ThreadSetTlsArrayAddress,</span><br><span class="line">    ThreadIsIoPending,</span><br><span class="line">    ThreadHideFromDebugger</span><br><span class="line">&#125;THREAD_INFO_CLASS;</span><br></pre></td></tr></table></figure><p>这里传入17，刚好调用<code>ThreadHideFromDebugger</code>，检测到调试就会将该线程强制分离出调试器，造成反调试。修改方法直接将push 的17 patch成0就好了。</p><p><img src="/Images/3661847bc96f92448810106b4337ebb.png" alt="3661847bc96f92448810106b4337ebb"></p><p>修改后便能正常调试。</p><h2 id="0x02-走迷宫"><a href="#0x02-走迷宫" class="headerlink" title="0x02 走迷宫"></a>0x02 走迷宫</h2><p>一开始往下翻就发现是一个迷宫，中间有一大段加密，看不懂先不管。反正关键肯定是走迷宫，迷宫地图是在运行中生成的，这时候处理完反调试就能跑出地图了。</p><p>跑到进行走迷宫逻辑前：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v36 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        --v39;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        ++v39;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        ++v37;</span><br><span class="line">        v40 += <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        --v37;</span><br><span class="line">        v40 -= <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( dword_10053A8[v40 + v39] == <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v36 = v25[++v38];</span><br><span class="line">    <span class="keyword">if</span> ( !v36 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v37 == <span class="number">4</span> &amp;&amp; v39 == <span class="number">9</span> &amp;&amp; v38 &lt; <span class="number">17</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Congratulations! Here is your flag: RCTF&#123;%s&#125;&quot;</span>, (<span class="type">char</span>)ArgList);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Oh no.  Dont eat me!!!!&quot;</span>, v47);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>查看这个dword_10053A8数组，是一个int256大小的数组，点进去把数组内容shiftE出来，弄到python处理一下，有1024个01数字，但是int类型4个一组打印出来。</p><p>打印出来后发现只有01数，没有明显终点起点，于是再查看一下代码，发现v37记录着上下，v39记录左右移动。当v37 == 4 ，v39 == 9 ，且移动次数小于17次时，到达终点，于是终点坐标是(9 , 4)</p><p><img src="/Images/d2c3ca38cdeb9b329aaf100dec290c4.png" alt="d2c3ca38cdeb9b329aaf100dec290c4"></p><p><img src="/Images/25e10c4ea79eddebac9c60867166c87.png" alt="25e10c4ea79eddebac9c60867166c87"></p><p>再看成v39和v37的初始值，知道起点坐标为(5 , A)，假设终点为$，起点为#</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> = [    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]</span><br><span class="line"><span class="built_in">map</span>[<span class="number">4</span> * (<span class="number">16</span> * <span class="number">0xA</span> + <span class="number">0x5</span>)] = <span class="string">&#x27;#&#x27;</span></span><br><span class="line"><span class="built_in">map</span>[<span class="number">4</span> * (<span class="number">16</span> * <span class="number">4</span> + <span class="number">9</span>)] = <span class="string">&#x27;$&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">map</span>[<span class="number">4</span> * (<span class="number">16</span> * i + j)],end = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1111111111111111</span></span><br><span class="line"><span class="string">1000000000111111</span></span><br><span class="line"><span class="string">1011111110111111</span></span><br><span class="line"><span class="string">1011111110111111</span></span><br><span class="line"><span class="string">101111000$000111</span></span><br><span class="line"><span class="string">1011110111110111</span></span><br><span class="line"><span class="string">1011110111110111</span></span><br><span class="line"><span class="string">1011110000110111</span></span><br><span class="line"><span class="string">1011111110110111</span></span><br><span class="line"><span class="string">1011111110110111</span></span><br><span class="line"><span class="string">10000#0000110111</span></span><br><span class="line"><span class="string">1111101111110111</span></span><br><span class="line"><span class="string">1111100000000111</span></span><br><span class="line"><span class="string">1111111111111111</span></span><br><span class="line"><span class="string">1111111111111111</span></span><br><span class="line"><span class="string">1111111111111111</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>读图法，得到迷宫路径为<code>ddddwwwaaawwwddd</code></p><p>到这里可以合理猜测，输入的flag经过某种算法加密后，得到迷宫路径的正确答案，接下来就分析一下中间的算法是什么东西。</p><h2 id="0x03-BLOWFISH"><a href="#0x03-BLOWFISH" class="headerlink" title="0x03 BLOWFISH"></a>0x03 BLOWFISH</h2><p>解出迷宫后再回来看看中间那里，猜测是什么算法（迫真猜测），用FindCrypt插件看看（<a href="https://hex-rays.com/blog/findcrypt2/">下载地址</a>）</p><p><img src="/Images/image-20240501114439626.png" alt="image-20240501114439626"></p><p>去查查BLOWFISH是什么东西（摘抄）。</p><h3 id="BLOWFISH加密解析"><a href="#BLOWFISH加密解析" class="headerlink" title="BLOWFISH加密解析"></a>BLOWFISH加密解析</h3><p>blowfish加密算法是一种对称的分组加密算法，对Plaintext进行分组，每组长度为64bit，而该加密的密钥为变长密钥，32bit-448bit都可以当作密钥进行加解密处理</p><p>密钥可以定义为Key数组，该数组的长度为<code>[1, 14]</code></p><p>存在两个数组pBox和sBox，pBox为18个32位子密钥组成，sBox为4*256个32位子密钥组成，一般情况下，是用Π的小数点的16进制</p><h3 id="BLOWFISH加密过程"><a href="#BLOWFISH加密过程" class="headerlink" title="BLOWFISH加密过程"></a>BLOWFISH加密过程</h3><ol><li>传入明文和密钥K，密钥K的长度为<code>32bit-448bit</code>，密钥K数组的单位为32bit，所以得到<code>K = [K1, K2, ... , Kn]</code>，其中<code>1≤n≤14</code></li><li>初始化子密钥，子密钥分为1个pBox和4个sBox，pBox的长度为18，sBox的长度为256，一般情况下，该子密钥的初始化为Π的16进制</li><li>子密钥预处理pBox：这里密钥数组K的长度最大只有14，所以存在轮换使用密钥的情况，假设密钥数组K的长度为14，首先是pBox与密钥数组K进行异或：<ul><li><code>pBox[0] ^ K[0]</code></li><li><code>pBox[1] ^ K[1]</code></li><li>…</li><li><code>pBox[13] ^ K[13]</code></li><li><code>pBox[14] ^ K[0]</code></li></ul></li><li>pBox变换：产生一个64bit全0的数据，然后调用BlowFish的主加密函数进行加密，得到一个64bit的数据替换pBox的数据，总共进行9轮，得到一个新的pBox</li><li>sBox变换：此时沿用pBox中产生的leftpart和rightpart，再次通过BlowFish进行主加密函数进行加密，每次将处理后的leftpart和rightpart进行替换，替换得到新的sBox</li><li>Plaintext加密：首先是对明文进行填充，若不足8个字节则填充至8个字节，填充为8的整数倍，然后分为前4字节与后4字节传入主加密函数进行加密，在主加密函数中进行加密得到最终的密文</li></ol><p>主加密函数，总共为8轮加密，每轮都会从pBox中拿取64bit的数据分成2*32bit异或给leftpart和rightpart，然后再分别异或从sBox中查表得到的值</p><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">srand(<span class="number">0xDEADBEEF</span>);</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i )</span><br><span class="line">  key[i] = rand();</span><br><span class="line">key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">v57[<span class="number">0</span>] = <span class="number">0x4853494668736966</span>i64;</span><br><span class="line">word_10057A9 = <span class="number">6671</span>;</span><br><span class="line">word_10057AB = <span class="number">13569</span>;</span><br><span class="line">byte_10057AD = <span class="number">58</span>;</span><br><span class="line">byte_10057AE = <span class="number">59</span>;</span><br><span class="line">byte_10057AF = <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>这段代码用一个srand指定时间戳，然后用rand生成伪随机数来产生密钥，但是在调试后发现实际上的密钥并非如此，查了地址才发现，6671,13569等值紧随其后对生成的key进行了覆盖，把实际的密钥转化为16进制dump出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 0F 1A 01 35 3A 3B 20</span><br></pre></td></tr></table></figure><p>用<a href="https://cyberchef.org/#recipe=Blowfish_Encrypt(%7B&#39;option&#39;:&#39;Hex&#39;,&#39;string&#39;:&#39;00%200F%201A%2001%2035%203A%203B%2020&#39;%7D,%7B&#39;option&#39;:&#39;Hex&#39;,&#39;string&#39;:&#39;&#39;%7D,&#39;ECB&#39;,&#39;Raw&#39;,&#39;Hex&#39;">cyberchef网站的BLOWFISH</a>From_Base64(‘HNO4klm6ij9n%2BJ2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo%3DILaUpPBC5’,false,false/disabled)&amp;input=ZGRkZHd3d2FhYXd3d2RkZA)加密</p><p><img src="/Images/image-20240501130401853.png" alt="image-20240501130401853"></p><p>包裹flag提交，发现错误，后来查资料才知道会填充多余的8位空格。删去最后8个字节得到答案</p><p>flag{db824ef8605c5235b4bbacfa2ff8e087}</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LC-3 汇编语言实验1求成绩等级</title>
      <link href="/2024/04/25/LC-3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C1%E6%B1%82%E6%88%90%E7%BB%A9%E7%AD%89%E7%BA%A7/"/>
      <url>/2024/04/25/LC-3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C1%E6%B1%82%E6%88%90%E7%BB%A9%E7%AD%89%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="LC-3-汇编语言实验1求成绩等级"><a href="#LC-3-汇编语言实验1求成绩等级" class="headerlink" title="LC-3 汇编语言实验1求成绩等级"></a><strong>LC-3 汇编语言实验1求成绩等级</strong></h2><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>(一) 实验描述</p><p>对学生的成绩使用数组进行排序</p><p>背景：一位老师需要你帮忙决定学生的成绩，她想要根据学生分数在班上的排名和考试分数一起决定学生最后的成绩等级。</p><p>具体要求：</p><p>a. 如果学生的分数排名在全班的25%之前，且考试分数达到85分及以上，则学生可以获得A</p><p>b. 如果学生不能拿A，但是分数排名在全班的50%之前，且考试分数达到75及以上，则学生可以获得B</p><p>c. 剩下的学生都是C</p><p>具体的情况：一共有16名学生，每名学生只有一个成绩</p><p>(二) 实验要求</p><p>（1）用汇编语言给这个班写一个成绩排序的程序</p><p>（2）你的程序必须给学生的分数排序，然后计算出获得A和B的学生人数。程序从x3000开始</p><p>（3）程序的输入</p><p>a. 班上16个学生的没有排序的成绩；</p><p>b. 每个分数是用16位无符号数表示的0~100的整数；</p><p>c. 分数存储在16个连续的内存位置-每一个位置一个分数；从x3200开始；</p><p>d. 最后一个分数的存储位置为x320F；</p><p>e. 你可以假设所有的分数相互之间不相同（每个分数是唯一的）；</p><p>（4）程序的输出(你的程序必须有两个输出)</p><p>a. 16位学生的分数排序。分数必须按降序排序在连续的内存位置-每个内存地址一个分数，从x4000开始存储；即x4000存储的分数是最高的</p><p>b. 获得A和B的学生的人数。获得A的学生人数必须存储在x4100，获得B的人数必须存储在x4101</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>（1） 程序实现思路：</p><p>① 首先读取x3200到x320F的16个成绩，然后使用冒泡排序对成绩进行排序，并将排序后的成绩存储到x4000~x400F中；</p><p>② 通过计算获得A和B的学生人数并分别存储到x4100和x4101中。</p><p>（2）编写汇编语言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000   ;程序起始位于x3000</span><br><span class="line"></span><br><span class="line">;初始化寄存的值</span><br><span class="line">LD R0 SCORE     ;R0为地址x3200指向第一个成绩</span><br><span class="line">LD R1 VALUE_16  ;R1 = 16，用于copy和sort</span><br><span class="line">LD R2 S_START   ;R2指向copy后存放成绩的地址x4000</span><br><span class="line"></span><br><span class="line">;将位于x3200的成绩拷贝到x4000</span><br><span class="line">copy    BRz sort       ;计数器为0时进入排序操作</span><br><span class="line">LDR R4 R0 #0   ;将x3200的数据拷贝到x4000</span><br><span class="line">STR R4 R2 #0</span><br><span class="line">ADD R0 R0 #1   ;源指针和目标指针都+1</span><br><span class="line">ADD R2 R2 #1   </span><br><span class="line">ADD R1 R1 #-1  ;计数器R1-1</span><br><span class="line">BRnzp copy     ;无条件跳转到copy开始</span><br><span class="line"></span><br><span class="line">;冒泡排序</span><br><span class="line">sort    LD R1 VALUE_16  ;还原R1</span><br><span class="line"></span><br><span class="line">LOOP1LD R2 S_START   ;还原R2</span><br><span class="line">ADD R1 R1 #-1</span><br><span class="line">BRz count_A     ;外循环结束时进入count_A</span><br><span class="line">AND R3 R3 #0    ;初始化R3为0</span><br><span class="line">ADD R3 R3 R1;R3设置为内循环计数器</span><br><span class="line"></span><br><span class="line">LOOP2LDR R0 R2 #0</span><br><span class="line">LDR R4 R2 #1</span><br><span class="line">NOT R4 R4</span><br><span class="line">ADD R4 R4 #1;R4取相反数</span><br><span class="line">ADD R0 R4 R0;R0 = R0 - R4</span><br><span class="line">BRn swap ;前一个小于后一个时swap</span><br><span class="line">s_outADD R2 R2 #1 ;R2指针后移1</span><br><span class="line">ADD R3 R3 #-1;内循环计数器-1</span><br><span class="line">BRp LOOP2     ;为正数就继续循环</span><br><span class="line"></span><br><span class="line">BRz LOOP1;为0则跳出内循环</span><br><span class="line"></span><br><span class="line">swapLDR R4 R2 #1;前后两个数交换位置</span><br><span class="line">LDR R0 R2 #0</span><br><span class="line">STR R0 R2 #1</span><br><span class="line">STR R4 R2 #0</span><br><span class="line">BRnzp s_out;函数返回</span><br><span class="line"></span><br><span class="line">;统计A人数</span><br><span class="line">count_ALD R0 S_START;将R0指向S_START的x4000</span><br><span class="line">AND R1 R1 #0;R1作为A上限</span><br><span class="line">ADD R1 R1 #4;将4赋给R1</span><br><span class="line">AND R2 R2 #0;R2作为B上限</span><br><span class="line">ADD R2 R2 #8;将8赋给R2</span><br><span class="line">AND R3 R3 #0;寄存器初始化为0</span><br><span class="line">AND R4 R4 #0;R4记录A人数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOOP3LDR R3 R0 #0;将成绩传给R3</span><br><span class="line">LD R7 Ne85;将-85赋给R7</span><br><span class="line">ADD R3 R3 R7;比较R3与85</span><br><span class="line">BRn store_A;得分小于85，记录A人数</span><br><span class="line">ADD R2 R2 #-1;得分大于等于85，B上限-1</span><br><span class="line">ADD R4 R4 #1;A人数+1</span><br><span class="line">ADD R1 R1 #-1;A上限-1</span><br><span class="line">BRz store_A;A上限为0，记录A人数</span><br><span class="line">ADD R0 R0 #1;指针后移</span><br><span class="line">BRp LOOP3;</span><br><span class="line"></span><br><span class="line">store_ASTI R4,SaveA;将R4中的内容（等级为A的学生人数）存储在地址x4100中</span><br><span class="line"></span><br><span class="line">;统计B人数</span><br><span class="line">count_B AND R4 R4 #0;R4记录B人数</span><br><span class="line">AND R3 R3 #0;寄存器初始化为0</span><br><span class="line"></span><br><span class="line">LOOP4LDR R3 R0 #0;将成绩传给R3</span><br><span class="line">LD R7 Ne75;将-75赋给R7</span><br><span class="line">ADD R3 R3 R7;比较R3与85</span><br><span class="line">BRn store_B;得分小于75，记录B人数</span><br><span class="line">ADD R2 R2 #-1;得分大于等于75，B上限-1</span><br><span class="line">ADD R4 R4 #1;B人数+1</span><br><span class="line">ADD R2 R2 #-1   ;B上限-1</span><br><span class="line">BRz store_B;B上限为0，记录B人数</span><br><span class="line">ADD R0,R0,#1;指针后移</span><br><span class="line">BRp LOOP4;</span><br><span class="line"></span><br><span class="line">store_BSTI R4,SaveB;将R6存在地址x4101</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;程序结束</span><br><span class="line">HALT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ne85.FILL #-85</span><br><span class="line">Ne75.FILL #-75</span><br><span class="line">VALUE_16  .FILL #16</span><br><span class="line">SCORE     .FILL x3200</span><br><span class="line">S_START   .FILL x4000</span><br><span class="line">SaveA.FILL x4100</span><br><span class="line">SaveB.FILL x4101</span><br><span class="line">.END</span><br></pre></td></tr></table></figure><p>（3）编译程序，开启模拟器，加载并运行该程序</p><p>（4）使用手工给内存赋值的方式，给x3200~x320F输入实验数据</p><p>（5） 运行程序，检查内存x4000~x400F，可以看到学生成绩已经降序排列</p><p>（6）检查内存x4100、x4101，结果正确，实验完毕。</p><p>（上述过程自己补充实验截图）</p><h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><p>这次实验让我对汇编语言有了更深入的理解。</p><p>虽然在实验过程中遇到了一些困难，如条件判断错误和忘记给计数器操作等，但最终都在debug和测试中得到了解决。</p><p>我发现，在编写较长的汇编代码时，理解各个指令的含义会变得困难，因此注释的作用就显得尤为重要。</p><p>此外，我还学会了如何将高级语言中的排序算法应用到汇编语言中，这大大降低了实现相应操作的难度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深大计系2实验三</title>
      <link href="/2024/04/24/%E6%B7%B1%E5%A4%A7%E8%AE%A1%E7%B3%BB2%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
      <url>/2024/04/24/%E6%B7%B1%E5%A4%A7%E8%AE%A1%E7%B3%BB2%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-phase-1"><a href="#0x01-phase-1" class="headerlink" title="0x01 phase_1"></a>0x01 phase_1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400e70 &lt;phase_1&gt;:</span><br><span class="line">  400e70:48 83 ec 08          sub    $0x8,%rsp                   ;开辟8个字节的栈</span><br><span class="line">  400e74:be f8 1a 40 00       mov    $0x401af8,%esi      ;给寄存器%esi存入立即数0x401af8（传入参数，应该是运行时字符串的地址）</span><br><span class="line">  400e79:e8 bf 03 00 00       call   40123d &lt;strings_not_equal&gt;  ;调用地址在0x40123d的函数&lt;strings_not_equal&gt;</span><br><span class="line">  400e7e:85 c0                test   %eax,%eax                   ;检查返回值%eax里是否为0</span><br><span class="line">  400e80:74 05                je     400e87 &lt;phase_1+0x17&gt;       ;若为0则跳转到0x400e87</span><br><span class="line">  400e82:e8 b6 07 00 00       call   40163d &lt;explode_bomb&gt;       ;不为0则继续调用函数&lt;explode_bomb&gt;</span><br><span class="line">  400e87:48 83 c4 08          add    $0x8,%rsp                   ;清空8个字节的栈</span><br><span class="line">  400e8b:c3                   ret                                ;函数返回</span><br></pre></td></tr></table></figure><p>分析完很容易发现，在调用检查字符串是否相等的函数时，寄存器%esi传入了一个立即数地址，应该是要用来比较的字符串，在gdb调试时打印这个字符串。</p><p><img src="/Images/image-20240422224132204.png" alt="image-20240422224132204"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Science isn&#x27;t about why, it&#x27;s about why not?</span><br></pre></td></tr></table></figure><p>成功打印出字符串。</p><h2 id="0x02-phase-2"><a href="#0x02-phase-2" class="headerlink" title="0x02 phase_2"></a>0x02 phase_2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0000000000400e8c &lt;phase_2&gt;:</span><br><span class="line">  400e8c:48 89 5c 24 e0       mov    %rbx,-0x20(%rsp)            ;被调用者保护寄存器%rbx的值入栈（8个字节）</span><br><span class="line">  400e91:48 89 6c 24 e8       mov    %rbp,-0x18(%rsp)            ;被调用者保护寄存器%rbp的值入栈（8个字节）</span><br><span class="line">  400e96:4c 89 64 24 f0       mov    %r12,-0x10(%rsp)            ;被调用者保护寄存器%r12的值入栈（8个字节）</span><br><span class="line">  400e9b:4c 89 6c 24 f8       mov    %r13,-0x8(%rsp)             ;被调用者保护寄存器%r13的值入栈（8个字节）</span><br><span class="line">  400ea0:48 83 ec 48          sub    $0x48,%rsp                  ;栈向下开辟72个字节</span><br><span class="line">  400ea4:48 89 e6             mov    %rsp,%rsi                   ;将栈指针的值存放入%rsi（第二个传入参数）中</span><br><span class="line">  400ea7:e8 97 08 00 00       call   401743 &lt;read_six_numbers&gt;   ;调用&lt;read_six_numbers&gt;，返回的6个数字存在%rsp上偏移24bytes内</span><br><span class="line">  400eac:48 89 e5             mov    %rsp,%rbp                   ;更新栈底%rbp</span><br><span class="line">  400eaf:4c 8d 6c 24 0c       lea    0xc(%rsp),%r13              ;%r13 = %rsp + 0xc</span><br><span class="line">  400eb4:41 bc 00 00 00 00    mov    $0x0,%r12d                  ;%r12d清零</span><br><span class="line">  400eba:48 89 eb             mov    %rbp,%rbx                   ;%rbx存栈底指针，循环在此开始</span><br><span class="line">  400ebd:8b 45 0c             mov    0xc(%rbp),%eax              ;%eax = *(%rbp + 0xc)</span><br><span class="line">  400ec0:39 45 00             cmp    %eax,0x0(%rbp)              ;比较%rbp上的值和%eax</span><br><span class="line">  400ec3:74 05                je     400eca &lt;phase_2+0x3e&gt;       ;如果相等则跳转</span><br><span class="line">  400ec5:e8 73 07 00 00       call   40163d &lt;explode_bomb&gt;       ;否则bomb</span><br><span class="line">  400eca:44 03 23             add    (%rbx),%r12d                ;%r12d += *(%rbx)</span><br><span class="line">  400ecd:48 83 c5 04          add    $0x4,%rbp                   ;栈底指针%rbp向上偏移4个字节</span><br><span class="line">  400ed1:4c 39 ed             cmp    %r13,%rbp                   ;%rbp 不等于 %rsp + 0xc 则循环，从400eba开始</span><br><span class="line">  400ed4:75 e4                jne    400eba &lt;phase_2+0x2e&gt;       </span><br><span class="line">  400ed6:45 85 e4             test   %r12d,%r12d                 ;检测%r12d是否为0，不为0则跳转到400ee0</span><br><span class="line">  400ed9:75 05                jne    400ee0 &lt;phase_2+0x54&gt;</span><br><span class="line">  400edb:e8 5d 07 00 00       call   40163d &lt;explode_bomb&gt;</span><br><span class="line">  400ee0:48 8b 5c 24 28       mov    0x28(%rsp),%rbx             ;下面是被保存的寄存器的出栈</span><br><span class="line">  400ee5:48 8b 6c 24 30       mov    0x30(%rsp),%rbp</span><br><span class="line">  400eea:4c 8b 64 24 38       mov    0x38(%rsp),%r12</span><br><span class="line">  400eef:4c 8b 6c 24 40       mov    0x40(%rsp),%r13</span><br><span class="line">  400ef4:48 83 c4 48          add    $0x48,%rsp                  ;例行的清空栈帧和返回</span><br><span class="line">  400ef8:c3                   ret   </span><br></pre></td></tr></table></figure><p>这个是函数phase_2的大体分析，其中函数<read_xis_numbers>，我为了了解读取的6个数字存放在了哪里，于是进入分析了一下，以下贴分析后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0000000000401743 &lt;read_six_numbers&gt;:</span><br><span class="line">  401743:48 83 ec 18          sub    $0x18,%rsp                     ;开辟24个字节的栈</span><br><span class="line">  401747:48 89 f2             mov    %rsi,%rdx                      ;%rdx = %rsi（第3个参数）</span><br><span class="line">  40174a:48 8d 4e 04          lea    0x4(%rsi),%rcx                 ;%rcx = %rsi + 0x4 （第4个参数）</span><br><span class="line">  40174e:48 8d 46 14          lea    0x14(%rsi),%rax                ;%rax = %rsi + 0x14 </span><br><span class="line">  401752:48 89 44 24 08       mov    %rax,0x8(%rsp)                 ;将%rax的值存放在栈指针向上偏移8个字节的位置（参数构造顶第8个）</span><br><span class="line">  401757:48 8d 46 10          lea    0x10(%rsi),%rax                ;%rax = %rsi + 0x10 </span><br><span class="line">  40175b:48 89 04 24          mov    %rax,(%rsp)                    ;将%rax的值存放在栈指针位置（参数构造顶第7个参数）</span><br><span class="line">  40175f:4c 8d 4e 0c          lea    0xc(%rsi),%r9                  ;%r9 = %rsi + 0xc  （第5个参数）</span><br><span class="line">  401763:4c 8d 46 08          lea    0x8(%rsi),%r8                  ;%r8 = %rsi + 0x8   （第6个参数）</span><br><span class="line">  401767:be b2 1e 40 00       mov    $0x401eb2,%esi                 ;将立即数0x401eb2存入%esi，经过调试后发现是6个%d，scanf函数的表达式</span><br><span class="line">  40176c:b8 00 00 00 00       mov    $0x0,%eax                      ;%eax清零</span><br><span class="line">  401771:e8 3a f3 ff ff       call   400ab0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">;__isoc99_sscanf函数的返回值是读取的数字个数这里传入的六个参数（phase_2栈上的地址，这里用%rsi的偏移量来表示，实际上是phase_2栈帧的参数构造顶），以4个寄存器2个在栈上的方式，传入scanf函数。</span><br><span class="line"></span><br><span class="line">  401776:83 f8 05             cmp    $0x5,%eax                          ;如果读取的个数大于5个（这里需要读6个）</span><br><span class="line">  401779:7f 05                jg     401780 &lt;read_six_numbers+0x3d&gt;     ;则跳出程序正常返回</span><br><span class="line">  40177b:e8 bd fe ff ff       call   40163d &lt;explode_bomb&gt;              ;否则调用&lt;explode_bomb&gt;，程序中止</span><br><span class="line">  401780:48 83 c4 18          add    $0x18,%rsp                         ;清空&lt;read_six_numbers&gt;的栈</span><br><span class="line">  401784:c3                   ret                                       ;返回</span><br></pre></td></tr></table></figure><p>很容易发现，这6个数字，分别通过%rdx,%rcx,%r8,%r9和两个栈上的参数构造区的栈帧，来读取6个数字。这6个参数是指针，分别是函数phase_2的栈指针%rsp向上偏移的24的bytes，每4个字节一次偏移。</p><p>核心代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">400eac:48 89 e5             mov    %rsp,%rbp                   ;更新栈底%rbp</span><br><span class="line">400eaf:4c 8d 6c 24 0c       lea    0xc(%rsp),%r13              ;%r13 = %rsp + 0xc</span><br><span class="line">400eb4:41 bc 00 00 00 00    mov    $0x0,%r12d                  ;%r12d清零</span><br><span class="line">400eba:48 89 eb             mov    %rbp,%rbx                   ;%rbx存栈底指针，循环在此开始</span><br><span class="line">400ebd:8b 45 0c             mov    0xc(%rbp),%eax              ;%eax = *(%rbp + 0xc)</span><br><span class="line">400ec0:39 45 00             cmp    %eax,0x0(%rbp)              ;比较%rbp上的和%eax</span><br><span class="line">400ec3:74 05                je     400eca &lt;phase_2+0x3e&gt;       ;如果相等则跳转</span><br><span class="line">400ec5:e8 73 07 00 00       call   40163d &lt;explode_bomb&gt;       ;否则bomb</span><br><span class="line">400eca:44 03 23             add    (%rbx),%r12d                ;%r12d += *(%rbx)</span><br><span class="line">400ecd:48 83 c5 04          add    $0x4,%rbp                   ;栈底指针%rbp向上偏移4个字节</span><br><span class="line">400ed1:4c 39 ed             cmp    %r13,%rbp                   ;%rbp 不等于 %rsp + 0xc 则循环，从400eba开始</span><br><span class="line">400ed4:75 e4                jne    400eba &lt;phase_2+0x2e&gt;       </span><br><span class="line">400ed6:45 85 e4             test   %r12d,%r12d                 ;检测%r12d是否为0，不为0则跳转到400ee0（正常进行）</span><br><span class="line">400ed9:75 05                jne    400ee0 &lt;phase_2+0x54&gt;</span><br><span class="line">400edb:e8 5d 07 00 00       call   40163d &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p>回过来分析phase_2，%r13存放着第4个参数的地址，%r12是每次循环的*(%rbx)的求和，%rbx每次循环都会向上偏移4字节，实际上就是从读取的第1个数字按顺序取址，然后放到%rbx中，直到偏移到0xc（偏移2次到第三个参数，第三次跳出循环），其中每次把读取的数字和地址偏移0xc后的数字比较。</p><p>简单点说就是，把第1个数字和第4个数字比，第2个和第5个比，第3个和第6个比，全部相同，且数字不全为0，就能通过测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 1 2 3</span><br></pre></td></tr></table></figure><h2 id="0x03-phase-3"><a href="#0x03-phase-3" class="headerlink" title="0x03 phase_3"></a>0x03 phase_3</h2><p>这是类似switch的一个跳转表的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ef9 &lt;phase_3&gt;:</span><br><span class="line">  400ef9:48 83 ec 18          sub    $0x18,%rsp       ;开辟24个字节的栈</span><br><span class="line">  400efd:48 8d 4c 24 08       lea    0x8(%rsp),%rcx   ;%rcx = %rsp + 0x8</span><br><span class="line">  400f02:48 8d 54 24 0c       lea    0xc(%rsp),%rdx   ;%rdx = %rsp + 0xc</span><br><span class="line">  400f07:be be 1e 40 00       mov    $0x401ebe,%esi   ;键入某个字符串，调试后发现是%d %d，应该是两个输入</span><br><span class="line">  400f0c:b8 00 00 00 00       mov    $0x0,%eax        ;清零%eax</span><br><span class="line">  400f11:e8 9a fb ff ff       call   400ab0 &lt;__isoc99_sscanf@plt&gt; ;输入两个数字，存在%rsp分别偏移0x8和0xc上</span><br><span class="line">  400f16:83 f8 01             cmp    $0x1,%eax        ;读取大于一个数字，即两个数字时跳转，正常运行</span><br><span class="line">  400f19:7f 05                jg     400f20 &lt;phase_3+0x27&gt;  </span><br><span class="line">  400f1b:e8 1d 07 00 00       call   40163d &lt;explode_bomb&gt; </span><br><span class="line">  400f20:83 7c 24 0c 07       cmpl   $0x7,0xc(%rsp)    ;检测第1个数字是否小于等于7</span><br><span class="line">  400f25:77 3c                ja     400f63 &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f27:8b 44 24 0c          mov    0xc(%rsp),%eax    ;第1个数字赋值给%eax</span><br><span class="line">  400f2b:ff 24 c5 60 1b 40 00 jmp    *0x401b60(,%rax,8) ;调试发现*0x401b60是地址0xf00f32，即下一条指令的地址</span><br><span class="line">  400f32:b8 17 02 00 00       mov    $0x217,%eax        ;根据%rax的值实现8字节一次的偏移，其实就是switch跳转</span><br><span class="line">  400f37:eb 3b                jmp    400f74 &lt;phase_3+0x7b&gt; ;下面是类似跳转表的东西</span><br><span class="line">  400f39:b8 d6 00 00 00       mov    $0xd6,%eax</span><br><span class="line">  400f3e:eb 34                jmp    400f74 &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f40:b8 53 01 00 00       mov    $0x153,%eax</span><br><span class="line">  400f45:eb 2d                jmp    400f74 &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f47:b8 77 00 00 00       mov    $0x77,%eax</span><br><span class="line">  400f4c:eb 26                jmp    400f74 &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f4e:b8 60 01 00 00       mov    $0x160,%eax</span><br><span class="line">  400f53:eb 1f                jmp    400f74 &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f55:b8 97 03 00 00       mov    $0x397,%eax</span><br><span class="line">  400f5a:eb 18                jmp    400f74 &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f5c:b8 9c 01 00 00       mov    $0x19c,%eax</span><br><span class="line">  400f61:eb 11                jmp    400f74 &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f63:e8 d5 06 00 00       call   40163d &lt;explode_bomb&gt;</span><br><span class="line">  400f68:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f6d:eb 05                jmp    400f74 &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f6f:b8 9e 03 00 00       mov    $0x39e,%eax</span><br><span class="line">  400f74:3b 44 24 08          cmp    0x8(%rsp),%eax  ;给%eax赋值后跳转到这里，与第2个数字比较</span><br><span class="line">  400f78:74 05                je     400f7f &lt;phase_3+0x86&gt; ;相等就正常退出函数</span><br><span class="line">  400f7a:e8 be 06 00 00       call   40163d &lt;explode_bomb&gt;</span><br><span class="line">  400f7f:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400f83:c3                   ret</span><br></pre></td></tr></table></figure><p>我这里用最简单的一种组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 535</span><br></pre></td></tr></table></figure><h2 id="0x04-phase-4"><a href="#0x04-phase-4" class="headerlink" title="0x04 phase_4"></a>0x04 phase_4</h2><p>该函数是一个函数调用的嵌套，读取一个数字然后检测返回是否是55</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fc1 &lt;phase_4&gt;:</span><br><span class="line">  400fc1:48 83 ec 18          sub    $0x18,%rsp    ;惯例开辟24字节的栈</span><br><span class="line">  400fc5:48 8d 54 24 0c       lea    0xc(%rsp),%rdx  ;第1个参数存在%rsp+0xc上</span><br><span class="line">  400fca:be c1 1e 40 00       mov    $0x401ec1,%esi  ;%esi惯例是 %d ，用来读取一个数字</span><br><span class="line">  400fcf:b8 00 00 00 00       mov    $0x0,%eax     ;%eax初始化</span><br><span class="line">  400fd4:e8 d7 fa ff ff       call   400ab0 &lt;__isoc99_sscanf@plt&gt; </span><br><span class="line">  400fd9:83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400fdc:75 07                jne    400fe5 &lt;phase_4+0x24&gt; </span><br><span class="line">  400fde:83 7c 24 0c 00       cmpl   $0x0,0xc(%rsp)   ;读取的数字个数应该为1，否则bomb</span><br><span class="line">  400fe3:7f 05                jg     400fea &lt;phase_4+0x29&gt;</span><br><span class="line">  400fe5:e8 53 06 00 00       call   40163d &lt;explode_bomb&gt;</span><br><span class="line">  400fea:8b 7c 24 0c          mov    0xc(%rsp),%edi  ;读取的数字赋值到%edi，作为参数传入&lt;func4&gt;</span><br><span class="line">  400fee:e8 91 ff ff ff       call   400f84 &lt;func4&gt;</span><br><span class="line">  400ff3:83 f8 37             cmp    $0x37,%eax   ;返回值等于55则正常退出</span><br><span class="line">  400ff6:74 05                je     400ffd &lt;phase_4+0x3c&gt;</span><br><span class="line">  400ff8:e8 40 06 00 00       call   40163d &lt;explode_bomb&gt;</span><br><span class="line">  400ffd:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  401001:c3                   ret</span><br></pre></td></tr></table></figure><p>这里的核心代码是func4，func4是一个递归调用。分析后能发现，假如传入参数是a，当a大于1时，return func4(a - 1) + func4(a - 2)，否则return 1，其实很容易发现这是一个斐波那契数列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f84 &lt;func4&gt;:</span><br><span class="line">  400f84:48 89 5c 24 f0       mov    %rbx,-0x10(%rsp)</span><br><span class="line">  400f89:48 89 6c 24 f8       mov    %rbp,-0x8(%rsp)</span><br><span class="line">  400f8e:48 83 ec 18          sub    $0x18,%rsp       ;开栈和寄存器保护</span><br><span class="line">  400f92:89 fb                mov    %edi,%ebx       ;传入参数（假设叫a）赋值到%ebx</span><br><span class="line">  400f94:b8 01 00 00 00       mov    $0x1,%eax    ;返回值赋值1</span><br><span class="line">  400f99:83 ff 01             cmp    $0x1,%edi       ;如果a小于或者等于1，直接返回</span><br><span class="line">  400f9c:7e 14                jle    400fb2 &lt;func4+0x2e&gt;</span><br><span class="line">  400f9e:8d 7b ff             lea    -0x1(%rbx),%edi  ;否则把a-1然后再次传入func4</span><br><span class="line">  400fa1:e8 de ff ff ff       call   400f84 &lt;func4&gt;</span><br><span class="line">  400fa6:89 c5                mov    %eax,%ebp       ;%ebp存func4(a-1)的返回值</span><br><span class="line">  400fa8:8d 7b fe             lea    -0x2(%rbx),%edi</span><br><span class="line">  400fab:e8 d4 ff ff ff       call   400f84 &lt;func4&gt;  ;a-2传入func4</span><br><span class="line">  400fb0:01 e8                add    %ebp,%eax     ;%eax = func4(a-1)+func4(a-2)</span><br><span class="line">  400fb2:48 8b 5c 24 08       mov    0x8(%rsp),%rbx</span><br><span class="line">  400fb7:48 8b 6c 24 10       mov    0x10(%rsp),%rbp</span><br><span class="line">  400fbc:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fc0:c3                   ret       ;返回func4(a-1)+func4(a-2)</span><br></pre></td></tr></table></figure><p>列出斐波那契数列的前几项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure><p>输入55的索引，从0开始算，就是9，输入9就能正常通过这一关了</p><h2 id="0x05-phase-5"><a href="#0x05-phase-5" class="headerlink" title="0x05 phase_5"></a>0x05 phase_5</h2><p>第五个函数的核心代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">0000000000401002 &lt;phase_5&gt;:</span><br><span class="line">  401002:48 83 ec 18          sub    $0x18,%rsp     ;开栈24字节</span><br><span class="line">  401006:48 8d 4c 24 08       lea    0x8(%rsp),%rcx  </span><br><span class="line">  40100b:48 8d 54 24 0c       lea    0xc(%rsp),%rdx</span><br><span class="line">  401010:be be 1e 40 00       mov    $0x401ebe,%esi</span><br><span class="line">  401015:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  40101a:e8 91 fa ff ff       call   400ab0 &lt;__isoc99_sscanf@plt&gt;  ;读取两个数字，第1个存在%rsp+0xc上，第2个存在%rsp+0x8上</span><br><span class="line">  40101f:83 f8 01             cmp    $0x1,%eax   </span><br><span class="line">  401022:7f 05                jg     401029 &lt;phase_5+0x27&gt;   ;读取2个否则bomb</span><br><span class="line">  401024:e8 14 06 00 00       call   40163d &lt;explode_bomb&gt;</span><br><span class="line">  401029:8b 44 24 0c          mov    0xc(%rsp),%eax          ;%eax存第1个参数</span><br><span class="line">  40102d:83 e0 0f             and    $0xf,%eax              ;%eax取低4位掩码（十进制0到15）</span><br><span class="line">  401030:89 44 24 0c          mov    %eax,0xc(%rsp)         ;存回去</span><br><span class="line">  401034:83 f8 0f             cmp    $0xf,%eax             ;若%eax等于15则bomb（需要不为15）</span><br><span class="line">  401037:74 2c                je     401065 &lt;phase_5+0x63&gt;</span><br><span class="line">  401039:b9 00 00 00 00       mov    $0x0,%ecx        </span><br><span class="line">  40103e:ba 00 00 00 00       mov    $0x0,%edx               ;%edx和%ecx初始化，都为0</span><br><span class="line">  401043:83 c2 01             add    $0x1,%edx               ;循环起始，每次循环%edx += 1</span><br><span class="line">  401046:48 98                cltq                           ;将%eax扩展到64位放入%rax</span><br><span class="line">  401048:8b 04 85 a0 1b 40 00 mov    0x401ba0(,%rax,4),%eax  ;%eax = 0x401ba0 + 4 * %rax</span><br><span class="line">  40104f:01 c1                add    %eax,%ecx               ;把%eax加到%ecx</span><br><span class="line">  401051:83 f8 0f             cmp    $0xf,%eax             </span><br><span class="line">  401054:75 ed                jne    401043 &lt;phase_5+0x41&gt;   ;如果%eax不等于15继续循环</span><br><span class="line">  401056:89 44 24 0c          mov    %eax,0xc(%rsp)          ;%eax赋值给第1个参数</span><br><span class="line">  40105a:83 fa 0c             cmp    $0xc,%edx               </span><br><span class="line">  40105d:75 06                jne    401065 &lt;phase_5+0x63&gt;   ;%edx要等于12，才能正常运行</span><br><span class="line">  40105f:3b 4c 24 08          cmp    0x8(%rsp),%ecx          </span><br><span class="line">  401063:74 05                je     40106a &lt;phase_5+0x68&gt;   ;如果第2个参数等于%ecx，则正常结束</span><br><span class="line">  401065:e8 d3 05 00 00       call   40163d &lt;explode_bomb&gt;</span><br><span class="line">  40106a:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  40106e:c3                   ret</span><br></pre></td></tr></table></figure><p>分析发现，第1个参数%eax是0到14间的一个数字，用来取0x401ba0的偏移。取完偏移后，把读出的值存到%eax中，并累加到%ecx中，如果%eax=15则跳出循环。</p><p>之后用%eax更新第1个参数，检测循环次数，要为12次，接着检测第2个参数是否和累加值%ecx相等。</p><p>可以用gdb调试把0x401ba0所有偏移得到的值打印出来分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/16wx 0x401ba0</span><br></pre></td></tr></table></figure><p>打印出来的值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x401ba0 &lt;array.3014&gt;:  0x0000000a      0x00000002      0x0000000e      0x00000007</span><br><span class="line">0x401bb0 &lt;array.3014+16&gt;:       0x00000008      0x0000000c      0x0000000f      0x0000000b</span><br><span class="line">0x401bc0 &lt;array.3014+32&gt;:       0x00000000      0x00000004      0x00000001      0x0000000d</span><br><span class="line">0x401bd0 &lt;array.3014+48&gt;:       0x00000003      0x00000009      0x00000006      0x00000005</span><br></pre></td></tr></table></figure><p>这些值，可能会在等下的偏移中取到，姑且把他看成是存着0到f的数组，然后偏移量%rax看成是下标索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10  2  14  7  8  12  15  11  0  4  1  13  3  9  6  5      上面是值</span><br><span class="line">0   1  2   3  4  5   6   7   8  9  10 11  12 13 14 15     下面是索引%rax</span><br></pre></td></tr></table></figure><p>这下逻辑就十分清晰了，我们要输入一个下标索引，根据索引映射到数组的值，再作为下一次映射的下标，我们要做的事情就是让他映射12次（第12次时读到值15），且算出每次映射的值的和。</p><p>写出逆向脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">10</span>,  <span class="number">2</span> , <span class="number">14</span> , <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">12</span>,  <span class="number">15</span>,  <span class="number">11</span> ,<span class="number">0</span>  ,<span class="number">4</span>  ,<span class="number">1</span>,  <span class="number">13</span>  ,<span class="number">3</span> , <span class="number">9</span>,  <span class="number">6</span>,  <span class="number">5</span>]</span><br><span class="line">last_number = <span class="number">15</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">temp = last_number</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">12</span>):</span><br><span class="line">    <span class="built_in">sum</span> += temp</span><br><span class="line">    temp = a.index(temp)</span><br><span class="line"><span class="built_in">print</span>(temp,<span class="built_in">sum</span>)</span><br><span class="line"><span class="comment">#7 93</span></span><br></pre></td></tr></table></figure><h2 id="0x06-phase-6"><a href="#0x06-phase-6" class="headerlink" title="0x06 phase_6"></a>0x06 phase_6</h2><p>phase_6很容易发现是一个链表。</p><p>假设node0是一个链表的节点，三次解引用就是沿着链表向前搜索三次，然后要满足搜索到的节点的值和node0节点的值相等。来具体看看函数phase_6：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00000000004010d9 &lt;phase_6&gt;:</span><br><span class="line">  4010d9:48 83 ec 08          sub    $0x8,%rsp            </span><br><span class="line">  4010dd:ba 0a 00 00 00       mov    $0xa,%edx            ;%edx = 10</span><br><span class="line">  4010e2:be 00 00 00 00       mov    $0x0,%esi            ;%esi = 0</span><br><span class="line">  4010e7:e8 94 fa ff ff       call   400b80 &lt;strtol@plt&gt;  ;将字符串转换为长整型数（字符串是读取的）</span><br><span class="line">  4010ec:89 05 8e 16 20 00    mov    %eax,0x20168e(%rip)        # 602780 &lt;node0&gt; ;%eax存为node0的值（由读取字符串转换而来的值）</span><br><span class="line">  4010f2:bf 80 27 60 00       mov    $0x602780,%edi         ;%edi存为node0的地址</span><br><span class="line">  4010f7:e8 73 ff ff ff       call   40106f &lt;fun6&gt;   </span><br><span class="line">  4010fc:48 8b 40 08          mov    0x8(%rax),%rax       ;三次解引用（链表顺序向前搜索）</span><br><span class="line">  401100:48 8b 40 08          mov    0x8(%rax),%rax</span><br><span class="line">  401104:48 8b 40 08          mov    0x8(%rax),%rax</span><br><span class="line">  401108:8b 15 72 16 20 00    mov    0x201672(%rip),%edx        # 602780 &lt;node0&gt; </span><br><span class="line">  40110e:39 10                cmp    %edx,(%rax)      ;比较三次解引用后的值和node0的值，相等则程序正常进行</span><br><span class="line">  401110:74 05                je     401117 &lt;phase_6+0x3e&gt;</span><br><span class="line">  401112:e8 26 05 00 00       call   40163d &lt;explode_bomb&gt;  </span><br><span class="line">  401117:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  40111b:c3                   ret</span><br></pre></td></tr></table></figure><p>下面是核心代码func6：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">000000000040106f &lt;fun6&gt;:</span><br><span class="line">  40106f:4c 8b 47 08          mov    0x8(%rdi),%r8        ;%r8 存 node0的8字节偏移的值（应该是下一节点的地址）</span><br><span class="line">  401073:48 c7 47 08 00 00 00 movq   $0x0,0x8(%rdi)       ;node0指向下一节点的地址段更新为0</span><br><span class="line">  40107a:00 </span><br><span class="line">  40107b:48 89 f8             mov    %rdi,%rax        ;node0的地址存到%rax</span><br><span class="line">  40107e:48 89 f9             mov    %rdi,%rcx        ;node0的地址存到%rcx</span><br><span class="line">  401081:4d 85 c0             test   %r8,%r8          </span><br><span class="line">  401084:75 40                jne    4010c6 &lt;fun6+0x57&gt;  ;%r8不为0则跳转</span><br><span class="line">  401086:48 89 f8             mov    %rdi,%rax           ;返回node0的地址</span><br><span class="line">  401089:c3                   ret</span><br><span class="line">  40108a:48 89 d1             mov    %rdx,%rcx</span><br><span class="line">  40108d:48 8b 51 08          mov    0x8(%rcx),%rdx     </span><br><span class="line">  401091:48 85 d2             test   %rdx,%rdx</span><br><span class="line">  401094:74 09                je     40109f &lt;fun6+0x30&gt;</span><br><span class="line">  401096:39 32                cmp    %esi,(%rdx)</span><br><span class="line">  401098:7f f0                jg     40108a &lt;fun6+0x1b&gt;</span><br><span class="line">  40109a:48 89 cf             mov    %rcx,%rdi</span><br><span class="line">  40109d:eb 03                jmp    4010a2 &lt;fun6+0x33&gt;</span><br><span class="line">  40109f:48 89 cf             mov    %rcx,%rdi</span><br><span class="line">  4010a2:48 39 d7             cmp    %rdx,%rdi           ;循环在此开始</span><br><span class="line">  4010a5:74 06                je     4010ad &lt;fun6+0x3e&gt;  ;相等就跳转</span><br><span class="line">  4010a7:4c 89 47 08          mov    %r8,0x8(%rdi)</span><br><span class="line">  4010ab:eb 03                jmp    4010b0 &lt;fun6+0x41&gt;</span><br><span class="line">  4010ad:4c 89 c0             mov    %r8,%rax           ;下一节点的地址存到%rax</span><br><span class="line">  4010b0:49 8b 48 08          mov    0x8(%r8),%rcx      ;下下节点的地址存到%rcx</span><br><span class="line">  4010b4:49 89 50 08          mov    %rdx,0x8(%r8)    </span><br><span class="line">  4010b8:48 85 c9             test   %rcx,%rcx      </span><br><span class="line">  4010bb:74 1a                je     4010d7 &lt;fun6+0x68&gt;  ;%rcx为0就结束函数func6（下个节点是尾节点就结束函数）</span><br><span class="line">  4010bd:49 89 c8             mov    %rcx,%r8      ;下下个节点的地址存到%r8</span><br><span class="line">  4010c0:48 89 c1             mov    %rax,%rcx     ;下个节点的地址存到%rcx</span><br><span class="line">  4010c3:48 89 c7             mov    %rax,%rdi     ;下个节点的地址存到%rdi</span><br><span class="line">  4010c6:48 89 ca             mov    %rcx,%rdx     ;跳转到这</span><br><span class="line">  4010c9:48 85 c9             test   %rcx,%rcx</span><br><span class="line">  4010cc:74 d4                je     4010a2 &lt;fun6+0x33&gt;  ;%rcx为0则跳转（循环）</span><br><span class="line">  4010ce:41 8b 30             mov    (%r8),%esi    ;下下个节点的值存到%esi </span><br><span class="line">  4010d1:39 31                cmp    %esi,(%rcx)   ;下个节点的值和下下节点值比较</span><br><span class="line">  4010d3:7f b8                jg     40108d &lt;fun6+0x1e&gt;  ;前个节点大于后个节点就跳转</span><br><span class="line">  4010d5:eb cb                jmp    4010a2 &lt;fun6+0x33&gt;</span><br><span class="line">  4010d7:f3 c3                repz ret</span><br></pre></td></tr></table></figure><p>核心代码大概是链表的修改过程，是一个降序排序，把你输入的值存入node0。看不懂也没关系，直接上gdb动调很容易理解是降序排序。<br>用gdb调试打印出链表节点的值：(your input)→374→826→370→782→488→673→286→600→529，phase_6查找node3与你的输入值比较，其实就是要求你输入的值在排序中是倒数第4大的。对比数据发现，只要your input在600到673之间，就能满足上述条件。</p><p>826-&gt;782-&gt;673-&gt;your input -&gt;600 …</p><h2 id="0x07-实验结论"><a href="#0x07-实验结论" class="headerlink" title="0x07 实验结论"></a>0x07 实验结论</h2><p>学习和掌握了gdb调试工具的使用。</p><p>学会了objdump反编译机器码</p><p>通过gdb调试工具和objdump分析汇编程序</p><p>成功逆出了6步phase</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用爬虫爬取图片后搭建随机图床</title>
      <link href="/2024/04/21/%E7%94%A8%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E8%94%9A%E8%93%9D%E6%A1%A3%E6%A1%88wiki%E7%9A%84%E8%AE%B0%E5%BF%86%E5%A4%A7%E5%8E%85/"/>
      <url>/2024/04/21/%E7%94%A8%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E8%94%9A%E8%93%9D%E6%A1%A3%E6%A1%88wiki%E7%9A%84%E8%AE%B0%E5%BF%86%E5%A4%A7%E5%8E%85/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-发送网页请求"><a href="#0x01-发送网页请求" class="headerlink" title="0x01 发送网页请求"></a>0x01 发送网页请求</h2><p>在python项目中引入一个requests库，用来发送网页请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#os是操作系统库，re是正则表达式库</span></span><br></pre></td></tr></table></figure><p>复制蔚蓝档案wiki的网址，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url1 = <span class="string">&quot;https://www.gamekee.com/ba/&quot;</span></span><br></pre></td></tr></table></figure><p>有的网站会有基础的反爬检测，通过你请求的user-agent来测试你是不是爬虫的，虽然wiki这里没有反爬检测，如果遇到这种检测的话，可以手动更换user-agent来绕过，如下图。</p><p><img src="/Images/image-20240421103500458.png" alt="image-20240421103500458"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url1 = <span class="string">&quot;https://www.gamekee.com/ba/&quot;</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span> :</span><br><span class="line"> <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36 Edg/124.0.0.0&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url1, headers = headers)</span><br><span class="line"><span class="built_in">print</span>(response.request)</span><br><span class="line"><span class="comment">#返回 &lt;PreparedRequest [GET]&gt; 表示成功请求</span></span><br></pre></td></tr></table></figure><h2 id="0x02-解析网页内容"><a href="#0x02-解析网页内容" class="headerlink" title="0x02 解析网页内容"></a>0x02 解析网页内容</h2><p>我们的任务是</p><p><img src="/Images/image-20240421103659412.png" alt="image-20240421103659412"></p><p>进入如下图的所有学生的网页，然后再是下载图片，所以我们可以先根据正则把这些网页都搜索下来，最后循环依次进入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;解析网页&quot;&quot;&quot;</span></span><br><span class="line">temp_urls = re.findall(<span class="string">&#x27;&lt;a href=&quot;(.*?)&quot; title=&quot;.*?&quot; class=&quot;item&quot; data-v-df5d5428&gt;.*?&lt;/a&gt;&#x27;</span>,html)</span><br></pre></td></tr></table></figure><p>这里有个让我很难绷的事情，就是用此法读取出来的字符串，会带有一大段的前缀，只有最后一小部分是需要的网址，我这里用日奈举例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp_urls = re.findall(<span class="string">&#x27;&lt;a href=&quot;(.*?)&quot; title=&quot;日奈&quot; class=&quot;item&quot; data-v-df5d5428&gt;.*?&lt;/a&gt;&#x27;</span>,html)</span><br><span class="line"><span class="built_in">print</span>(temp_urls)</span><br></pre></td></tr></table></figure><p><img src="/Images/image-20240421132658921.png" alt="image-20240421132658921"></p><p>代码返回这些字符串，只有最后一段是我们所需要的，不知道是什么反爬手段，一次获取就获取一堆。</p><p>我们这里用分割法把这些字符串分割开，只取最后一块网址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;解析网页&quot;&quot;&quot;</span></span><br><span class="line">temp_urls = re.findall(<span class="string">&#x27;&lt;a href=&quot;(.*?)&quot; title=&quot;.*?&quot; class=&quot;item&quot; data-v-df5d5428&gt;.*?&lt;/a&gt;&#x27;</span>,html)</span><br><span class="line"><span class="string">&quot;&quot;&quot;读取特定角色的网页&quot;&quot;&quot;</span></span><br><span class="line">get_url_or_not = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> temp_urls:</span><br><span class="line">    <span class="comment">#从59934到603140</span></span><br><span class="line">    part_of_url = url.split(<span class="string">&#x27;&lt;a href=&quot;&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">&#x27;59934&#x27;</span>,part_of_url):</span><br><span class="line">         get_url_or_not = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> get_url_or_not:</span><br><span class="line">        urls.append( <span class="string">&#x27;https://www.gamekee.com&#x27;</span>+ part_of_url )</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">&#x27;603140&#x27;</span>,part_of_url):</span><br><span class="line">        get_url_or_not = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>如上代码，我们发现角色的网址是59934到603140，写一个if语句判断，然后用<code>split(&#39;&lt;a href=&quot;&#39;)</code>分割得到网址。</p><h2 id="0x03-获取网页内图片"><a href="#0x03-获取网页内图片" class="headerlink" title="0x03 获取网页内图片"></a>0x03 获取网页内图片</h2><p><img src="/Images/image-20240421143135651.png" alt="image-20240421143135651"></p><p>分析网页的图片源的源码，匹配前后红色部分，其余部分用<code>.*?</code>任意非贪婪匹配来代替，然后提取图片中蓝色部分的图片源</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url = urls[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#这里的urls可以是之前获取的网址列表，这里用单个测试防止把网站爬崩</span></span><br><span class="line">response = requests.get(url, headers = headers)</span><br><span class="line">html = response.text</span><br><span class="line"><span class="comment"># print(html)</span></span><br><span class="line">download_url = re.findall(<span class="string">&#x27;data-real=&quot;.*?&quot; src=&quot;(.*?)&quot;&gt;.*?解锁等级&#x27;</span>,html)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;https:&quot;</span> + download_url)</span><br><span class="line">file_name = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#正常输出</span></span><br><span class="line"><span class="comment">#https://cdnimg.gamekee.com/wiki2.0/images/w_3156/h_2214/829/43637/2022/7/19/823498.png</span></span><br></pre></td></tr></table></figure><p>按照这个思路把循环代码补全，记得加上time.sleep，缓冲一下速度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;生成打包图片的文件夹&quot;&quot;&quot;</span></span><br><span class="line">dir_name = <span class="string">r&#x27;F:\picture_bed\My_own_pic_bed\img&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_name):</span><br><span class="line">    os.mkdir(dir_name)</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;解析图片&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> file_name, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls):</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment">#解析出图片的源</span></span><br><span class="line">    response = requests.get(url, headers = headers)</span><br><span class="line">    html = response.text</span><br><span class="line">    <span class="comment">#处理正则匹配的未知异常</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#这个匹配方法，如果有两张记忆大厅图片，会优先下载第一张，但是我们一般是要第二张，这里懒得改了</span></span><br><span class="line">        <span class="comment">#按理来说，只要把这个索引从[0]改成[1]就可以了，试了一下不行，反正就三张特例，手动修改就好了</span></span><br><span class="line">        <span class="comment">#这里第51张，作者因为偷懒了，导致我们匹配失败</span></span><br><span class="line">        download_url = <span class="string">&quot;https:&quot;</span> + re.findall(<span class="string">&#x27;data-real=&quot;.*?&quot; src=&quot;(.*?)&quot;.*?解锁等级&#x27;</span>,html)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#请求下载图片</span></span><br><span class="line">    response = requests.get(download_url, headers = headers)</span><br><span class="line">    <span class="comment">#保存到文件夹</span></span><br><span class="line">    path = dir_name + <span class="string">&#x27;\\&#x27;</span> + <span class="built_in">str</span>(file_name) + <span class="string">&#x27;.png&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(response.content)</span><br></pre></td></tr></table></figure><p><img src="/Images/image-20240421154958017.png" alt="image-20240421154958017"></p><p>（这里我解锁等级呢，唯一一张匹配失败的图片）</p><h2 id="0x04-导入到html文件生成随机图床"><a href="#0x04-导入到html文件生成随机图床" class="headerlink" title="0x04 导入到html文件生成随机图床"></a>0x04 导入到html文件生成随机图床</h2><p><img src="/Images/image-20240421155311077.png" alt="image-20240421155311077"></p><p>这里成功把图片弄到图床文件夹后，根据这些图片的名字，用python写个脚本导出图片名字列表，然后填入到写好的html文件中，随机重定向就能生成随机图床了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用于重定向的html文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = [这里放网址]</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> item = a[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * a.<span class="property">length</span>)];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> b = <span class="title class_">String</span>(item)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = b;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于我不懂html语法，这个脚本是网上抄的，以后有机会再学学看，我这里就先傻瓜式帮运网址名了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urls = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">177</span>):</span><br><span class="line">    urls.append(<span class="string">&quot;https://my-own-pic-bed.pages.dev/img/&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;.png&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(urls)</span><br><span class="line"><span class="comment">#打印图片网址名，然后复制到html脚本里</span></span><br></pre></td></tr></table></figure><h2 id="0x05-部署到github"><a href="#0x05-部署到github" class="headerlink" title="0x05 部署到github"></a>0x05 部署到github</h2><p><img src="/Images/image-20240421160324466.png" alt="image-20240421160324466"></p><p>在这个文件夹里打开git bash，部署，第一次可能有点久</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将更改提交</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;更新图片&quot;</span><br><span class="line"># 推送至github仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>然后直接访问下面的网址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my-own-pic-bed.pages.dev/rand.html</span><br></pre></td></tr></table></figure><p><img src="/Images/image-20240421161703870.png" alt="image-20240421161703870"></p><p>成功了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
            <tag> 图床搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mumu模拟器下adb调试apk文件</title>
      <link href="/2024/04/18/mumu%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8Badb%E8%B0%83%E8%AF%95apk%E6%96%87%E4%BB%B6/"/>
      <url>/2024/04/18/mumu%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8Badb%E8%B0%83%E8%AF%95apk%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-adb连接mumu模拟器"><a href="#0x01-adb连接mumu模拟器" class="headerlink" title="0x01 adb连接mumu模拟器"></a>0x01 adb连接mumu模拟器</h2><p>不知道为什么我去官方下的adb总是连接不上设备，搜索后发现mumu模拟器之类的模拟器都有自带adb程序，于是直接在mumu模拟器的文件下面打开cmd终端，然后adb 直接连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 172.0.0.1:16384</span><br></pre></td></tr></table></figure><p>16384是我的mumu模拟器的端口，这个端口可以通过下图方式查询</p><p><img src="/Images/image-20240418210719876.png" alt="image-20240418210719876"></p><p>连接成功后出现下面提示</p><p><img src="/Images/image-20240418210805830.png" alt="image-20240418210805830"></p><h2 id="0x02-ctf下的apk调试"><a href="#0x02-ctf下的apk调试" class="headerlink" title="0x02 ctf下的apk调试"></a>0x02 ctf下的apk调试</h2><p>这里是为了做一道xyctf 的题目，题目提示说，只要开启了debug，就能得到flag。</p><p>首先，安卓设备要开启开发者模式的调试功能，被调试的app在manifest文件里开启debuggable = “ture”</p><p><img src="/Images/image-20240418211148430.png" alt="image-20240418211148430"></p><p>这里我用jadx反编译后，在这个application下手动添加一个android:debuggable = “true”，这里我已经事先添加过了，还是带着看一遍如何添加。</p><p>jadx里没法修改反编译后的文件，我们将文件安装到mumu模拟器，然后在商店下载一个MT文件管理器。</p><p>打开后点击左上角三横线找到安装包提取</p><p><img src="/Images/image-20240418211715347.png" alt="image-20240418211715347"></p><p>然后点击这个路径直接找到apk文件，点击apk-&gt;查看-&gt;AndroidManifest.xml，反编译模式打开，然后在如上图的application选项下，把调试选项手打进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:debuggable=&quot;true&quot;</span><br></pre></td></tr></table></figure><p>改好后关闭文件，如果出现权限不够的报错，试着把apk文件移动到其他文件夹（跟着报错的提示走就好了）</p><p><img src="/Images/image-20240418212300637.png" alt="image-20240418212300637"></p><p>最后记得把修改后的apk文件覆盖掉电脑上原来的那个apk文件，我通过mumu 的共享文件夹可以把模拟器里面修改后的apk移动到电脑上。</p><h2 id="0x03-终端jeb调试"><a href="#0x03-终端jeb调试" class="headerlink" title="0x03 终端jeb调试"></a>0x03 终端jeb调试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abd shell am start -D -n 包名/需要调试的进程名</span><br></pre></td></tr></table></figure><p>在终端输入上述命令可以启动调试，然后模拟器上就会waiting for debugger，这时候在windows上用jeb打开apk，然后在mainactivity里面调试（这个方法是朋友试的）</p><h2 id="0x04-jadx直接启动调试"><a href="#0x04-jadx直接启动调试" class="headerlink" title="0x04 jadx直接启动调试"></a>0x04 jadx直接启动调试</h2><p>jadx调试时看不到正在指向的调试的指令（我也不知道为什么，等大神解答），但是能很方便的启动调试程序，直接在mumu模拟器打开app，然后jadx直接启动调试</p><p><img src="/Images/image-20240418213045141.png" alt="image-20240418213045141"></p><p>双击红色框里面的app 的包名就能启动调试了，这时候在模拟器的app里就能检测到调试爆出flag。</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2024/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-测试学习网站"><a href="#0x01-测试学习网站" class="headerlink" title="0x01 测试学习网站"></a>0x01 测试学习网站</h2><p>用这个在线网站来测试正则表达式的使用，<a href="http://regex101.com">传送门</a></p><p><img src="/Images/image-20240415225717801.png" alt="image-20240415225717801"></p><p>网站还是很方便学习的，随便粘贴一段文本，选择语言风格就可以开始测试了，这里用PHP测试。</p><h2 id="0x02-限定符Quantifiers"><a href="#0x02-限定符Quantifiers" class="headerlink" title="0x02 限定符Quantifiers"></a>0x02 限定符Quantifiers</h2><h3 id="限定符"><a href="#限定符" class="headerlink" title="?限定符"></a><code>?</code>限定符</h3><p>代表前面的一个字符需要在表达式中出现0次或1次，也就是改字符在匹配中可有可无。</p><p>比如  <code>used?</code>能够匹配到<code>used   use</code></p><h3 id="限定符-1"><a href="#限定符-1" class="headerlink" title="*限定符"></a><code>*</code>限定符</h3><p>代表前面的一个字符可以在表达式中出现任意次，也可以不出现，但不能是其他字符</p><p>比如 <code>ab*c</code> 可以匹配到<code>ac  abbbc  abbbbbc</code>，无法匹配 <code>adc</code></p><h3 id="限定符-2"><a href="#限定符-2" class="headerlink" title="+限定符"></a><code>+</code>限定符</h3><p>和<code>*</code>一样，但是只会匹配出现一次及以上的。</p><h3 id="限定符-3"><a href="#限定符-3" class="headerlink" title="{}限定符"></a><code>&#123;&#125;</code>限定符</h3><p>允许在花括号内写上严格的限定出现次数，<code>&#123;2,6&#125;</code>匹配出现2到6次，<code>&#123;6&#125;</code>匹配出现6次，</p><p><code>&#123;2,&#125;</code>则是匹配大于或者等于2次出现的字符。</p><h3 id="多个字符的情况"><a href="#多个字符的情况" class="headerlink" title="多个字符的情况"></a>多个字符的情况</h3><p>如果要同时对多个连续的字符使用限定符，可以先把这些字符用小括号括起来。</p><h2 id="0x03-“或”运算"><a href="#0x03-“或”运算" class="headerlink" title="0x03 “或”运算"></a>0x03 “或”运算</h2><p>可以用<code>|</code>来使用字符匹配的或</p><p>例如<code>a (cat|dog)</code>则是先匹配a加上空格，后面匹配cat或者dog都可以。</p><h2 id="0x04-字符类"><a href="#0x04-字符类" class="headerlink" title="0x04 字符类[ ]"></a>0x04 字符类[ ]</h2><p><code>[]</code>字符类模板，在中括号内填入需要匹配的字符，代表要求匹配的字符只能取自于它们，可以指定字符的范围。例如<code>a-z A-Z 0-9</code>。然后在后面加上限定符，指定匹配模式。</p><p>在开头加上<code>^</code>脱字符，代表匹配除了尖号后面列出的以外的字符。</p><h2 id="0x05-元字符"><a href="#0x05-元字符" class="headerlink" title="0x05 元字符"></a>0x05 元字符</h2><p>正则表达式中大多元字符都是以反斜杠开头的</p><p><code>\d</code>代表所有的数字字符</p><p><code>\w</code>代表单词字符（英文，数字以及下划线）</p><p><code>\s</code>代表空白符，同时包含Tab和换行符</p><p>把这些元字符大写后，代表取非。</p><p><code>\b</code>代表单词字符的边界。例如这里的<code>\b</code>可以防止部分匹配，而是按照块匹配。</p><p><img src="/Images/image-20240415234121325.png" alt="image-20240415234121325" style="zoom: 50%;" /></p><p><code>.</code>在正则表达式中是一个特殊字符，代表任意字符但不包含换行符。（若想匹配<code>.</code>这个字符，需要在前面加上反斜杠转义。</p><p><code>^a</code>只会匹配行首的a，<code>a$</code>只会去匹配行尾的a</p><h2 id="0x06-贪婪与懒惰匹配"><a href="#0x06-贪婪与懒惰匹配" class="headerlink" title="0x06 贪婪与懒惰匹配"></a>0x06 贪婪与懒惰匹配</h2><p><img src="/Images/image-20240415232949884.png" alt="image-20240415232949884"></p><p>在这个例子中我们想去匹配尖括号以及里面的字符，然而因为<code>.</code>代表任意字符，把除了开头结尾的字符全部匹配进来了，这种匹配方式是默认的，称为贪婪匹配</p><p>解决方法是加上<code>?</code></p><p><img src="/Images/image-20240415233647680.png" alt="image-20240415233647680"></p><p>会将默认的贪婪匹配切换为懒惰匹配。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试命令</title>
      <link href="/2024/04/12/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/04/12/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-GDB调试命令"><a href="#0x01-GDB调试命令" class="headerlink" title="0x01 GDB调试命令"></a>0x01 GDB调试命令</h2><p>这是从csapp里摘抄下来的，基础调试命令。</p><p><img src="/Images/image-20240412095722755.png" alt="image-20240412095722755"></p><p>虽然说这些命令大部分都可以简写，但还是建议先习惯写完整，还能方便理解每一步操作的具体实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深圳大学LC3实验2源码</title>
      <link href="/2024/04/12/%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E6%9C%BA%E5%99%A8%E7%A0%81%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/04/12/%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E6%9C%BA%E5%99%A8%E7%A0%81%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="实验二-机器码编程实验源代码"><a href="#实验二-机器码编程实验源代码" class="headerlink" title="实验二 机器码编程实验源代码"></a>实验二 机器码编程实验源代码</h2><p>LC3汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000    ;将x3000作为程序起始位置</span><br><span class="line">LD R2 xFF      ;读取x3100处的值存入R2</span><br><span class="line">AND R1 R1 #0   ;R1初始化为0</span><br><span class="line">AND R0 R0 #0   ;R0初始化为0，&#x27;1&#x27;计数器</span><br><span class="line">ADD R1 R1 15   ;循环计数器</span><br><span class="line"></span><br><span class="line">LOOP AND R2 R2 R2   ;读取R2符号位</span><br><span class="line">BRZP x1</span><br><span class="line">ADD R0 R0 #1   ;若符号位为1计数器加1</span><br><span class="line">ADD R2 R2 R2   ;R2左移一位</span><br><span class="line">ADD R1 R1 #-1  ;循环计数器-1</span><br><span class="line">BRZP LOOP</span><br><span class="line"></span><br><span class="line">ST R0 xF6</span><br><span class="line">HALT</span><br><span class="line">.END</span><br></pre></td></tr></table></figure><p>LC3机器码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0011000000000000</span><br><span class="line">0010010011111111</span><br><span class="line">0101001001100000</span><br><span class="line">0101000000100000</span><br><span class="line">0001001001101111</span><br><span class="line">0101010010000010</span><br><span class="line">0000011000000001</span><br><span class="line">0001000000100001</span><br><span class="line">0001010010000010</span><br><span class="line">0001001001111111</span><br><span class="line">0000011111111010</span><br><span class="line">0011000011110110</span><br><span class="line">1111000000100101</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深圳大学LC3实验1</title>
      <link href="/2024/04/12/%E8%AE%A1%E7%B3%BB1%E5%AE%9E%E9%AA%8C1/"/>
      <url>/2024/04/12/%E8%AE%A1%E7%B3%BB1%E5%AE%9E%E9%AA%8C1/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目的与要求"><a href="#实验目的与要求" class="headerlink" title="实验目的与要求"></a>实验目的与要求</h2><p>实验目的：</p><p>（1）掌握处理器仿真工具LC-3软件的安装和使用方法。</p><p>（2）学会在LC-3仿真环境下编辑程序和转换成可执行目标程序的方法 。</p><p>（2）学会在LC-3仿真环境下运行和调试程序的方法 。</p><p>实验要求：</p><p>（1）安装LC-3仿真器</p><p>（2）利用LC3EDIT输入机器代码程序（0/1模式）并创建创建可执行目标程序。</p><p>（3）利用LC3EDIT输入机器代码程序（hex模式）并创建创建可执行目标程序。</p><p>（4）利用LC3EDIT输入汇编代码程序并创建创建可执行目标程序。</p><p>（5）利用仿真器运用对应目标程序。</p><p>（6）学习和掌握断点，单步执行等调试方法和手段。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p> LC3WinGuide: </p><p>​     通过chapter1-3学习和掌握仿真器的使用。</p><p>​     完成chapter4:  P15 example1</p><p>​                                P20 example2</p><h2 id="实验过程与步骤"><a href="#实验过程与步骤" class="headerlink" title="实验过程与步骤"></a>实验过程与步骤</h2><h3 id="0x01-安装LC-3仿真器"><a href="#0x01-安装LC-3仿真器" class="headerlink" title="0x01 安装LC-3仿真器"></a>0x01 安装LC-3仿真器</h3><p>运行”仿真器” 目录下的LC301.exe文件，点击unzip即可</p><h3 id="0x02-输入机器or汇编代码"><a href="#0x02-输入机器or汇编代码" class="headerlink" title="0x02 输入机器or汇编代码"></a>0x02 输入机器or汇编代码</h3><h4 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h4><p>输入一段01二进制程序，然后选择File -&gt; save，保存文件，这里我命名为EX1.bin，接着选择Translate -&gt; Convert Base 2，二进制编译模式。</p><p><img src="/Images/wps1.jpg" alt="img"></p><p>同理，输入16进制机器码也可以，选择Translate-&gt;Convert Base 16编译，保存时的文件后缀必须为.hex。</p><p>输入汇编代码的话，文件保存为.asm后缀的文件，选择Translate-&gt;Convert assemble编译。</p><p>编译成功后，显示0个error，然后就能正常生产EX1.obj</p><p><img src="/Images/wps15.jpg" alt="img"></p><p>运行安装目录下的Simulate.exe文件，出现主窗口和console 窗口（ console 用于模拟输入和输出设备）</p><p>选择File -&gt; Load Program，选择刚才编译好的汇编代码EX1.obj</p><p><img src="/Images/wps46.jpg" alt="img"></p><p>这里的主窗口显示了编译后的汇编代码，还有他们的起始地址等等信息</p><p><img src="/Images/wps69.jpg" alt="img"></p><h4 id="运行和调试程序"><a href="#运行和调试程序" class="headerlink" title="运行和调试程序"></a>运行和调试程序</h4><p>选择 Execute -&gt;run 运行程序，然后console窗口会给出运行结束的信息</p><p>这里箭头指向的单步调试按钮，然后红方框里显示着当前各种寄存器的状态，单步调试时可以观察寄存器变化来帮助理解汇编代码</p><p><img src="/Images/wps87.jpg" alt="img"></p><p>除了单步调试，这里还有单步跳出，单步进入等功能，不一一列举了。</p><h3 id="0x03-实战之完成example1"><a href="#0x03-实战之完成example1" class="headerlink" title="0x03 实战之完成example1"></a>0x03 实战之完成example1</h3><p><img src="/Images/wps101.jpg" alt="img"></p><p>编译这段实现乘法的代码，求得R4 * R5的结果并放在R2中</p><p>我将这段代码保存为mul.bin，编译后得到mul.obj，加载进仿真器里。</p><p>接着再halt处下一个断点，防止程序跑完，然后就可以通过Set Value来设置初始寄存器的值，在本例中设置R4和R5的值，不用设太大防止陷入长时间循环。</p><p>我在这里设置为R4 = 3和R5 = 2</p><p><img src="/Images/wps110.jpg" alt="img"></p><p>如图，成功将R4和R5自定义设置，接下来就可以用上个步骤里学习过的单步调试等技术来测试这个程序。</p><h4 id="01单步调试法"><a href="#01单步调试法" class="headerlink" title="01单步调试法"></a>01单步调试法</h4><p>Step over一次一次执行，同时观察寄存器的变化，由于初始值设置得较小，该方法调试的过程并不长。</p><h4 id="02一键运行"><a href="#02一键运行" class="headerlink" title="02一键运行"></a>02一键运行</h4><p>之前在halt设置的断点现在派上用场，直接run program</p><p><img src="/Images/wps121.jpg" alt="img"></p><p>仿真器会提示我们PC，即指向下一条指令的地址，是我们设置的断点处。</p><h4 id="03-循环内设置断点"><a href="#03-循环内设置断点" class="headerlink" title="03 循环内设置断点"></a>03 循环内设置断点</h4><p>RUN一次能跑完一次循环，帮助我们分析每次循环带来的寄存器变化。</p><h4 id="04-分析程序"><a href="#04-分析程序" class="headerlink" title="04 分析程序"></a>04 分析程序</h4><p><img src="/Images/wps128.jpg" alt="img"></p><p>不管用哪种调试方法，都能发现，程序出错了，2*3的结果得到9，很容易发现是循环多跑了一次，原因是如下指令：</p><p><code>0000 011 111111101 ;如果结果&gt;=0 转移至x3201</code></p><p>当R5 = 2时，循环会执行三次，分别是R5为2,1和0时。</p><p>这里将条件跳转的三个条件码设置改为001，结果为正数时跳转，R5为2时就只会循环2和1两次了。</p><p><img src="/Images/wps147.jpg" alt="img"></p><p>修改完后正确得到结果R2 = 6</p><h3 id="0x04-实战之完成example2"><a href="#0x04-实战之完成example2" class="headerlink" title="0x04 实战之完成example2"></a>0x04 实战之完成example2</h3><p>第二个实验和第一个实验一样，编译以下源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line">TRAP x23 ;the trap instruction which is also known as &quot;IN&quot;</span><br><span class="line">ADD R1,R0,x0 ;move the first integer to register 1</span><br><span class="line">TRAP x23 ;another &quot;IN&quot;</span><br><span class="line">ADD     R2，R0，R1 ;两个整数相加</span><br><span class="line">LEA      R0，MESG  ;载入字符串的地址</span><br><span class="line">TRAP     x22         ;输出字符串</span><br><span class="line">ADD      R0，R2，x0  ;sum保存到R0中，并准备输出</span><br><span class="line">TRAP     x21         ;显示结果</span><br><span class="line">HALT</span><br><span class="line">MESG   .STRINGZ  “The sum of those two numbers is”</span><br><span class="line">.END</span><br></pre></td></tr></table></figure><p>加载运行，不难发现程序又出错了，原因是trap读入的值是以字符串的形式读入，若我要实现一个3+4=7，输入3会存储为0x33，而4则是0x34，两者相加得到0x67，是ASCII表里的字符g。</p><p>修改方法则是在数字相加前先各自减去0x30，然后相加后再加上0x30。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line">LD R6, ASCII</span><br><span class="line">LD R5, NEGASCII</span><br><span class="line">TRAP x23 ;输入</span><br><span class="line">ADD R1,R0,x0 ;将第一个整数传给R0</span><br><span class="line">ADD R1,R1,R5 ;将第一个ASCII数字转换成数值</span><br><span class="line">TRAP x23 ;另一个驶入</span><br><span class="line">ADD R0,R0,R5 ;将另一个ASCII数字转换成数值</span><br><span class="line">ADD R2,R0,R1 ;将这两个整数相加</span><br><span class="line">ADD R2,R2,R6 ;将和转换成ASCII表示</span><br><span class="line">LEA R0,MESG ;载入字符串的地址</span><br><span class="line">TRAP x22 ;输出字符串</span><br><span class="line">ADD R0,R2,x0 ;结果传给RO</span><br><span class="line">TRAP x21 ;显示结果</span><br><span class="line">HALT</span><br><span class="line">ASCII .FILL x30 ;mask：转换成ASCII</span><br><span class="line">NEGASCII .FILL xFFD0 ;mask：-x30</span><br><span class="line">MESG .STRINGZ &quot;The sum of those two numbers is &quot;</span><br><span class="line">.END</span><br></pre></td></tr></table></figure><p>编译这份修改后的源码。</p><p><img src="/Images/wps154.jpg" alt="img"></p><p>成功得到正确的结果。</p><p>浅浅分析一下，这份源码修改后的源码分别在R6和R5加载进ASCII和NEGASCII处的值，用来实现字符和数字的转换（加减0x30）</p><h2 id="实验结论或体会"><a href="#实验结论或体会" class="headerlink" title="实验结论或体会"></a>实验结论或体会</h2><p>初步掌握了LC3仿真器的使用，学会了调试和看寄存器。</p><p>初步掌握了LC3代码编译器的使用。</p><p>通过两个example学会了初步用调试功能分析LC3汇编程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adb工具配置和使用</title>
      <link href="/2024/04/09/adb/"/>
      <url>/2024/04/09/adb/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-下载安装与环境变量配置"><a href="#0x01-下载安装与环境变量配置" class="headerlink" title="0x01 下载安装与环境变量配置"></a>0x01 下载安装与环境变量配置</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>adb全称全称为Android Debug Bridge（安卓调试桥），它可以与设备进行通信，实现操作管理Android设备</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1、通过电脑的命令行使用adb，对安卓设备进行操作</p><p>2、比如可以在设备上安装或卸载应用</p><p>3、可以获取设备的基本信息等</p><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>1、adb 是Android SDK Platform-Tools中的一个工具，而Android SDK Platform-Tools是Android SDK的一个组件</p><p>2、对于安卓开发人员来说，在安装IDE （Android Studio）时或是android SDK时就已经带有这个工具</p><p>3、而对于非开发人员，也可以通过直接下载adb安装包的方式安装</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://developer.android.com/studio/releases/platform-tools?hl=zh-cn">SDK Platform-Tools下载地址</a></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>下载解压后将adb所在的地址添加到系统里的环境变量，然后再cmd命令行输入adb，若有adb的信息出现说明配置成功。</p><h2 id="0x02-通过adb连接安卓设备"><a href="#0x02-通过adb连接安卓设备" class="headerlink" title="0x02 通过adb连接安卓设备"></a>0x02 通过adb连接安卓设备</h2><h3 id="adb的工作原理"><a href="#adb的工作原理" class="headerlink" title="adb的工作原理"></a>adb的工作原理</h3><p>adb 提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：</p><p>客户端：用于发送命令。客户端在开发机器上运行。您可以通过发出 adb 命令从命令行终端调用客户端。 守护程序</p><p>守护程序 (adbd)：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。</p><p>服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。</p><h3 id="abd的工作流程"><a href="#abd的工作流程" class="headerlink" title="abd的工作流程"></a>abd的工作流程</h3><p>1、当某个adb 客户端启动时，会先检查是否有 adb 服务器进程已在运行</p><p>2、如果没有，它会启动服务器进程</p><p>3、服务器在启动后会与本地 TCP 端口 5037 绑定，并监听 adb 客户端发出的命令</p><p>4、服务器会与所有正在运行的设备建立连接。它通过扫描 5555 到 5585 之间的奇数号端口查找模拟              器。服务器一旦发现 adb 守护程序 (adbd)，便会与相应的端口建立连接</p><p>5、服务器与设备建立连接后，便可以使用 adb 命令访问这些设备</p><h3 id="开启手机USB调试模式"><a href="#开启手机USB调试模式" class="headerlink" title="开启手机USB调试模式"></a>开启手机USB调试模式</h3><p>打开开发者选项隐藏开关：</p><p>开启手机的开发者模式，方法是进入设置里的关于手机（我的设备），然后点击里面的参数信息多次，若该参数信息是正确的则会提示再次点击可开启开发者模式，打开后返回系统管理界面就能看到开发者选项。</p><p><img src="/Images/1e0c56eb2105dcdb9c3aced9ef82ed9.jpg" alt="1e0c56eb2105dcdb9c3aced9ef82ed9" style="zoom:33%;" /></p><p>开启USB调试：</p><p>打开开发者选项，然后往下继续找到USB调试开关，打开。</p><p><img src="/Images/0633c66f346bf53bf58ccd4a9712c63.jpg" alt="0633c66f346bf53bf58ccd4a9712c63" style="zoom:33%;" /></p><h3 id="adb连接安卓设备"><a href="#adb连接安卓设备" class="headerlink" title="adb连接安卓设备"></a>adb连接安卓设备</h3><p>打开手机上的开发者选项和开关后用USB连接，接着点击手机上的允许调试。</p><p>打开电脑终端，输入以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices -l</span><br></pre></td></tr></table></figure><p>查看输出结果，就可以看到设备是否连接成功</p><p><img src="/Images/image-20240409222351890.png" alt="image-20240409222351890"></p><h3 id="adb-devices-l的含义"><a href="#adb-devices-l的含义" class="headerlink" title="adb devices -l的含义"></a>adb devices -l的含义</h3><p>作为“adb devices -l”的响应，adb 会针对每个设备输出以下状态信息：</p><p>序列号：adb 会创建一个字符串，用于通过端口号唯一标识设备。下面是一个序列号示例：emulator-5554</p><p>状态：设备的连接状态可以是以下几项之一：</p><p>offline：设备未连接到 adb 或没有响应。</p><p>device：设备已连接到 adb服务器。请注意，此状态并不表示 Android 系统已完全启动并可正常运行，因为在设备连接到 adb时系统仍在启动。系统完成启动后，设备通常处于此运行状态。</p><p>no device：未连接任何设备。</p><p>说明：如果加入 -l 选项，devices命令会告知设备是什么。当连接了多个设备时，此信息可以方便区分这些设备。</p><h2 id="0x03-使用adb操作手机"><a href="#0x03-使用adb操作手机" class="headerlink" title="0x03 使用adb操作手机"></a>0x03 使用adb操作手机</h2><h3 id="查询是否连接"><a href="#查询是否连接" class="headerlink" title="查询是否连接"></a>查询是否连接</h3><p>用上个步骤的<code>adb devices</code>命令来检测</p><p>如果出现异常可以重启adb服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server</span><br><span class="line">adb start-server</span><br></pre></td></tr></table></figure><p>如果出现<code>daemon started successfully</code>字样，说明adb服务启动成功</p><h3 id="尝试安装app"><a href="#尝试安装app" class="headerlink" title="尝试安装app"></a>尝试安装app</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install &quot;D:\test file\test.apk&quot;</span><br></pre></td></tr></table></figure><p>注：当文件路径有空格的情况下，需要给路径加上引号</p><p>安装成功后，响应<code>success</code></p><p>若安装失败：</p><p>1、设备未连接：adb.exe: no devices/emulators found</p><p>2、文件未找到：adb: failed to stat D:\test1.apk: No such file or directory</p><p>3、在安卓低系统设备上，这个指令直接用于覆盖安装时会报错：INSTALL_FAILED_ALREADY_EXISTS</p><p>在第三种情况中，加伤-r选项可以允许覆盖安装。</p><h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall app_key </span><br></pre></td></tr></table></figure><p><code>app_key</code>为需要删除的包名</p><h3 id="多设备连接"><a href="#多设备连接" class="headerlink" title="多设备连接"></a>多设备连接</h3><p>当多个设备连接时，执行命令却未指定设备会报错。</p><p>需要在指令中adb后面加上设备的序列号，序列号可以通过<code>adb devices -l</code>查看</p><h2 id="0x04-其他指令"><a href="#0x04-其他指令" class="headerlink" title="0x04 其他指令"></a>0x04 其他指令</h2><h3 id="启动应用指令"><a href="#启动应用指令" class="headerlink" title="启动应用指令"></a>启动应用指令</h3><p>通过adb指令可以直接启动应用，但需要知道应用的启动activity的完整路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start 包名</span><br></pre></td></tr></table></figure><p>如果不知道应用的启动activity，可以尝试使用下面方法：</p><p>1、使用adb指令“adb logcat -c”清空日志</p><p>2、再使用adb指令“adb logcat ActivityManager:I *:S”，这样会打印出设备上运行的activity信息</p><p>3、启动应用</p><p>4、然后在运行信息里面找到包名，一般包名由花括号括起来，然后前面有<code>pre-top-activity</code>字样</p><h3 id="使用浏览器打开指定网址"><a href="#使用浏览器打开指定网址" class="headerlink" title="使用浏览器打开指定网址"></a>使用浏览器打开指定网址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a android.intent.action.VIEW -d URL</span><br></pre></td></tr></table></figure><p>URL是网址</p><h3 id="杀死应用进程"><a href="#杀死应用进程" class="headerlink" title="杀死应用进程"></a>杀死应用进程</h3><p>1、杀死指定应用的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am force-stop 包名</span><br></pre></td></tr></table></figure><p>2、终止所有后台进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am kill-all</span><br></pre></td></tr></table></figure><h3 id="删除应用所有数据"><a href="#删除应用所有数据" class="headerlink" title="删除应用所有数据"></a>删除应用所有数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm clear 包名</span><br></pre></td></tr></table></figure><h3 id="获取设备已安装应用列表"><a href="#获取设备已安装应用列表" class="headerlink" title="获取设备已安装应用列表"></a>获取设备已安装应用列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages 选项 关键字</span><br></pre></td></tr></table></figure><p>选项和关键字非必填</p><p>如果填写了关键字，将会输出包含关键字的应用</p><p>选下有下面几种：</p><ul><li>-f：查看关联文件。</li><li>-d：进行过滤以仅显示已停用的软件包。</li><li>-e：进行过滤以仅显示已启用的软件包。</li><li>-s：进行过滤以仅显示系统软件包。</li><li>-3：进行过滤以仅显示第三方软件包。</li><li>-i：查看软件包的安装程序。</li><li>-u：包括已卸载的软件包。</li><li>–user user_id：要查询的用户空间。</li></ul><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>1、将文件从设备复制电脑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull 设备上的地址 本地地址</span><br></pre></td></tr></table></figure><p>2、将文件从电脑复制设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push 本地地址 设备上的地址</span><br></pre></td></tr></table></figure><h3 id="手机截图"><a href="#手机截图" class="headerlink" title="手机截图"></a>手机截图</h3><p>当设备连接adb时，可以使用adb指令截图设备屏幕截图</p><p>1、截屏，并将截图保存在指定目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap /文件路径/图片名字</span><br></pre></td></tr></table></figure><p>2、将截图复制到电脑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /文件路径/图片名字 本地地址</span><br></pre></td></tr></table></figure><p>补充一下录制视频的命令<code>screenrecord</code>，格式和手机截图类似，通过Ctrl + C可以停止屏幕录制</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和寄存器</title>
      <link href="/2024/04/09/%E6%A0%88%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2024/04/09/%E6%A0%88%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-寄存器和栈"><a href="#0x01-寄存器和栈" class="headerlink" title="0x01 寄存器和栈"></a>0x01 寄存器和栈</h2><p><img src="/Images/image-20240409170718620.png" alt="image-20240409170718620"></p><h3 id="被调用者保护"><a href="#被调用者保护" class="headerlink" title="被调用者保护"></a>被调用者保护</h3><p><code>%rbp</code> ，<code>%rbx</code>和<code>%r12~15</code></p><p>被调用者保护的寄存器在进入一个函数后会先压入栈来保存原先的值</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>%rax</code></p><p>寄存器rax通常存储着一个函数的返回值</p><h3 id="调用者保护"><a href="#调用者保护" class="headerlink" title="调用者保护"></a>调用者保护</h3><p>除被调用者保护外。</p><p>和被调用者保护相反，可以随意修改该寄存器里的值而不需要压入栈来保存</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>%rdi,%rsi,%rdx,%rcx,%r8,%r9</code></p><p>这里默认有六个参数寄存器，在传入函数时使用，超过的参数将在栈帧上保存</p><h3 id="栈指针"><a href="#栈指针" class="headerlink" title="栈指针"></a>栈指针</h3><p><code>%rsp</code></p><p>指示着栈顶的位置，栈往低处生长</p><h2 id="0x02-运行时栈"><a href="#0x02-运行时栈" class="headerlink" title="0x02 运行时栈"></a>0x02 运行时栈</h2><p><img src="/Images/image-20240409171340649.png" alt="image-20240409171340649"></p><h3 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3><p>在进入一个函数前，先将该call该函数的指令的下一条指令的地址压入栈，当执行ret指令时将该返回地址从栈中弹出，作为%rip的值（下一条执行指令的地址）</p><h3 id="被保存的寄存器"><a href="#被保存的寄存器" class="headerlink" title="被保存的寄存器"></a>被保存的寄存器</h3><p>对应寄存器中的被调用者保护寄存器，进入函数前先保存。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>有时，局部数据必须存放在内存中，常见的情况包括：</p><p>1、寄存器不足够存放所有的本地数据。</p><p>2、对一个局部变量使用地址运算符＇＆＇，因此必须能够为它产生一个地址</p><p>3、某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到 </p><h3 id="参数构造区"><a href="#参数构造区" class="headerlink" title="参数构造区"></a>参数构造区</h3><p>当传入的函数的参数超过六个（对应六个参数寄存器）时，需要在call之前先在栈顶构造参数，存储在栈上，使得调用的函数通过栈指针来读取参数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> cum15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emplace_back()</title>
      <link href="/2024/04/09/emplace-back/"/>
      <url>/2024/04/09/emplace-back/</url>
      
        <content type="html"><![CDATA[<h2 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back( )"></a>emplace_back( )</h2><p>在容器末尾添加一个新元素，它通常使用 placement-new 在容器提供的位置就地构造元素。</p><p>通常要保证操作后的size不大于旧的capacity（end迭代器要重新生成），否则需要重新分配内存，这种情况下所有迭代器和对元素的所有引用都会失效。</p><p>下面代码是从cpp reference抄来的，理解一下怎么运行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">President</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string country;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">President</span>(std::string p_name, std::string p_country, <span class="type">int</span> p_year)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(p_country)), <span class="built_in">year</span>(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am being constructed.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">President</span>(President&amp;&amp; other)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(other.country)), <span class="built_in">year</span>(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am being moved.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="type">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;President&gt; elections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;emplace_back:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; ref = elections.<span class="built_in">emplace_back</span>(<span class="string">&quot;Nelson Mandela&quot;</span>, <span class="string">&quot;South Africa&quot;</span>, <span class="number">1994</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ref.year == <span class="number">1994</span> &amp;&amp; <span class="string">&quot;uses a reference to the created object (C++17)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;President&gt; reElections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npush_back:\n&quot;</span>;</span><br><span class="line">    reElections.<span class="built_in">push_back</span>(<span class="built_in">President</span>(<span class="string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="string">&quot;the USA&quot;</span>, <span class="number">1936</span>));</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nContents:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="type">const</span>&amp; president: elections)</span><br><span class="line">        std::cout &lt;&lt; president.name &lt;&lt; <span class="string">&quot; was elected president of &quot;</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (President <span class="type">const</span>&amp; president: reElections)</span><br><span class="line">        std::cout &lt;&lt; president.name &lt;&lt; <span class="string">&quot; was re-elected president of &quot;</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的是Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">I am being constructed.</span><br><span class="line"> </span><br><span class="line">push_back:</span><br><span class="line">I am being constructed.</span><br><span class="line">I am being moved.</span><br><span class="line"> </span><br><span class="line">Contents:</span><br><span class="line">Nelson Mandela was elected president of South Africa in 1994.</span><br><span class="line">Franklin Delano Roosevelt was re-elected president of the USA in 1936.</span><br></pre></td></tr></table></figure><h2 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h2><h3 id="default"><a href="#default" class="headerlink" title="= default"></a>= default</h3><p><code>President&amp; operator=(const President&amp; other) = default;</code></p><p>这串代码里的<code>= default</code>使得编译器将会提供该函数的默认实现，并且保证这些默认实现不会被删除；构造函数和析构函数将提供默认的空实现。</p><p>作用：</p><p>1、生成默认实现：当一个类没有显式定义构造函数或析构函数时，编译器会自动生成默认的构造函数或析构函数。如果我们在类中使用了default关键字，则可以显式地告诉编译器使用默认的实现。</p><p>2、防止默认实现被删除：在某些情况下，编译器不会生成默认的构造函数或析构函数，例如当类包含了一个用户自定义的构造函数或析构函数时。如果我们想要让编译器生成默认的实现，可以在类定义中使用default关键字来显式声明默认的构造函数或析构函数。（例子里属于这种）</p><h3 id="std-move"><a href="#std-move" class="headerlink" title="std : : move"></a>std : : move</h3><p><code>name(std::move(p_name))</code>这里的p_name作为一个右值，通过std::move绑定左值name，相当于构造函数里给name赋值。</p><h3 id="构造函数President"><a href="#构造函数President" class="headerlink" title="构造函数President"></a>构造函数President</h3><p>这里构造函数有两种手动实现，第一种直接传入三个参数构造，第二种传入类other再构造，通过输出很容易发现，通过emplace_back构造的函数直接通过第一种构造，传入参数，不需要生成类再拷贝。</p><p>通过push_back的输出发现，会先构造President类，再通过第二种构造拷贝构造，需要两步。</p><h3 id="c-11的for"><a href="#c-11的for" class="headerlink" title="c++11的for"></a>c++11的for</h3><p><code>for (President const&amp; president: elections)</code></p><p>先定义一个变量，这里是president，然后从序列elections一个一个取出全部元素循环。（例子里这里只有一个President变量elections，只循环一次，将elections作为president取出）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这段代码就是让你看透emplace_back和push_back添加元素的本质区别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体数据类型所占字节长度</title>
      <link href="/2024/04/09/%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82%E9%95%BF%E5%BA%A6/"/>
      <url>/2024/04/09/%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>记录一下结构体的数据类型大小怎么算，主要看对齐数和地址偏移量</p><h2 id="计算原理"><a href="#计算原理" class="headerlink" title="计算原理"></a>计算原理</h2><p>举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];<span class="comment">//8 byte</span></span><br><span class="line"><span class="type">int</span> com, math, english;</span><br><span class="line"><span class="type">double</span> average;<span class="comment">//8 byte</span></span><br><span class="line">&#125; stu;</span><br><span class="line">stu boy[<span class="number">1000</span>], * p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(stu)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对齐数的大小，在vs编译器里，是数据类型大小和默认对齐数（vs是8）的最小值。</p><p>从第二个数据开始，数据首个字节的地址的偏移量要为对齐数的整数倍</p><p>对于数据类型stu，num先填充4 bytes，之后第二个char name[10]的对齐数是10和8的较小值，为8 bytes，首地址应为8的整数倍的偏移地址量，最小为8，所以从8开始存放name，</p><p>第三个数据还是int，现在已经填充了num，4个0xcc，name，加起来偏移地址为18，int对齐数是4，再填充两个0xcc，从偏移地址20开始填充三个int，20+12=32，</p><p>第四个数据是double，对齐数是其64位的大小，8bytes，32是8的整数倍，可以直接填入，加起来是40，所以sizeof(stu) 的大小是40</p><p><img src="/Images/430208b28b1148d99a4e0b1d209590c4.png" alt="430208b28b1148d99a4e0b1d209590c4"></p><p>数组的情况是同理的，把他看成几个连续的单个数据算就好了</p><h2 id="当结构体中有其他结构体"><a href="#当结构体中有其他结构体" class="headerlink" title="当结构体中有其他结构体"></a>当结构体中有其他结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];<span class="comment">//8 byte</span></span><br><span class="line"><span class="type">int</span> com, math, english;</span><br><span class="line"><span class="type">double</span> average;<span class="comment">//8 byte</span></span><br><span class="line">&#125; stu;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">cls</span> &#123;</span><br><span class="line"><span class="type">int</span> class_number;</span><br><span class="line">stu one;</span><br><span class="line">&#125;;</span><br><span class="line">stu boy[<span class="number">1000</span>], * p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(stu)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(cls);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stu one 需要从其结构体内部数据的最大对齐数的整数倍的地址偏移量开始，这里内部最大是8，所以应该从cls里的地址偏移量为8开始存储，就是40+8=48。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合和数据对齐</title>
      <link href="/2024/04/09/%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E8%81%94%E5%90%88%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/"/>
      <url>/2024/04/09/%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E8%81%94%E5%90%88%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-联合"><a href="#0x01-联合" class="headerlink" title="0x01 联合"></a>0x01 联合</h2><p>联合允许以多种类型来引用一个对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U3</span>&#123;</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三种数据结构仅能存储一种</span></span><br></pre></td></tr></table></figure><p>一个联合的总的大小等于它最大字段的大小</p><p>应用场景：</p><p>一个数据结构中的个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分 ，而不是结构的一部分，会减小分配空间的总量。</p><p>union还可以用来访问不同的数据类型的位模式，用一种数据类型才存储联合中的参数，又用另一种数据类型来访问它，除了有一样的位模式外，数值一般没有任何关联。</p><h2 id="0x02-数据对齐"><a href="#0x02-数据对齐" class="headerlink" title="0x02 数据对齐"></a>0x02 数据对齐</h2><p>许多计算机系统对基本数据类型的合法地址做出了 些限制，要求某种类型对象的地址必须是某个值 K( 通常是2，4或8) 的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。</p><h3 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h3><p>对齐原则是任何K字节的基本对象的地址必须是K的倍数。</p><p><code>align 8</code>    </p><p>这段声明保证了它后面的数据的起始地址是8的倍数，常用于8字节数据类型的对齐。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>看下面的例子：</p><p>结构体的起始地址和其中的数据类型，一般要满足对齐（对齐大小一般最大的数据类型大小）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span> </span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="type">char</span> c; </span><br><span class="line"><span class="type">int</span> j; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/Images/image-20240409180939599.png" alt="image-20240409180939599"></p><p>如图所示，蓝色部分为了满足对齐而被浪费了。</p><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>结构的末尾有时候也需要填充，这样结构数组中的每个元素都会满足他们的对齐要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span> </span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="type">int</span> j; </span><br><span class="line"><span class="type">char</span> c; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/Images/image-20240409181218102.png" alt="image-20240409181218102"></p><p>只有在结构末尾填充，才能使得该结构体数组的每个结构的起始地址都是4的倍数。</p><h2 id="0x03-结构体内偏移和填充的具体分布"><a href="#0x03-结构体内偏移和填充的具体分布" class="headerlink" title="0x03 结构体内偏移和填充的具体分布"></a>0x03 结构体内偏移和填充的具体分布</h2><p>研究复杂结构体内部的填充是怎么进行的，可以参考<a href="https://www.beihaihaihai.top/2024/04/09/%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82%E9%95%BF%E5%BA%A6/">结构体数据类型的所占字节长度</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学公式编辑</title>
      <link href="/2024/04/07/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"/>
      <url>/2024/04/07/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>打算记录一些数学题目，发现不会编辑数学公式，遂记录。</p><p>编辑数学公式前，要将其囊括在首尾两个美元符号的大括号中。</p><h2 id="0x02-常用符号"><a href="#0x02-常用符号" class="headerlink" title="0x02 常用符号"></a>0x02 常用符号</h2><p>整合一些常用的符号例如古希腊字母，积分符号，求和符号等等。</p><h3 id="古希腊字母"><a href="#古希腊字母" class="headerlink" title="古希腊字母"></a>古希腊字母</h3><p><img src="/Images/image-20240402181057758.png" alt="image-20240402181057758"></p><h3 id="各种运算符号"><a href="#各种运算符号" class="headerlink" title="各种运算符号"></a>各种运算符号</h3><p><img src="/Images/image-20240402181435055.png" alt="image-20240402181435055"></p><h3 id="三角函数和对数"><a href="#三角函数和对数" class="headerlink" title="三角函数和对数"></a>三角函数和对数</h3><p>只需要在反斜杠后加上对应字母表示</p><p>补充一下圆周率是pi</p><h3 id="向量符号和根号等"><a href="#向量符号和根号等" class="headerlink" title="向量符号和根号等"></a>向量符号和根号等</h3><p><img src="/Images/image-20240402181724770.png" alt="image-20240402181724770"></p><h3 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h3><p>主要是math mode</p><p><img src="/Images/image-20240402181825954.png" alt="image-20240402181825954"></p><h2 id="0x03-基本编辑方法"><a href="#0x03-基本编辑方法" class="headerlink" title="0x03 基本编辑方法"></a>0x03 基本编辑方法</h2><p>记录一些数学公式编辑方法</p><h3 id="如何输入上下标"><a href="#如何输入上下标" class="headerlink" title="如何输入上下标"></a>如何输入上下标</h3><p><code>^</code> 表示上表，<code>_</code> 表示下标，如果上下标的内容多于一个字符，需要用 <code>&#123;&#125;</code>将这些内容括成一个整体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;e&#123;^x_y&#125;=(x+2)^5&#125;$</span><br></pre></td></tr></table></figure><p>​                                                                 ${e{^x_y}=(x+2)^5}$</p><h3 id="如何显示分数"><a href="#如何显示分数" class="headerlink" title="如何显示分数"></a>如何显示分数</h3><p>通常使用 <code>\frac &#123;分子&#125; &#123;分母&#125;</code> 来生成一个分数，分数可多层嵌套。如果分式较为复杂，亦可使用 <code>分子 \over 分母</code> 此时分数仅有一层                                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;\frac&#123;x+1&#125;&#123;y+1&#125;=\frac xy&#125;$</span><br></pre></td></tr></table></figure><p>​                                                                    ${\frac{x+1} {y+1}=\frac xy}$</p><p>或者使用<code>\frac ab</code>快速生成一个a/b</p><h3 id="如何输入省略号"><a href="#如何输入省略号" class="headerlink" title="如何输入省略号"></a>如何输入省略号</h3><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与 <strong>文本底线</strong> 对齐的省略号，<code>\cdots</code> 表示与 <strong>文本中线</strong> 对齐的省略号</p><h3 id="如何输入积分"><a href="#如何输入积分" class="headerlink" title="如何输入积分"></a>如何输入积分</h3><p>使用 <code>\int_积分下限^积分上限 &#123;被积表达式&#125;</code> 来输入一个积分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;\int&#123;_1^2&#125;&#123;f^&#123;-1&#125;(x)dx&#125;&#125;$</span><br></pre></td></tr></table></figure><p>​                                                                 ${\int{_1^2} {f^{-1}(x)dx} }$</p><h3 id="如何输入极限"><a href="#如何输入极限" class="headerlink" title="如何输入极限"></a>如何输入极限</h3><p>使用 <code>\lim_&#123;变量 \to 表达式&#125; 表达式</code> 来输入一个极限。如有需求，可以更改 <code>\to</code> 符号至任意符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;\lim_&#123;x \to \infty&#125;\frac&#123;sinx&#125;&#123;x&#125;&#125;$</span><br></pre></td></tr></table></figure><p>​                                                                  ${\lim_{x \to \infty}\frac{sinx} {x} }$</p><h2 id="0x04-符号汇总"><a href="#0x04-符号汇总" class="headerlink" title="0x04 符号汇总"></a>0x04 符号汇总</h2><p><img src="/Images/2018041621294865.png" alt="2018041621294865"></p><p><img src="/Images/20180416213036844.png" alt="20180416213036844"></p><p><img src="/Images/20180416213119987.png" alt="20180416213119987"></p><p><img src="/Images/20180416213126857.png" alt="20180416213126857"></p><h3 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h3><p><a href="https://blog.csdn.net/Snakewood/article/details/130445273">纯手打可复制的数学公式表</a></p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11关于四个引用的学习</title>
      <link href="/2024/03/09/c-11%E5%85%B3%E4%BA%8E-%E5%BC%95%E7%94%A8/"/>
      <url>/2024/03/09/c-11%E5%85%B3%E4%BA%8E-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-引用的嵌套"><a href="#0x01-引用的嵌套" class="headerlink" title="0x01 引用的嵌套"></a>0x01 引用的嵌套</h2><p>It is permitted to form references to references through type manipulations in templates or typedefs, in which case the <em>reference collapsing</em> rules apply: rvalue reference to rvalue reference collapses to rvalue reference, all other combinations form lvalue reference</p><p>引用折叠规则：右值对右值的引用折叠为右值引用，所有其他组合为左值引用。</p><h2 id="0x02-左值引用"><a href="#0x02-左值引用" class="headerlink" title="0x02 左值引用"></a>0x02 左值引用</h2><p>Lvalue references can be used to alias an existing object (optionally with different cv-qualification):</p><p>左值引用可以作为一个已存在对象的别名，且可以用多个别名，别名之间共享一个对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Ex&quot;</span>;</span><br><span class="line">    std::string&amp; r1 = s;</span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s;</span><br><span class="line"> </span><br><span class="line">    r1 += <span class="string">&quot;ample&quot;</span>;           <span class="comment">// modifies s</span></span><br><span class="line"><span class="comment">//  r2 += &quot;!&quot;;               // error: cannot modify through reference to const</span></span><br><span class="line">    std::cout &lt;&lt; r2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints s, which now holds &quot;Example&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里r1和r2是一个东西</span></span><br></pre></td></tr></table></figure><p>They can also be used to implement pass-by-reference semantics in function calls:</p><p>左值引用可以在函数中引用传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">double_string</span><span class="params">(std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s += s; <span class="comment">// &#x27;s&#x27; is the same object as main()&#x27;s &#x27;str&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    <span class="built_in">double_string</span>(str);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When a function’s return type is lvalue reference, the function call expression becomes an lvalue expression:</p><p>当一个函数的返回值是左值引用时，这个函数调用表达式也成为了左值表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">char_number</span><span class="params">(std::string&amp; s, std::<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">at</span>(n); <span class="comment">// string::at() returns a reference to char</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    <span class="built_in">char_number</span>(str, <span class="number">1</span>) = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// the function call is lvalue, can be assigned to</span></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里s.at(1) = &#x27;a&#x27;;一个左值表达式</span></span><br></pre></td></tr></table></figure><h2 id="0x03-右值引用"><a href="#0x03-右值引用" class="headerlink" title="0x03 右值引用"></a>0x03 右值引用</h2><p>Rvalue referencesRvalue references can be used to extend the lifetimes of temporary objects (note, lvalue references to const can extend the lifetimes of temporary objects too, but they are not modifiable through them):</p><p>右值引用可以延长临时对象的生命周期，左值引用加const也能延长生命周期（cppref 的例子，我也不知道有什么用，随便翻译一下吧）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line"><span class="comment">//  std::string&amp;&amp; r1 = s1;           // error: can&#x27;t bind to lvalue不能绑定左值</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s1 + s1; <span class="comment">// okay: lvalue reference to const extends lifetime</span></span><br><span class="line">     <span class="comment">//const左值引用可以延长生命周期</span></span><br><span class="line"><span class="comment">//  r2 += &quot;Test&quot;;                    // error: can&#x27;t modify through reference to const</span></span><br><span class="line">     <span class="comment">//const 的值不能修改</span></span><br><span class="line"> </span><br><span class="line">    std::string&amp;&amp; r3 = s1 + s1;      <span class="comment">// okay: rvalue reference extends lifetime</span></span><br><span class="line">     <span class="comment">//延长临时变量生命周期</span></span><br><span class="line">    r3 += <span class="string">&quot;Test&quot;</span>;                    <span class="comment">// okay: can modify through reference to non-const</span></span><br><span class="line">    std::cout &lt;&lt; r3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>More importantly, when a function has both rvalue reference and lvalue reference overloads, the rvalue reference overload binds to rvalues (including both prvalues and xvalues), while the lvalue reference overload binds to lvalues</p><p>当一个函数同时有左值和右值的重载时，右值引用重载绑定右值，左值引用重载绑定左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference to const overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">f</span>(i);  <span class="comment">// calls f(int&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(ci); <span class="comment">// calls f(const int&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">3</span>);  <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line">           <span class="comment">// would call f(const int&amp;) if f(int&amp;&amp;) overload wasn&#x27;t provided</span></span><br><span class="line">       <span class="comment">// 如果没有f(int&amp;&amp;)重载提供，将调用f(const int&amp;)</span></span><br><span class="line">    <span class="comment">//move后左值被转化成右值</span></span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(i)); <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// rvalue reference variables are lvalues when used in expressions</span></span><br><span class="line">    <span class="comment">//右值引用将被当成左值，在函数表达式中时</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(x);            <span class="comment">// calls f(int&amp; x)</span></span><br><span class="line">    <span class="comment">//move后左值被转化成右值</span></span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(x)); <span class="comment">// calls f(int&amp;&amp; x)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">/*lvalue reference overload f(1)</span></span><br><span class="line"><span class="comment">  lvalue reference to const overload f(2)</span></span><br><span class="line"><span class="comment">  rvalue reference overload f(3)</span></span><br><span class="line"><span class="comment">  rvalue reference overload f(1)</span></span><br><span class="line"><span class="comment">  lvalue reference overload f(1)</span></span><br><span class="line"><span class="comment">  rvalue reference overload f(1)*/</span></span><br></pre></td></tr></table></figure><p>可以通过std::move将42绑定i2，使得i2成为一个右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rri = std::<span class="built_in">move</span>(i2); <span class="comment">// binds directly to i2</span></span><br></pre></td></tr></table></figure><p>This makes it possible to move out of an object in scope that is no longer needed:</p><p>通过这样就可以舍去作用域中不再需要的对象：（这个例子移去了v）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(std::move(v))</span></span>; <span class="comment">// binds an rvalue reference to v（绑定右值引用到v）</span></span><br><span class="line"><span class="comment">//断言函数，程序可以正常运行说明v为空</span></span><br><span class="line"><span class="built_in">assert</span>(v.<span class="built_in">empty</span>());</span><br></pre></td></tr></table></figure><h2 id="0x04-Forwarding-reference"><a href="#0x04-Forwarding-reference" class="headerlink" title="0x04 Forwarding reference"></a>0x04 Forwarding reference</h2><p>转发引用是一种特殊的引用，它保留了函数参数的值类别（左值和右值性质不变），从而可以通过 std::forward 进行转发给另一个函数或者类，实现完美转发。（该引用是左右不确定的）</p><p>例子1，模板函数参数声明为类模板参数的右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(T&amp;&amp; x)</span>                      <span class="comment">// x is a forwarding reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(std::forward&lt;T&gt;(x)); <span class="comment">// and so can be forwarded</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//根据引用的嵌套性质</span></span><br><span class="line">    <span class="built_in">f</span>(i); <span class="comment">// argument is lvalue, calls f&lt;int&amp;&gt;(int&amp;), std::forward&lt;int&amp;&gt;(x) is lvalue</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>); <span class="comment">// argument is rvalue, calls f&lt;int&gt;(int&amp;&amp;), std::forward&lt;int&gt;(x) is rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//const使得左值变右值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp;&amp; x)</span></span>; <span class="comment">// x is not a forwarding reference: const T is not cv-unqualified</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//要实现forwarding reference的话应该把这个模板声明写到下面</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">A</span><span class="params">(T&amp;&amp; x, U&amp;&amp; y, <span class="type">int</span>* p)</span></span>; <span class="comment">// x is not a forwarding reference: T is not a</span></span><br><span class="line">                             <span class="comment">// type template parameter of the constructor,</span></span><br><span class="line">                             <span class="comment">// but y is a forwarding reference</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例子2，auto&amp;&amp;能自动推导。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; vec = <span class="built_in">foo</span>();       <span class="comment">// foo() may be lvalue or rvalue, vec is a forwarding reference</span></span><br><span class="line"><span class="keyword">auto</span> i = std::<span class="built_in">begin</span>(vec); <span class="comment">// works either way</span></span><br><span class="line">(*i)++;                   <span class="comment">// works either way</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">g</span>(std::forward&lt;<span class="keyword">decltype</span>(vec)&gt;(vec)); <span class="comment">// forwards, preserving value category</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; x: <span class="built_in">f</span>())<span class="comment">//能自动推导f类型，从中取出x循环</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// x is a forwarding reference; this is a common way to use range for in generic code</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; z = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// *not* a forwarding reference (special case for initializer lists)初始化器列表的特殊情况</span></span><br></pre></td></tr></table></figure><h2 id="0x05-Dangling-references"><a href="#0x05-Dangling-references" class="headerlink" title="0x05 Dangling references"></a>0x05 Dangling references</h2><p>生命周期已经结束，但引用仍可以访问（悬挂）访问这样的引用是未定义的行为</p><p>If the referred-to object was destroyed (e.g. by explicit destructor call), but the storage was not deallocated, a reference to the out-of-lifetime object may be used in limited ways, and may become valid if the object is recreated in the same storage (see <a href="https://en.cppreference.com/w/cpp/language/lifetime#Access_outside_of_lifetime">Access outside of lifetime</a> for details).</p><p>如果被引用的对象已被销毁（例如通过显式析构函数调用），但存储空间未被清空，则对超出生命周期的对象的引用可以以有限的方式使用，如果在同一存储空间中重新创建该对象，则该引用可能有效（详见超出生命周期的访问）。（deepl翻译的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Example&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// exits the scope of s:</span></span><br><span class="line">              <span class="comment">// its destructor is called and its storage deallocated</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常都是没法访问到的，会报错</span></span><br><span class="line">std::string&amp; r = <span class="built_in">f</span>(); <span class="comment">// dangling reference（会出现警告）</span></span><br><span class="line">std::cout &lt;&lt; r;       <span class="comment">// undefined behavior: reads from a dangling reference</span></span><br><span class="line">std::string s = <span class="built_in">f</span>();  <span class="comment">// undefined behavior: copy-initializes from a dangling reference</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表达实验</title>
      <link href="/2024/03/09/csapp%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BE%BE%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/03/09/csapp%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BE%BE%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-实验前的环境部署和操作"><a href="#0x01-实验前的环境部署和操作" class="headerlink" title="0x01 实验前的环境部署和操作"></a>0x01 实验前的环境部署和操作</h2><h3 id="安装gcc-multilib插件"><a href="#安装gcc-multilib插件" class="headerlink" title="安装gcc-multilib插件"></a>安装gcc-multilib插件</h3><p>由于实验自带的检验和打分等程序是32位程序，而我的虚拟机是Ubuntu64位的，因此安装这个插件来兼容64位系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure><h3 id="实验步骤简述"><a href="#实验步骤简述" class="headerlink" title="实验步骤简述"></a>实验步骤简述</h3><p>我这里用vscode远程连接本地Ubuntu虚拟机，打开<code>datalab-handout</code>文件夹的<code>bits.c</code>文件，根据里面的要求补全函数。</p><p>（参考网站：<a href="https://blog.csdn.net/qq_29856169/article/details/115489702">vscode远程连接本地虚拟机</a>；<a href="https://blog.csdn.net/qq_27727147/article/details/104814170">出现无法连接的问题时</a>）</p><h3 id="实验结果检验"><a href="#实验结果检验" class="headerlink" title="实验结果检验"></a>实验结果检验</h3><p>在linux终端中输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make 编译</span><br><span class="line">./btest 测试</span><br></pre></td></tr></table></figure><h2 id="0x02-补全bits-c里的函数思路"><a href="#0x02-补全bits-c里的函数思路" class="headerlink" title="0x02 补全bits.c里的函数思路"></a>0x02 补全bits.c里的函数思路</h2><h3 id="01-bitXor"><a href="#01-bitXor" class="headerlink" title="01 bitXor"></a>01 bitXor</h3><p>根据异或公式，(~x &amp; y) | (x &amp; ~y)，由于这里不允许使用或|，于是使用摩根定律替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x &amp; y) &amp; ~(x &amp; ~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02-tmin"><a href="#02-tmin" class="headerlink" title="02 tmin"></a>02 tmin</h3><p>返回补码数的最小值，就是1开头后面全是0的数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03-isTmax"><a href="#03-isTmax" class="headerlink" title="03 isTmax"></a>03 isTmax</h3><p>检测是不是int补码数最大值，即0111后面全是1，我发现，只有-1和INT_MAX加1后再与本身异或运算，才有可能是位级表示下全1的数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0111 ^ 1000 = 1111 Or 1111 ^ 0000 = 1111</span><br></pre></td></tr></table></figure><p>全1的数很好判断，只有取反再测是不是0。这时候只要排除-1的情况就好了，只要x加1后非0，这个数就不是-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !!(x+<span class="number">1</span>) &amp; !(~((x+<span class="number">1</span>) ^ x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04-allOddBits"><a href="#04-allOddBits" class="headerlink" title="04 allOddBits"></a>04 allOddBits</h3><p>如果某个数所有的奇数位是1就返回1，比如0xAA：1010 1010</p><p>用0xAA AA AA AA取输入数x的掩码，然后再判断是否与0xAAAAAAAA相等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp = <span class="number">0xAA</span>;</span><br><span class="line">  temp |= temp &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  temp |= temp &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; temp) ^ temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="05-negate"><a href="#05-negate" class="headerlink" title="05 negate"></a>05 negate</h3><p>返回一个负数</p><p>按照补码运算性质马上就能得出答案，按位取反再加1（最大补码负数的取负还是本身）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (~x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06-isAsciiDigit"><a href="#06-isAsciiDigit" class="headerlink" title="06 isAsciiDigit"></a>06 isAsciiDigit</h3><p>如果是ASCII码下的数字符号就返回1，在0x30到0x39之间</p><p>先排除大于0xff的情况，与一个高24位全是1的掩码，之后除了0x3x，再判断低四位，有0xxx，和100x两种情况，分别讨论即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> test_number = (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  <span class="keyword">return</span> !(x &amp; test_number) &amp; (!((x &amp; <span class="number">0xf8</span>) ^ <span class="number">0x30</span>) | !((x &amp; <span class="number">0xfe</span>) ^ <span class="number">0x38</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="07-conditional"><a href="#07-conditional" class="headerlink" title="07 conditional"></a>07 conditional</h3><p><code>x ? y : z</code> 三元运算符，x为真取y，假取z</p><p>若x为真，根据x的值来生成一个全1的掩码，跟y与得到y本身；全1的非，即全0，跟z与得到0，最后两者再或运算</p><p>得到y，若x为假，同上理得到z。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> Bool = ((!!x) &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (Bool &amp; y) | (~Bool &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08-isLessOrEqual"><a href="#08-isLessOrEqual" class="headerlink" title="08 isLessOrEqual"></a>08 isLessOrEqual</h3><p>实现小于或等于号</p><p>判断y - x 是否大于或等于0，减法用加逆元来实现（实测发现虽然INT_MIN的逆元是本身，但是能正常运算）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> test_number = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !(((y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) &amp; test_number) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="09-logicalNeg"><a href="#09-logicalNeg" class="headerlink" title="09 logicalNeg"></a>09 logicalNeg</h3><p>不用 <code>!</code> 来实现 <code>!</code></p><p>0得到1，非0得到0</p><p>非0的数的逆元（否定）会翻转符号位，而0不会，于是非0数的否定与本身或运算得到符号位为1的数。</p><p>然后再算术右移，若非0则得到-1，为0则得到0，再加1就实现成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (((~x + <span class="number">1</span>) | x) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0A-howManyBits"><a href="#0A-howManyBits" class="headerlink" title="0A howManyBits"></a>0A howManyBits</h3><p>判断某个数，最少可以用多少位级表示，由于x和~x的位级所需位是一样的，所有负数都通过翻转成正数来处理（正数不变）。以下操作可以实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x &gt;&gt; <span class="number">31</span> ^ x;</span><br></pre></td></tr></table></figure><p>之后开始查找第一个1的位置，表示第一个1的位置所需的位级再加上1（符号位），就能返回正确答案。</p><p>查找位置的方法用二分查找，每次取中间位置，看看高位是否存在1，若存在再右移x来查找高位，否则不位移来查找低位，记录被右移掉的位数，最后要加到结果中。经过5轮的二分，就能查找到第一个1的确切位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  x = x &gt;&gt; <span class="number">31</span> ^ x;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1;</span><br><span class="line"></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  x = x &gt;&gt; (b16);</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0B-float-twice"><a href="#0B-float-twice" class="headerlink" title="0B float_twice"></a>0B float_twice</h3><p>把一个浮点数乘以2，返回对应的值。</p><p>NaN返回本身：<code>exp = 0xff,frac != 0</code></p><p>非规格化：<code>exp = 0, frac &lt;&lt;= 1</code>，与规格化的过渡是平滑的，直接frac左移一位即可</p><p>规格化乘以2后溢出：<code>&#123;exp = 0xff，frac = 0&#125; Or &#123;exp = 0xff-1&#125;</code>，return ∞（返回无穷）</p><p>规格化未溢出：<code>exp += 1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">float_twice</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf ^ sign) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">exp</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | sign;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!(<span class="built_in">exp</span> ^ <span class="number">0xff</span>) &amp;&amp; frac)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((!(<span class="built_in">exp</span> ^ <span class="number">0xff</span>) &amp;&amp; !frac) || !(<span class="built_in">exp</span> ^ <span class="number">0xfe</span>))&#123;</span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> sign | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (uf ^ (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>)) | (<span class="built_in">exp</span> + <span class="number">1</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0C-float-i2f"><a href="#0C-float-i2f" class="headerlink" title="0C float_i2f"></a>0C float_i2f</h3><p>（偶数舍入方法：先加上舍弃位的半值，利用四舍五入，小于半值的加上半值也不会进位，移位后自然舍弃，大于半值的加上半值会产生进位，完全符合我们的需求。对于刚好半值，加上半值会进位，但是它比较特殊，加完后舍弃的值是全0，如果最低有效位是1，说明原来是0，不该进位，所以再减1去掉进位。）</p><p>（这个有点难，我最后参考了网上的做法）</p><p>先把int正数取正（无符号），再算出uf的位数，把其转化为frac表示，然后记录exp，最后合并。</p><p>然后后九位要根据向偶数舍入来舍入（如果int部分超过24）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">float_i2f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> uf, <span class="built_in">exp</span>;</span><br><span class="line">  <span class="type">unsigned</span> sign = x &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  <span class="type">unsigned</span> i = <span class="number">30</span>, t;<span class="comment">//i存储的是最高位的向量下标</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">    uf = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">0x80000000</span>)&#123;</span><br><span class="line">    uf = <span class="number">0xcf000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sign)&#123;</span><br><span class="line">      uf = ~x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      uf = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!(uf &amp; (<span class="number">1</span> &lt;&lt; i)))&#123;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    uf = uf - (<span class="number">1</span> &lt;&lt; i);<span class="comment">//去掉最高位的1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">24</span>)&#123;<span class="comment">//如果不大于24位，不需要舍入操作</span></span><br><span class="line">      uf = uf &lt;&lt; (<span class="number">23</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      t = i - <span class="number">23</span>;</span><br><span class="line">      uf += (<span class="number">1</span> &lt;&lt; (t - <span class="number">1</span>));   <span class="comment">//加即将丢弃的值的一半，四舍五入</span></span><br><span class="line">      <span class="keyword">if</span>(uf &amp; ((<span class="number">1</span> &lt;&lt; (t + <span class="number">1</span>)) - <span class="number">1</span>))&#123;   <span class="comment">//判断奇偶，如果是1后跟着0，说明不该进位。</span></span><br><span class="line">        uf -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      uf = uf &gt;&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exp</span> = (<span class="number">127</span> + i) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">    <span class="comment">//这里用加法而不是或运算是可能因为尾数舍入进位</span></span><br><span class="line">    uf += <span class="built_in">exp</span> | sign;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0D-float-f2i"><a href="#0D-float-f2i" class="headerlink" title="0D float_f2i"></a>0D float_f2i</h3><p>应该是默认向0舍入。</p><p>当float数小于1时，直接返回0</p><p>当float数大于1，但不溢出int所能表示的范围时（exp 在127到157之间）</p><p>先补全小数点前的1，再根据E = exp -1 调整阶数。</p><p>当float超过int所能表示的范围，或者是NaN时，按照题意返回 0x8000 0000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_f2i - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">float_f2i</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf ^ sign) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">  <span class="type">unsigned</span> E;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span> || (<span class="built_in">exp</span> &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">exp</span> &lt;= <span class="number">126</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">127</span> &amp;&amp; <span class="built_in">exp</span> &lt;= <span class="number">157</span>)&#123;</span><br><span class="line">    E = <span class="built_in">exp</span> - <span class="number">127</span>;</span><br><span class="line">    frac |= <span class="number">0x800000</span>;</span><br><span class="line">    <span class="keyword">if</span>(E &lt;= <span class="number">23</span>)&#123;</span><br><span class="line">      frac &gt;&gt;= (<span class="number">23</span> - E);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(E &gt; <span class="number">23</span>)&#123;</span><br><span class="line">      frac &lt;&lt;= (E - <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">158</span> &amp;&amp; <span class="built_in">exp</span> &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sign)&#123;</span><br><span class="line">    <span class="keyword">return</span> ~frac + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> cum15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cum15-213程序bomb破解</title>
      <link href="/2024/03/09/cum%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%BA%8Fbomb%E9%80%86%E5%90%91/"/>
      <url>/2024/03/09/cum%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%BA%8Fbomb%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>最近在学习csapp时，发现第三章作业是一个程序叫bomb，要求破解六个步骤拆除炸弹。bomb是一个elf文件，我们用ida64分析，然后打开kali虚拟机远程调试，准备工作就做好了。</p><h2 id="0x02-前五个部分"><a href="#0x02-前五个部分" class="headerlink" title="0x02 前五个部分"></a>0x02 前五个部分</h2><p>炸弹的前五个部分十分简单。第一部分就是比较一个输入的字符串，而这个字符点开加密函数phase_1就可以找到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><p>第二部分是输入6个数字，然后数字前后直接要满足后面一个是前面一个两倍的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">phase_2</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+4h] [rbp-34h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+18h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read_six_numbers(a1, &amp;v3);</span><br><span class="line">  <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">    explode_bomb(a1, &amp;v3);</span><br><span class="line">  v2 = &amp;v4;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="number">2</span> * *(v2 - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> ( *v2 != result )</span><br><span class="line">      explode_bomb(a1, &amp;v3);</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v2 != &amp;v5 );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入首项为1，公比为2的等比数列前六项即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure><p>第三部分是输入两个数字，然后第一个数字作为switch的索引来查找一个数字，再把这个数字和输入的第二个数字比较，相同即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">phase_3</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( __isoc99_sscanf(a1, <span class="string">&quot;%d %d&quot;</span>, &amp;v4, &amp;v5) &lt;= <span class="number">1</span> )</span><br><span class="line">    explode_bomb(a1, <span class="string">&quot;%d %d&quot;</span>, v1, v2);</span><br><span class="line">  <span class="keyword">switch</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      result = <span class="number">207LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      result = <span class="number">311LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      result = <span class="number">707LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      result = <span class="number">256LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      result = <span class="number">389LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      result = <span class="number">206LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      result = <span class="number">682LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      result = <span class="number">327LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      explode_bomb(a1, <span class="string">&quot;%d %d&quot;</span>, v1, v2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( result != v5 )</span><br><span class="line">    explode_bomb(a1, <span class="string">&quot;%d %d&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里随便找一个组合输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 327</span><br></pre></td></tr></table></figure><p>第四部分是一个二分查找的递归函数，满足的条件是return 0，这里发现只要a1小于一次中值v3，result就会被赋值0，之后递归回溯时就会把result=0返回出去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加密函数</span></span><br><span class="line">__int64 __fastcall <span class="title function_">phase_4</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdi</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+8h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( __isoc99_sscanf(a1, <span class="string">&quot;%d %d&quot;</span>, &amp;v3, &amp;v4) != <span class="number">2</span> || v3 &gt; <span class="number">0xE</span> )</span><br><span class="line">    explode_bomb(a1, <span class="string">&quot;%d %d&quot;</span>);</span><br><span class="line">  v1 = v3;</span><br><span class="line">  result = func4(v3, <span class="number">0LL</span>, <span class="number">14LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result || v4 )</span><br><span class="line">    explode_bomb(v1, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归函数</span></span><br><span class="line">__int64 __fastcall <span class="title function_">func4</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">    <span class="comment">//a2初始是0，a3初始是14</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = (a3 - a2) / <span class="number">2</span> + a2;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * func4(a1, a2, (v3 - <span class="number">1</span>));</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * func4(a1, (v3 + <span class="number">1</span>), a3) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要输入两个值，第一个值v4必为0，第二个值v3我为了保险起见，输入了一个0，让上述二分查找里a1，也就是v3传进去的值能一直小于中值，然后result赋值为0接着返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0</span><br></pre></td></tr></table></figure><p>第五部分是个查找表的加密，输入长度为6的字符串，然后取每个字符的二进制前四位掩码，作为数组array_3449的下标，依次和字符串flyers比较。这里通过找表发现下标顺序是9 F E 5 6 7，只要依次输入低四位是这些数字的字符就好了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">phase_5</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 i; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( string_length() != <span class="number">6</span> )</span><br><span class="line">    explode_bomb(a1, a2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">6</span>; ++i )</span><br><span class="line">    v4[i] = array_3449[*(a1 + i) &amp; <span class="number">0xF</span>];</span><br><span class="line">  v4[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( strings_not_equal(v4, <span class="string">&quot;flyers&quot;</span>) )</span><br><span class="line">    explode_bomb(v4, <span class="string">&quot;flyers&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组array_3449（索引表）</span></span><br><span class="line">.rodata:<span class="number">00000000004024B</span>0                               ; <span class="type">char</span> array_3449[<span class="number">16</span>]</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>0 <span class="number">6</span>D                            array_3449 db <span class="number">6</span>Dh                       ; DATA XREF: phase_5+<span class="number">37</span>↑r</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>1 <span class="number">61</span>                            db  <span class="number">61</span>h ; a</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>2 <span class="number">64</span>                            db  <span class="number">64</span>h ; d</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>3 <span class="number">75</span>                            db  <span class="number">75</span>h ; u</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>4 <span class="number">69</span>                            db  <span class="number">69</span>h ; i</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>5 <span class="number">65</span>                            db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>6 <span class="number">72</span>                            db  <span class="number">72</span>h ; r</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>7 <span class="number">73</span>                            db  <span class="number">73</span>h ; s</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>8 <span class="number">6</span>E                            db  <span class="number">6</span>Eh ; n</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>9 <span class="number">66</span>                            db  <span class="number">66</span>h ; f</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>A <span class="number">6F</span>                            db  <span class="number">6F</span>h ; o</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>B <span class="number">74</span>                            db  <span class="number">74</span>h ; t</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>C <span class="number">76</span>                            db  <span class="number">76</span>h ; v</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>D <span class="number">62</span>                            db  <span class="number">62</span>h ; b</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>E <span class="number">79</span>                            db  <span class="number">79</span>h ; y</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>F <span class="number">6</span>C                            db  <span class="number">6</span>Ch ; l</span><br></pre></td></tr></table></figure><p>我这里输入 69  6F 6E 65 66 67</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ionefg</span><br></pre></td></tr></table></figure><h2 id="0x03-最后一部分"><a href="#0x03-最后一部分" class="headerlink" title="0x03 最后一部分"></a>0x03 最后一部分</h2><p>最后一部分调了我一个傍晚，发现是个链表加密</p><p><img src="/Images/image-20240309192021180.png" alt="image-20240309192021180" style="zoom: 67%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">phase_6</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *v1; <span class="comment">// r13</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r12d</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD *v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v9; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 j; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// ebp</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> num[<span class="number">6</span>]; <span class="comment">// [rsp+0h] [rbp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v16; <span class="comment">// [rsp+18h] [rbp-60h] BYREF</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+20h] [rbp-58h]</span></span><br><span class="line">  <span class="type">char</span> v18; <span class="comment">// [rsp+28h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v19[<span class="number">40</span>]; <span class="comment">// [rsp+50h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v1 = num;</span><br><span class="line">  read_six_numbers(a1, num);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (*v1 - <span class="number">1</span>) &gt; <span class="number">5</span> )                        <span class="comment">// 第一个大于6</span></span><br><span class="line">      explode_bomb(a1, num);</span><br><span class="line">    <span class="keyword">if</span> ( ++v2 == <span class="number">6</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = v2;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v1 == num[v3] )                     <span class="comment">// 如果第一个和最后一个相等</span></span><br><span class="line">        explode_bomb(a1, num);</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 &lt;= <span class="number">5</span> );                          <span class="comment">// v3=6</span></span><br><span class="line">    ++v1;</span><br><span class="line">  &#125;                                             <span class="comment">// 检查6个数字是否互不相等</span></span><br><span class="line">  v4 = num;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    *v4 = <span class="number">7</span> - *v4;</span><br><span class="line">    v4 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v4 != &amp;v16 );                         <span class="comment">// 7-输入数字</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">24</span>; i += <span class="number">4LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = num[i / <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = &amp;node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v7 = <span class="number">1</span>;</span><br><span class="line">      v6 = &amp;node1;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = v6[<span class="number">1</span>];</span><br><span class="line">        ++v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v7 != v8 );</span><br><span class="line">    &#125;</span><br><span class="line">    *(&amp;v17 + <span class="number">2</span> * i) = v6;                       <span class="comment">// v17是各节点地址数组，循序是输入的1到6的顺序</span></span><br><span class="line">  &#125;</span><br><span class="line">  v9 = v17;                                     <span class="comment">// 第一个</span></span><br><span class="line">  v10 = &amp;v18;                                   <span class="comment">// 第二个</span></span><br><span class="line">  <span class="keyword">for</span> ( j = v17; ; j = v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = *v10;                                 <span class="comment">// 第二个的值</span></span><br><span class="line">    *(j + <span class="number">8</span>) = *v10;</span><br><span class="line">    v10 += <span class="number">8</span>;                                   <span class="comment">// 第三个</span></span><br><span class="line">    <span class="keyword">if</span> ( v10 == v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(v12 + <span class="number">8</span>) = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = **(v9 + <span class="number">8</span>);                        <span class="comment">// result的值是该节点指向的节点的值</span></span><br><span class="line">    <span class="keyword">if</span> ( *v9 &lt; result )</span><br><span class="line">      explode_bomb(a1, v19);</span><br><span class="line">    v9 = *(v9 + <span class="number">8</span>);                             <span class="comment">// 设置为下一个节点</span></span><br><span class="line">    --v13;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v13 );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这坨式主要的逻辑就是，输入1到6的数字，然后取关于3.5的对称数，接着根据1到6的代表节点1到6，来重置链表的顺序，最后进行一个某节点与下一个节点的比较，若小于则程序退出，于是我们就要使得链表的顺序重置为从大到小排列。（其实是非常简单的逻辑，第一次见链表式存储的逆向给我卡了，调试后才发现）</p><p>根据逆向原理，我们得先找到排序然后再取数的对称。找到6个节点各自的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1    2  3    4    5    6</span><br><span class="line">014c a8 039c 02b3 01dd 01bb</span><br><span class="line">//排序</span><br><span class="line">3 4 6 5 2 1</span><br><span class="line">//取对称</span><br><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><p>这样就把炸弹拆除了。</p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>其实这个程序，我感觉作者的本意应该是让我们在机器语言或者汇编语言层面调试分析，奈何ida工具太强大了。</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
            <tag> cum15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Ubuntu虚拟机</title>
      <link href="/2024/03/05/%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>/2024/03/05/%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-创建虚拟机"><a href="#0x01-创建虚拟机" class="headerlink" title="0x01 创建虚拟机"></a>0x01 创建虚拟机</h2><p>先在VMware创建一个虚拟机容器，直接点击”创建新的虚拟机“就好了。</p><p><img src="/Images/image-20240305203001550.png" alt="image-20240305203001550" style="zoom: 67%;" /></p><p>点击稍后安装操作系统，到时候去Ubuntu官网下载一个映像文件。</p><p><img src="/Images/image-20240305203050232.png" alt="image-20240305203050232" style="zoom:67%;" /></p><p>选择Ubuntu 64位，操作系统当然是Linux。</p><p>之后的虚拟机名称，默认就好了，无所谓，位置放到一个容易管理的文件夹里。</p><p><img src="/Images/image-20240305203217149.png" alt="image-20240305203217149" style="zoom:67%;" /></p><p>选择将虚拟磁盘储存为单个文件，最大磁盘大小并不会一开始就占用你20GB内存，而是动态扩展的，有大容量需求的话可以多分配一点，对我来说20GB绰绰有余了。</p><p>之后点击完成，虚拟机就创建好了。</p><h2 id="0x02-安装Ubuntu"><a href="#0x02-安装Ubuntu" class="headerlink" title="0x02 安装Ubuntu"></a>0x02 安装Ubuntu</h2><p>去Ubuntu的官网下载Linux系统映像文件（<a href="https://ubuntu.com/download/desktop">传送门</a>）</p><p><img src="/Images/image-20240305203502313.png" alt="image-20240305203502313" style="zoom:67%;" /></p><p>我安装了这个23.10版本，是去年10月份的最新版本。</p><p>大概有4GB左右，安装得有点慢。</p><p>安装好后将他放在随便一个文件夹里，最好是能找得到的，我创建了一个software文件夹来存放它。</p><p>再次打开Vmware，选择我们之前创建的虚拟机，点击编辑此虚拟机，</p><p><img src="/Images/image-20240305203757046.png" alt="image-20240305203757046" style="zoom:50%;" /></p><p>这里可以调整内存大小，我们先不管，点击CD/DVD，选择使用ISO映像文件，预览我们之前下载好的映像文件。</p><p>选择好之后就可以启动虚拟机了。</p><p>第一次启动会配置一些东西，一直下一步就行了。选择语言界面的我还是建议选择英语，方便之后命令的书写，我不小心点到Chinese了现在很痛苦。还有的就是填写用户名，密码和计算机名称这里，尽量把密码设置简单一点，之后在命令行安装文件一直都要输入密码，太长的密码搞人心态；还有就是计算机名称也填一个好记的名称，之后remote连接可能要用到，用户名就无所谓了，随便输入。</p><p>配置完后会重启虚拟机，然后等待安装配置就好了。</p><h2 id="0x03-VMware-Tools安装"><a href="#0x03-VMware-Tools安装" class="headerlink" title="0x03 VMware Tools安装"></a>0x03 VMware Tools安装</h2><p>这个工具能帮助我们把电脑里的文件和命令直接的东西复制到虚拟机里，非常实用，建议安装。</p><p>Vmware tools在Vm里有个安装的操作提示，如果你已经按照它的步骤并且安装成功了，那这部分你就不用看了。如果你安装成功后却无法将电脑里的文件拖拽进虚拟机（例如把桌面的照片拖拽到虚拟机），那么请你看看下面的解决方法（我也是用这个方法才解决的）</p><h3 id="卸载Vmware-Tools"><a href="#卸载Vmware-Tools" class="headerlink" title="卸载Vmware Tools"></a>卸载Vmware Tools</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove open-vm-tools</span><br></pre></td></tr></table></figure><h3 id="联网安装VMware-tools"><a href="#联网安装VMware-tools" class="headerlink" title="联网安装VMware tools"></a>联网安装VMware tools</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools-desktop</span><br><span class="line">如果安装错误请以此输入下面两条命令</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install open-vm-tools-desktop fuse</span><br></pre></td></tr></table></figure><h3 id="重启虚拟机"><a href="#重启虚拟机" class="headerlink" title="重启虚拟机"></a>重启虚拟机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p><img src="/Images/image-20240305204931600.png" alt="image-20240305204931600" style="zoom: 50%;" /></p><p>如此，我成功把一张照片复制到了桌面文件夹里。</p><h2 id="0x04-Linux终端命令"><a href="#0x04-Linux终端命令" class="headerlink" title="0x04 Linux终端命令"></a>0x04 Linux终端命令</h2><p>一些基本的cd，ls常用的先看看就好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论算法</title>
      <link href="/2024/03/01/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <url>/2024/03/01/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Dijkstra算法（寻找有权图最短路径）"><a href="#0x01-Dijkstra算法（寻找有权图最短路径）" class="headerlink" title="0x01 Dijkstra算法（寻找有权图最短路径）"></a>0x01 Dijkstra算法（寻找有权图最短路径）</h2><p>看视频的讲解实现的，P4（<a href="https://www.bilibili.com/video/BV1hc41187JZ?p=4&amp;vd_source=bdd8551641c485c305190c0dc5e3875e">视频地址</a>）</p><p>这里默认源点是1，之后再改改自定义源点的，</p><p>这个算法的大致思路是，从一个源点开始，把他压入优先队列（小的先出），然后给存储最短路径的dis数组全部初始化无穷大，接着就可以开始循环了。只要队列不为空，我们就一直取队列里的元素，然后判断由这个节点到下个节点的路径是不是最小的，如果是就把下个节点压入队列，若不是就不压入。每个节点到源点的最短路径是递归而来的。</p><p><img src="/Images/image-20240227213034851.png" alt="image-20240227213034851"></p><p>算法就是一直在完善这个表。由于有优先队列存在，省去了无意义的路线判断，很大程度上一次就可以寻得最短路径，因为是从小权重的边开始寻路的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> m,n;<span class="comment">//m是边权方向设定数，n是顶点数</span></span><br><span class="line"><span class="type">int</span> x,y,w,temp_n,temp_w;<span class="comment">//顶点坐标xy，边权数w</span></span><br><span class="line"><span class="type">int</span> mat[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">info</span>(<span class="type">int</span> node, <span class="type">int</span> weight)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;node = node;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> info &amp;info1, <span class="type">const</span> info &amp;info2)&#123;</span><br><span class="line">            <span class="keyword">return</span> info1.weight &gt; info2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> node;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;info&gt; q;</span><br><span class="line"><span class="comment">//求从源点1到各个顶点的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化操作，dis初始化</span></span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">1</span>,dis[<span class="number">1</span>]);<span class="comment">//源点进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp_n = q.<span class="built_in">top</span>().node, temp_w = q.<span class="built_in">top</span>().weight;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(mat[temp_n][i] != INF &amp;&amp; temp_n != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp_w + mat[temp_n][i] &lt; dis[i])&#123;</span><br><span class="line">                    dis[i] = temp_w + mat[temp_n][i];</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i,dis[i]);</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mat[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        mat[x][y] = w;<span class="comment">//由x指向y，边权为w</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-Prim算法（寻找最小生成树）"><a href="#0x03-Prim算法（寻找最小生成树）" class="headerlink" title="0x03 Prim算法（寻找最小生成树）"></a>0x03 Prim算法（寻找最小生成树）</h2><p>首先记录一下什么是生成树，生成树是在一个连通的，无回环的无向图中，寻找能构成树的节点和边。</p><p>n个节点的图中，生成树必须是n个节点，n-1条边的。</p><p>最小生成树就是生成树中边权重之和最小的数。</p><p>最小生成树简单的应用在于修路问题，在原有的道路的基础上，铺设新的道路，最省钱，又能全部连通，这时候就要用到最小生成树了。</p><p>先记录一下Prim算法，算法的大致思路就是从一个源点开始，将他标记为树的节点，然后从树与剩余图连接的边中选择权重最小的边，将与该边连接的节点也纳入树中，以此类推，知道全部节点都成为树的一部分。</p><p><img src="/Images/image-20240227213926642.png" alt="image-20240227213926642"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> m,n;<span class="comment">//m是边权方向设定数，n是顶点数</span></span><br><span class="line"><span class="type">int</span> x,y,w,ans = <span class="number">0</span>,temp_w,temp_n;<span class="comment">//顶点坐标xy，边权数w</span></span><br><span class="line"><span class="comment">//temp_w暂时存储边权，temp_n暂时存储节点</span></span><br><span class="line"><span class="type">int</span> mat[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100</span>];<span class="comment">//存储某个节点到树的距离</span></span><br><span class="line"><span class="type">bool</span> book[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    book[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">//初始化dis</span></span><br><span class="line">        dis[i] = <span class="built_in">min</span>(dis[i], mat[<span class="number">1</span>][i]);<span class="comment">//只有结点1的数，初始化设定到1的距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        temp_w = INF, temp_n = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book[j] &amp;&amp; dis[j] &lt; temp_w)&#123;</span><br><span class="line">                <span class="comment">//找到离树边权最小的节点</span></span><br><span class="line">                temp_n = j, temp_w = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp_n == <span class="number">-1</span>)&#123;<span class="comment">//若为-1，代表找不到节点，无法构成树</span></span><br><span class="line">            ans = INF;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        book[temp_n] = <span class="literal">true</span>;<span class="comment">//找到后把节点纳入树中</span></span><br><span class="line">        ans += temp_w;<span class="comment">//计算边权和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;<span class="comment">//更新节点离树的边权，未被访问到的节点dis为INF</span></span><br><span class="line">            dis[j] = <span class="built_in">min</span>(dis[j], mat[temp_n][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mat[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[i] = INF;<span class="comment">//给dis全设置为正无穷</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        mat[x][y] = mat[y][x] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Prim</span>(n);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-Kruskal算法（寻找最小生成树）"><a href="#0x04-Kruskal算法（寻找最小生成树）" class="headerlink" title="0x04 Kruskal算法（寻找最小生成树）"></a>0x04 Kruskal算法（寻找最小生成树）</h2><p>Kruskal算法的和Prim算法的区别在于，他的核心点在于边和森林。一开始把图看成一个森林，然后选取边权最小的边事先合并，逐渐把森林连接成树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edge</span>&#123;<span class="comment">//边类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">edge</span>(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;w = w, <span class="keyword">this</span>-&gt;x = x, <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x,y,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge &amp;p1, edge &amp;p2)</span></span>&#123;<span class="comment">//sort判断函数重载</span></span><br><span class="line">    <span class="keyword">if</span>(p1.w &lt; p2.w)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, x, y, w, ans=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line">vector&lt;edge&gt; T;<span class="comment">//边容器T</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree;<span class="comment">//下标代表节点，值代表树</span></span><br><span class="line"><span class="comment">//比如tree[1] = 1, tree[2] = 1,说明节点1和节点2在同一颗树内，初始每个节点在不同树内</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(T.<span class="built_in">begin</span>(),T.<span class="built_in">end</span>(),cmp);<span class="comment">//根据边权排序，从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//tree初始化</span></span><br><span class="line">        tree.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//遍历m条边</span></span><br><span class="line">        <span class="keyword">if</span>(tree[T[i].x] != tree[T[i].y])&#123;<span class="comment">//若不在同一树内</span></span><br><span class="line">            ans += T[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//遍历节点修改节点所属的树</span></span><br><span class="line">                <span class="keyword">if</span>(tree[j] == tree[T[i].y])&#123;</span><br><span class="line">                    tree[j] = tree[T[i].x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != n<span class="number">-1</span>)&#123;<span class="comment">//如果构不成树</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//由于这个算法主要是分析边的，这里就不读取mat了</span></span><br><span class="line">    T.<span class="built_in">emplace_back</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//占0下标，方便从1开始循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//读取图的边</span></span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        T.<span class="built_in">emplace_back</span>(x,y,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>(n);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集优化"><a href="#并查集优化" class="headerlink" title="并查集优化"></a>并查集优化</h3><p>写完这个算法后，询问了一下大佬的意见，连接树这一部分可以用并查集算法优化。</p><p>同样设置一个tree数组，tree下标代表节点，这时候值则代表节点的双亲节点（parents[ ]）。</p><p>例如 tree[1] = 2，说明节点1往上查找是节点2。当数组值等于数组下标时，说明该节点是其所属树的根结点，因为无法再溯源了，很好理解（自己的双亲节点是自己，就是没有了）。</p><p>这时候查找一个节点的所属树时，只要找到他的根结点，跟另一个节点的根节点比较，若相同则说明两者有同一祖宗，不相等则不是，这时候把其中任意根结点的值改成另一根结点的值，使得两者有共同祖宗，就所属同一棵树了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != parents[x])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(parents[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法中，若该节点x不是根结点，继续回溯，判断x的双亲节点是不是根结点，直到找到后返回根结点。</p><p>虽然这个算法满足了回溯找祖宗的功能，但没有在过去的查找中逐渐优化树，让下一次的查找无需多次return。</p><p>如果能在每次查找中优化树结构，让本来由1 -&gt; 2 -&gt; 3 的树，变成1 -&gt; 3 ，2 -&gt; 3，的少层多孩子的树，能大大减少查找的时间，使得1无需经过两次回溯才能找到根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != parents[x])&#123;</span><br><span class="line">        parents[x] = <span class="built_in">find</span>(parents[x]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> parents[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次查找失败后，将双亲节点的值赋值为祖宗节点。</p><p>这里顺便把sort排序用于判断的小于号重载并用友元全局函数封装进edge类内，让整体感更强。</p><p>优化后的算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edge</span>&#123;<span class="comment">//边类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">edge</span>(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;w = w, <span class="keyword">this</span>-&gt;x = x, <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;edge1,<span class="type">const</span> edge &amp;edge2)&#123;<span class="comment">//重载小于号，方便sort排序</span></span><br><span class="line">            <span class="keyword">return</span> edge1.w &lt; edge2.w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x,y,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n, m, x, y, w, ans=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line">vector&lt;edge&gt; T;<span class="comment">//边容器T</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; parents;<span class="comment">//下标代表节点，值代表双亲节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != parents[x])&#123;</span><br><span class="line">        parents[x] = <span class="built_in">find</span>(parents[x]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> parents[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(T.<span class="built_in">begin</span>(),T.<span class="built_in">end</span>());<span class="comment">//根据边权排序，从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//tree初始化</span></span><br><span class="line">        parents.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//遍历m条边</span></span><br><span class="line">        x = <span class="built_in">find</span>(T[i].x), y = <span class="built_in">find</span>(T[i].y);</span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;<span class="comment">//若不在同一树内</span></span><br><span class="line">            parents[x] = y;</span><br><span class="line">            ans += T[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != n<span class="number">-1</span>)&#123;<span class="comment">//如果构不成树</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//由于这个算法主要是分析边的，这里就不读取mat了</span></span><br><span class="line">    T.<span class="built_in">emplace_back</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//占0下标，方便从1开始循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//读取图的边</span></span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        T.<span class="built_in">emplace_back</span>(x,y,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>(n);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-网络流问题Nework-Flow"><a href="#0x05-网络流问题Nework-Flow" class="headerlink" title="0x05 网络流问题Nework Flow"></a>0x05 网络流问题Nework Flow</h2><p><img src="/Images/image-20240229123902886.png" alt="image-20240229123902886" style="zoom: 50%;" /></p><p>如图就是一个经典网络流问题，从起点S出发，流量不超过最大容量（边权），最多能有多少流量到终点T。</p><p>这里先介绍一种基础的计算网络流的办法，这种办法算出来不一定正确。</p><p>先找到一条从S到T的简单路径，然后各种短板效应找到通过该路径的最大流量，接着用容量减去流量计算出空闲量，更新上面的空闲量图</p><p><img src="/Images/image-20240229124820753.png" alt="image-20240229124820753" style="zoom:50%;" /></p><p>更新后如图，继续寻找从S到T的简单路径，直到找不到从S到T的路径。</p><p>这个算法当选择路径的顺序正确时，能够计算出最大流量，但多数时候路径的选择顺序是不固定的，选择的不是最优解也无法回头再来。</p><h2 id="0x06-Ford-Fulkerson算法"><a href="#0x06-Ford-Fulkerson算法" class="headerlink" title="0x06 Ford-Fulkerson算法"></a>0x06 Ford-Fulkerson算法</h2><p>这个算法一定能找到最大流，介绍一下大致思想，为下一个E-K算法做铺垫。</p><p>先创建一个residual graph，然后开始循环找从起点到终点的简单路径，和上节介绍的方法一样，但是在每次更新得到residual graph后，在原先的Flow上添加一条方向路径（如图绿色）</p><p><img src="/Images/image-20240229130256745.png" alt="image-20240229130256745" style="zoom:50%;" /></p><p>这条反向路径的在之后寻找从起点到终点的简单路径时是可以选择的，他的存在使得Flow的选择能够反悔，例如图中从S到T流向了三份水后，添加的反向路径使得水能够动态的从T流回S，之后若选择的路径通过的Flow不好，也可以通过反向路径流动水，一来一回相当于水没流动，修改路径上水的Flow。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>但是F-F算法选择路径的方式是随机的，最坏的情况下时间复杂度为O(f*m)（f是最大流量，m是边的数量）</p><p>O(m)用来寻找从起点到终点的路径，O(f)则是最坏情况下的循环找路径次数。</p><h2 id="0x07-Edmonds-Karp算法（F-F算法特例）"><a href="#0x07-Edmonds-Karp算法（F-F算法特例）" class="headerlink" title="0x07 Edmonds-Karp算法（F-F算法特例）"></a>0x07 Edmonds-Karp算法（F-F算法特例）</h2><p>基于F-F算法，E-K算法在寻找路径时添加了一条规则，优先选择最短路径（把图看成有向无权图）</p><p>最坏情况下时间复杂度为O(m <em> m </em> n)，时间复杂度与最大流无关（m是边的数量，n是节点数）</p><h3 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h3><p>先写一个无权图的最短路径BFS算法，根据这个算法，遍历每个节点，记录到源点的最短路径，节点的前驱节点，并且在计算的过程中，更新当前路径的最大容量。思路是先设置一个info节点类，维护节点编号、最短路径和前驱节点，然后设置一个mat图二维数组，存储residual图（初始是有向容量图），维护着图的各种路径，方向路径等。（邻接矩阵法）</p><p>先贴个网址，以后再补：<a href="https://blog.csdn.net/qq_45361883/article/details/106860975">最大流问题——Ford Fulkerson算法_fordfulkerson算法求最大流-CSDN博客</a></p><p><a href="https://www.cnblogs.com/Icys/p/15122777.html">                                          三种网络流（最大流）的实现算法讲解与代码 - Icys - 博客园 (cnblogs.com)</a></p><p>完结撒花，已经补全了，真是道阻且长！！</p><p>这里用的是新的链式前向星存储图的思路，重点在于找到最短路径并计算最大Flow这个操作，该算法巧妙的用一个数组last存储指向某个节点的边的编号，再通过反向路径编号=正向路径编号+1的存取方式，将正反向路径的to（指向的节点编号）联动起来，成功实现溯源，遍历路径节点的同时修改边权（边的容量剩余量）的操作，我觉得很妙，思路主要来源于第二篇文章。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> to,<span class="type">int</span> w,<span class="type">int</span> next)&#123;</span><br><span class="line">            <span class="comment">//Next，表示与这个边起点相同的上一条边的编号</span></span><br><span class="line">            <span class="comment">//to，表示边指向的节点，w是边权（容量）</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;next = next, <span class="keyword">this</span>-&gt;to = to, <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> to,w,next;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>,head[<span class="number">100</span>];<span class="comment">//初始化-1</span></span><br><span class="line"><span class="type">int</span> n,m,x,y,w,s,t,INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> last[<span class="number">100</span>],flow[<span class="number">100</span>];<span class="comment">//last记录从S到T的完整路径，flow记录到该节点的流量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;<span class="comment">//u起点，v终点，w边权</span></span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点最后一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    <span class="comment">//这时候edge[cnt]变成以u起点的最后一条边，存储进head，然后cnt++</span></span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;<span class="comment">//初始化head，m代表边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> n)</span></span>&#123;<span class="comment">//搜索从s到t的最短路径，找出最小容量，并生成一个last数组供查询</span></span><br><span class="line">    <span class="type">int</span> temp_n,dis[<span class="number">100</span>];<span class="comment">//dis用来寻找最短路径</span></span><br><span class="line">    <span class="type">bool</span> vis[<span class="number">100</span>] = &#123;<span class="literal">false</span>&#125;;<span class="comment">//各点访问情况</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = INF;<span class="comment">//初始化INF</span></span><br><span class="line">        last[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    flow[s] = INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp_n = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(temp_n == t)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//找到终点t了，直接break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[temp_n];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[i].to] &amp;&amp; edge[i].w&gt;<span class="number">0</span>)&#123;<span class="comment">//节点未有水流过，且到达节点的边的容量不为0</span></span><br><span class="line">                dis[edge[i].to] = dis[temp_n] + <span class="number">1</span>;<span class="comment">//更新未访问过的点的路径（这里用不到，找最短路径用）</span></span><br><span class="line">                last[edge[i].to] = i;<span class="comment">//到edge[i].to这个点要走边i</span></span><br><span class="line">                flow[edge[i].to] = <span class="built_in">min</span>(flow[temp_n],edge[i].w);<span class="comment">//记录当前节点的水量</span></span><br><span class="line">                vis[edge[i].to] = <span class="literal">true</span>;<span class="comment">//表示访问过</span></span><br><span class="line">                q.<span class="built_in">push</span>(edge[i].to);<span class="comment">//入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last[t]!=<span class="number">-1</span>;<span class="comment">//找到s到t的路径就返回true</span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_flow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(s,t,n))&#123;</span><br><span class="line">        maxflow += flow[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t;i!=s;i = edge[last[i]+<span class="number">1</span>].to)&#123;<span class="comment">//这个last[i]得到路径里指向i的边的编号，然后编号+1得到反向边，</span></span><br><span class="line">        <span class="comment">//接着取这条边的to，就是找到指向结点i的边的起点，这样一步步反向回溯路径直到起点s</span></span><br><span class="line">            edge[last[i]].w -= flow[t];<span class="comment">//减去流量得到边的容量剩余量</span></span><br><span class="line">            edge[last[i]+<span class="number">1</span>].w += flow[t];<span class="comment">//添加反向路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    edge.<span class="built_in">resize</span>(<span class="number">100</span>,<span class="built_in">Edge</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">init</span>(m);<span class="comment">//初始化head</span></span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;<span class="comment">//记录起点到终点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add_edge</span>(x,y,w);<span class="comment">//添加正向边，编号为奇数</span></span><br><span class="line">        <span class="built_in">add_edge</span>(y,x,<span class="number">0</span>);<span class="comment">//添加初始容量为0的反向边，编号是偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">max_flow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x08-Dinic’s算法（有点复杂但更快）"><a href="#0x08-Dinic’s算法（有点复杂但更快）" class="headerlink" title="0x08 Dinic’s算法（有点复杂但更快）"></a>0x08 Dinic’s算法（有点复杂但更快）</h2><p>关键在于blocking graph，level graph和residual graph</p><p>该算法引入了level graph层级图这个概念，先记录一下层级图</p><h3 id="Level-Graph"><a href="#Level-Graph" class="headerlink" title="Level Graph"></a>Level Graph</h3><p>层级图的构建，从起点S开始，能从S一步到达的节点为一层，从一层节点一步到达的节点为二层节点（访问过的节点不算），直到访问到终点T。</p><p><img src="/Images/image-20240229205316906.png" alt="image-20240229205316906" style="zoom: 33%;" /></p><h3 id="Blocking-Graph"><a href="#Blocking-Graph" class="headerlink" title="Blocking Graph"></a>Blocking Graph</h3><p>阻流图，其实就是0x05节介绍简单网络流问时，用于初步解决的简单算法得到的Flow graph，不一定是最大流，只要是把通往终点T的容量全部填满就好了。（在d算法中，阻塞流计算用于level graph）</p><p><img src="/Images/image-20240229205959257.png" alt="image-20240229205959257" style="zoom:33%;" /></p><h3 id="Dinic’s算法流程"><a href="#Dinic’s算法流程" class="headerlink" title="Dinic’s算法流程"></a>Dinic’s算法流程</h3><p>算法需要准备一个residual graph，每次循环都根据residual graph更新level graph，然后再在residual graph中减去level graph中的阻塞流，得到新的residual graph，然后再在residual中添加反向路径（和F-F算法中的思路一样），反向路径也算实际存在的路径，用于level graph的构建，一直循环知道level graph没法构建，算法就结束，这时候用Original graph（原图）的，和起点S相连边的容量减去它的residual（空闲量），就能得到最大流量。（公式：Original - Residual = Flow）</p><h2 id="0x09-图的存储"><a href="#0x09-图的存储" class="headerlink" title="0x09 图的存储"></a>0x09 图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵矩阵属于是好写但效率低的存储方式，挺实用的数据结构。</p><p>建立一个二维数组mat[x] [y]，表示x -&gt; y，权值为数组mat的值weight，例如节点1到节点2的边权值为5，记为mat[1] [2]  = 5。很好理解。</p><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>链式前向星的存储主体是边，是以【1，n】为起点的边的集合，例如将以1为起点的边的集合放在一起：</p><p>1：1 5 6，1 3 4，1 2 1，2： 2 3 2 …………</p><p>知道这个后，得先了解几个变量的含义：</p><p>Next，表示与这个边起点相同的上一条边的编号。</p><p>head[ i ]数组，表示以 i 为起点的最后一条边的编号（一般初始化为-1）。</p><p>cnt，用来记录边的编号（我习惯从1开始）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> to,<span class="type">int</span> w,<span class="type">int</span> next)&#123;</span><br><span class="line">            <span class="comment">//Next，表示与这个边起点相同的上一条边的编号</span></span><br><span class="line">            <span class="comment">//to，表示边指向的节点，w是边权</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;next = next, <span class="keyword">this</span>-&gt;to = to, <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> to,w,next;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>,head[<span class="number">100</span>];<span class="comment">//初始化-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;<span class="comment">//u起点，v终点，w边权</span></span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点最后一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    <span class="comment">//这时候edge[cnt]变成以u起点的最后一条边，存储进head，然后cnt++</span></span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//初始化head，n代表节点数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        head[n] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    edge.<span class="built_in">resize</span>(<span class="number">100</span>,<span class="built_in">Edge</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//这里容器edge也要初始化一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说为什么要给head数初始化-1呢？每次读入边时，就会记入edge[cnt].next，表示同起点的上一条边的编号，那么第一条边的next就会被head赋值成-1，当你读取边时，edge[cnt].next == -1为终止条件（从后到前）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL队列和栈</title>
      <link href="/2024/02/24/STL%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
      <url>/2024/02/24/STL%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-栈"><a href="#0x01-栈" class="headerlink" title="0x01 栈"></a>0x01 栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><p>先记录一下栈stack。</p><p>和数据结构教材讲的性质基本一致，这里记录一下STL实现栈的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>栈的类模板，第一个参数是存储对象的类型，第二个参数是底层容器的类型。</p><p><img src="/Images/image-20240225200412230.png" alt="image-20240225200412230" style="zoom:80%;" /></p><p>还有一个swap函数，swap(stack<T> &amp;other_stack)，能将当前栈中的元素和参数中的元素交换。stack模板还有赋值运算符重载，operator=( )。</p><p>访问栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; data&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; </span><br><span class="line"><span class="comment">//初始化一个栈</span></span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(data)</span></span>; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;data : &quot;</span>&lt;&lt;data.<span class="built_in">size</span>()&lt;&lt;endl; </span><br><span class="line"><span class="keyword">while</span>(!data.<span class="built_in">empty</span>())&#123;   </span><br><span class="line">    <span class="comment">//获得栈顶元素</span></span><br><span class="line">cout&lt;&lt;data.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">    <span class="comment">//栈顶元素出栈 </span></span><br><span class="line">data.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;data : &quot;</span>&lt;&lt;data.<span class="built_in">size</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="0x02-队列"><a href="#0x02-队列" class="headerlink" title="0x02 队列"></a>0x02 队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><p>stack和queue这类模板在初始化时，都默认封装了一个deque<T>容器，修改第二个参数的模板类型能使用其他自定义的容器。</p><p><img src="/Images/image-20240225201211734.png" alt="image-20240225201211734" style="zoom:80%;" /></p><p>这里顺便记录一下emplace是什么吧，我当时看的时候也不懂，看这个例子就完全明白了</p><p><img src="/Images/image-20240225203600168.png" alt="image-20240225203600168" style="zoom: 80%;" />也有赋值运算符重，也有swap函数，也有拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; data_&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line">queue&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">q</span>(data_); </span><br><span class="line"><span class="comment">//list容器初始化队列</span></span><br><span class="line">queue&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;&gt; copy_q &#123;q&#125;; </span><br><span class="line"><span class="comment">//拷贝构造新队列</span></span><br></pre></td></tr></table></figure><p>这里补充一下，list容器类似于链表，deque容器类似于vector，但是是双端数组，可以对头部进行插入和删除。具体操作再看。</p><p>栈和队列两种模板默认封装deque容器，更利于头尾的修改。</p><h2 id="0x03-堆（优先队列）"><a href="#0x03-堆（优先队列）" class="headerlink" title="0x03 堆（优先队列）"></a>0x03 堆（优先队列）</h2><p>优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;Type, Container, Functional&gt;</span><br></pre></td></tr></table></figure><p>Type就是数据类型，Container就是容器类型，STL里默认vector。Functional就是比较的方式（是一个仿函数，重载了括号），默认大顶堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列（小顶堆）</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列（大顶堆）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; a;（默认大顶堆）</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><p>如果你用的不是int这种基本数据类型，比如比较两个类，那么就要填入自己重载后的运算符了。</p><p><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">c++优先队列(priority_queue)用法详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/352404451">C++ STL 之 stack 和 queue</a></p><p><a href="https://blog.csdn.net/penghuicheng/article/details/51505625">C++11新特性emplace操作</a></p><p><a href="https://blog.csdn.net/qq_46514118/article/details/120698465">优先队列自定义类型</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector容器基础</title>
      <link href="/2024/02/24/vector%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/02/24/vector%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-vector构造函数"><a href="#0x01-vector构造函数" class="headerlink" title="0x01 vector构造函数"></a>0x01 vector构造函数</h2><p><img src="/Images/adfb98be36cf58f17c2a79b8087f429.png" alt="adfb98be36cf58f17c2a79b8087f429"></p><p>除了第一种，其他几种基本都是拷贝构造而来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//压入10个100的int数</span></span><br></pre></td></tr></table></figure><p>拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v2</span>(v);</span><br><span class="line"><span class="comment">//拷贝了v的10个100</span></span><br></pre></td></tr></table></figure><h2 id="0x02-vector赋值操作"><a href="#0x02-vector赋值操作" class="headerlink" title="0x02 vector赋值操作"></a>0x02 vector赋值操作</h2><p><img src="/Images/image-20240219145512229.png" alt="image-20240219145512229"></p><p>第一种就是等号运算符重载，直接v1 = v2赋值就好了。</p><h2 id="0x03-vector容量和大小"><a href="#0x03-vector容量和大小" class="headerlink" title="0x03 vector容量和大小"></a>0x03 vector容量和大小</h2><p><img src="/Images/image-20240219153402588.png" alt="image-20240219153402588"></p><p>empty( )，若容量为空则返回true，不为空则返回false。</p><p>capacity( )是返回容器的容量的函数，容器的容量不小于容器中元素的个数（常识）。</p><p>resize函数能调整容器的大小（长度size，并非容量）。</p><p>resize函数若不指定填充的元素elem，则默认填充0。</p><h2 id="0x04-vector插入和删除"><a href="#0x04-vector插入和删除" class="headerlink" title="0x04 vector插入和删除"></a>0x04 vector插入和删除</h2><p><img src="/Images/image-20240219160518544.png" alt="image-20240219160518544"></p><p>这里重点记录一下迭代器修改元素的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器插入法</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(),<span class="number">100</span>);</span><br><span class="line"><span class="comment">//在v1.begin()的位置插入100，v1.begin()是指向首元的迭代器</span></span><br></pre></td></tr></table></figure><p>注意const_iterator pos 位置是传入迭代器就好了。</p><h2 id="0x05-vector数据存取"><a href="#0x05-vector数据存取" class="headerlink" title="0x05 vector数据存取"></a>0x05 vector数据存取</h2><p><img src="/Images/image-20240219161554444.png" alt="image-20240219161554444"></p><p>没啥好注意的，一般都用[ ]重载来访问</p><h2 id="0x06-vector互换容器"><a href="#0x06-vector互换容器" class="headerlink" title="0x06 vector互换容器"></a>0x06 vector互换容器</h2><p><img src="/Images/image-20240219161831638.png" alt="image-20240219161831638"></p><p>实现两个容器内元素进行互换。</p><p>巧用swap可以收缩内存空间。</p><p>实际情况：假设你定义了一个容量很大的容器时，若当你不需要使用这么大的容量时，通过resize函数只能改变容器的大小，而容量不会改变，这时候多余的容量就遭到了浪费。</p><p>比如你push_back了10000个数据，容量会给你自动扩展到约13000的数据，这时候你resize(3)，将容器的大小调整至3，这时候容量依然是13000左右。这会造成浪费！！！</p><p>解决方法，匿名函数和swap函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br></pre></td></tr></table></figure><p>vector<int>(v) 默认构造匿名对象。这里会根据v目前所用的元素个数的大小来初始化匿名对象，在这里的例子里，大小为3。</p><p>然后调用 .swap(v)，v的容量经过swap交换后是 3，大小（size）也是 3，不会造成空间浪费了，匿名对象的容量经过swap后占用很大，但是在这一行执行完后匿名对象会被销毁，就不会造成空间浪费了。</p><p><img src="/Images/image-20240219182013042.png" alt="image-20240219182013042"></p><h2 id="0x07-vector预留空间"><a href="#0x07-vector预留空间" class="headerlink" title="0x07 vector预留空间"></a>0x07 vector预留空间</h2><p><img src="/Images/image-20240219182129095.png" alt="image-20240219182129095"></p><p>预留空间是为了，减少vector在动态扩展容量时的扩展次数。</p><p>vector容器在创建的时候是会先预留较多的空间来应对之后的扩展，比如我push_back了10个数据，编译器会事先将这个vector容器的容量设定成100多（大概的，反正比容器大小，元素个数多）。当你继续扩展这个容器时，可能超过了事先预留好的容量，这时候编译器会将原先的容器内的数据拷贝到一个新的，容量更大的容器中，虽然容器的名字不会变，但是该容器的首地址会发生了改变（因为数据被拷贝存储到了一个新开辟的空间）。</p><p>经过浅显的测试，10000个数据在push_back时大约会发生30次的新开辟存储空间的情况，浪费了时间资源。</p><p>测试代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//统计开辟次数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">//当每次开辟新空间时，v[0]的地址就会变化，以此为参照统计开辟次数</span></span><br><span class="line">    <span class="keyword">if</span>(p!= &amp;v[<span class="number">0</span>])&#123;</span><br><span class="line">        p = &amp;v[<span class="number">0</span>];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt;</span><br></pre></td></tr></table></figure><p>所以一开始就先预留出容量，能减少扩展次数。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树转载记录</title>
      <link href="/2024/02/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%8D%E4%B8%80%E9%A2%97%E6%A0%91/"/>
      <url>/2024/02/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%8D%E4%B8%80%E9%A2%97%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/106118909">原文章（线段树）</a></p><h2 id="0x01-种一颗线段树"><a href="#0x01-种一颗线段树" class="headerlink" title="0x01 种一颗线段树"></a>0x01 种一颗线段树</h2><p>假如我现在有一个数组A，总共有n个元素，我既想实现区间修改，又想单个修改，这时候种一颗线段树来维护这个数组，能平衡收益。</p><h2 id="0x02-怎么建立？"><a href="#0x02-怎么建立？" class="headerlink" title="0x02 怎么建立？"></a>0x02 怎么建立？</h2><p>线段树是一颗平衡二叉树，双亲结点是区间的和，左右子节点是双亲区间分两半的区间</p><p><img src="/Images/image-20240224211506204.png" alt="image-20240224211506204" style="zoom: 50%;" /></p><p>每个节点 p 的左右子节点的编号分别为 2p 和 2p+1，假设 双亲结点p 的为区间 [l , r]的和。</p><p>设 mid = [(l + r)/2]，那么两个子节点分别存储[l , mid] 和 [mid+1 , r]的和。可以发现，左节点对应的区间长度，与右节点相同或者比之恰好多1。</p><p>知道这些后，便可以用递归的方法来种一颗线段树了。大体的思想就是，从叶子结点开始，从下往上逐步建立。这便是递归的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(elem l = <span class="number">1</span>, elem r = n, elem p = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">// 到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123; </span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br><span class="line">        tree[p] = A[l];</span><br><span class="line">        <span class="comment">// 用数组中的数据赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        elem mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(l, mid, p * <span class="number">2</span>); </span><br><span class="line">        <span class="comment">// 先建立左右子节点</span></span><br><span class="line">        <span class="built_in">build</span>(mid + <span class="number">1</span>, r, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 该节点的值等于左右子节点之和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-修改维护"><a href="#0x03-修改维护" class="headerlink" title="0x03 修改维护"></a>0x03 修改维护</h2><p>在讲区间修改前，要先引入一个 “<strong>懒标记</strong>”（lazy） 的概念。懒标记是线段树的精髓所在。对于区间修改，朴素的想法是用<strong>递归</strong>的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。使用懒标记后，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个<strong>标记</strong>，将来要用到它的<strong>子区间</strong>的时候，再向下<strong>传递</strong>。</p><p>给目标区间[l , r]加上数d。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll d, ll p = <span class="number">1</span>, ll cl = <span class="number">1</span>, ll cr = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cl &gt; r || cr &lt; l) <span class="comment">// 区间无交集</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) <span class="comment">// 当前节点对应的区间包含在目标区间中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[p] += (cr - cl + <span class="number">1</span>) * d; <span class="comment">// 更新当前区间的值</span></span><br><span class="line">        <span class="keyword">if</span> (cr &gt; cl) <span class="comment">// 如果不是叶子节点</span></span><br><span class="line">            mark[p] += d; <span class="comment">// 给当前区间打上标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 与目标区间有交集，但不包含于其中</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (cl + cr) / <span class="number">2</span>;</span><br><span class="line">        mark[p * <span class="number">2</span>] += mark[p]; <span class="comment">// 标记向下传递</span></span><br><span class="line">        mark[p * <span class="number">2</span> + <span class="number">1</span>] += mark[p];</span><br><span class="line">        tree[p * <span class="number">2</span>] += mark[p] * (mid - cl + <span class="number">1</span>); <span class="comment">// 往下更新一层</span></span><br><span class="line">        tree[p * <span class="number">2</span> + <span class="number">1</span>] += mark[p] * (cr - mid);</span><br><span class="line">        mark[p] = <span class="number">0</span>; <span class="comment">// 清除标记</span></span><br><span class="line">        <span class="built_in">update</span>(l, r, d, p * <span class="number">2</span>, cl, mid); <span class="comment">// 递归地往下寻找</span></span><br><span class="line">        <span class="built_in">update</span>(l, r, d, p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, cr);</span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 根据子节点更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分三种情况处理，当前结点p的区间[cl , rl]，与目标区间无交集，包含关系，有交集。</p><p>用懒标记来给维护区间的加减</p><h2 id="0x04-区间查询"><a href="#0x04-区间查询" class="headerlink" title="0x04 区间查询"></a>0x04 区间查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll l, ll r, ll p = <span class="number">1</span>, ll cl = <span class="number">1</span>, ll cr = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cl &gt; r || cr &lt; l)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tree[p];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (cl + cr) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push_down</span>(p, cr - cl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, r, p * <span class="number">2</span>, cl, mid) + <span class="built_in">query</span>(l, r, p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, cr); </span><br><span class="line">        <span class="comment">// 上一行拆成三行写就和区间修改格式一致了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下刷的入门题</title>
      <link href="/2024/02/24/%E5%B0%8F%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%88%B7%E7%9A%84%E5%85%A5%E9%97%A8%E9%A2%98/"/>
      <url>/2024/02/24/%E5%B0%8F%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%88%B7%E7%9A%84%E5%85%A5%E9%97%A8%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-P1009-NOIP1998-普及组-阶乘之和"><a href="#0x01-P1009-NOIP1998-普及组-阶乘之和" class="headerlink" title="0x01 P1009 [NOIP1998 普及组] 阶乘之和"></a>0x01 P1009 [NOIP1998 普及组] 阶乘之和</h2><p>这题要用高精度乘法和高精度加法，把每位数字单独存储到一个数组中，每个元素如果大于9再进位，以此类推。这题的乘法是半个高精度，一个是高精度数字，另一个是普通的int数，简单了一点。</p><p>不过如果两个都是高精度数的乘法，原理差不多，就是把这个一个高精度一个普通的做好多遍，然后全部加起来再进位就好了，以后有机会再写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> i,sum[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;,one[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;,n,j;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    sum[<span class="number">0</span>]=one[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">            one[j]*=i;</span><br><span class="line">            <span class="comment">//乘法操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(one[j]&gt;<span class="number">9</span>)&#123;</span><br><span class="line">                one[j+<span class="number">1</span>] += one[j]/<span class="number">10</span>;</span><br><span class="line">                one[j]%=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进位操作</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">            sum[j]+=one[j];</span><br><span class="line">            <span class="comment">//加法操作</span></span><br><span class="line">            <span class="keyword">if</span> (sum[j]&gt;<span class="number">9</span>) &#123;</span><br><span class="line">                sum[j+<span class="number">1</span>] += sum[j]/<span class="number">10</span>;</span><br><span class="line">                sum[j]%=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进位操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; sum[i]==<span class="number">0</span>)&#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抹0操作</span></span><br><span class="line">    <span class="keyword">for</span> (j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum[j]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-P1217-USACO1-5-回文质数-Prime-Palindromes"><a href="#0x02-P1217-USACO1-5-回文质数-Prime-Palindromes" class="headerlink" title="0x02 P1217 [USACO1.5] 回文质数 Prime Palindromes"></a>0x02 P1217 [USACO1.5] 回文质数 Prime Palindromes</h2><p>sb题目，老是卡我时间。</p><p>先判断回文再判断质数，不然时间不够。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">zhi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">huiwen</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp=x;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        y = y*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp==y)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=b;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">9989900</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">huiwen</span>(i)&amp;&amp;<span class="built_in">zhi</span>(i))&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-P1420-最长连号"><a href="#0x03-P1420-最长连号" class="headerlink" title="0x03 P1420 最长连号"></a>0x03 P1420 最长连号</h2><p>超级超级简单的动态规划，把每次最长的连号存储起来，断了就重新计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">            dp[i] += dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        m = <span class="built_in">max</span>(m,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-P3613-【深基15-例2】寄包柜"><a href="#0x04-P3613-【深基15-例2】寄包柜" class="headerlink" title="0x04 P3613 【深基15.例2】寄包柜"></a>0x04 P3613 【深基15.例2】寄包柜</h2><p>初次用容器vector和map解题，挺有意思的，map类似python的字典</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; V;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="type">int</span> n,q,i,j,k,opcode=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=q;t++)&#123;</span><br><span class="line">        cin &gt;&gt; opcode &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        <span class="keyword">if</span>(opcode==<span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            V[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opcode==<span class="number">2</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(V[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = ans.<span class="built_in">begin</span>();it != ans.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-U264780-新生杯录取"><a href="#0x05-U264780-新生杯录取" class="headerlink" title="0x05 U264780 新生杯录取"></a>0x05 U264780 新生杯录取</h2><p>题目大概的意思就是，再给定的很多数据里，挑选最小的几个然后排序。</p><p>由于限制了内存，先排序再取值很难实现，学习了堆排序的知识后，决定先取值再排序。</p><p>输入n个数据，然后排k，从小到大。</p><p>这里讲一下堆的结构，对于大堆，用完全二叉树的形式表示，他的任意一个节点的值总比他的左右孩子大，这里就隐含了一个信息，二叉树形式的堆的头结点的值是最大的，不管头结点的值怎么被修改，只要在此之后把堆维护一下，头结点的值仍然是最大的。用这个特性，我们在建立了k个元素的大堆后，之后每插入一个元素时先和头结点比较，如果更小就和头结点交换值，然后再维护一下，以此类推，最后堆内的k个元素必定是n个元素中最小的那几个，最后再堆排序一下输出。</p><p>知道思路后，关于堆，有建立堆，维护堆，堆排序三个操作，这里贴代码都有实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> heap[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> n,k,temp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> heap[],<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = heap[a];</span><br><span class="line">    heap[a] = heap[b];</span><br><span class="line">    heap[b] = heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">correctHeap</span><span class="params">(<span class="type">int</span> heap[],<span class="type">int</span> index, <span class="type">int</span> len)</span></span>&#123;<span class="comment">//维护堆的函数，始终保持大堆</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * index &lt;= len)&#123;<span class="comment">//如果index有孩子</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">2</span>*index, r = <span class="number">2</span>*index+<span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> maxIndex = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= len &amp;&amp; heap[r] &gt; heap[l])&#123;</span><br><span class="line">            maxIndex = r;</span><br><span class="line">        &#125;<span class="comment">//判断左右孩子谁大</span></span><br><span class="line">        <span class="keyword">if</span>(heap[index] &gt;= heap[maxIndex])&#123;<span class="comment">//如果双亲更大</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(heap, index, maxIndex);</span><br><span class="line">        index = maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> heap[], <span class="type">int</span> len)</span></span>&#123;<span class="comment">//堆排序，从小到大</span></span><br><span class="line">    <span class="type">int</span> s = len;</span><br><span class="line">    <span class="keyword">while</span>(s &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap,<span class="number">1</span>,s);</span><br><span class="line">        s--;</span><br><span class="line">        <span class="built_in">correctHeap</span>(heap, <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapCreate</span><span class="params">(<span class="type">int</span> heap[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">correctHeap</span>(heap, index, len);</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//改善输入输出流时间效率的代码，具体含义可以查一下</span></span><br><span class="line">    std::ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cin &gt;&gt; heap[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先建一个k大堆</span></span><br><span class="line">    <span class="built_in">heapCreate</span>(heap,k);</span><br><span class="line">    <span class="comment">//插入数据和堆顶比较，小就交换，大就舍去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-k;i++)&#123;</span><br><span class="line">        cin &gt;&gt; heap[<span class="number">104</span>];</span><br><span class="line">        <span class="keyword">if</span>(heap[<span class="number">104</span>] &lt; heap[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap,<span class="number">104</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">correctHeap</span>(heap,<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后排序</span></span><br><span class="line">    <span class="built_in">heapSort</span>(heap,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cout &lt;&lt; heap[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的维护操作"><a href="#堆的维护操作" class="headerlink" title="堆的维护操作"></a>堆的维护操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">correctHeap</span><span class="params">(<span class="type">int</span> heap[],<span class="type">int</span> index, <span class="type">int</span> len)</span></span>&#123;<span class="comment">//维护堆的函数，始终保持大堆</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * index &lt;= len)&#123;<span class="comment">//如果index有孩子</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">2</span>*index, r = <span class="number">2</span>*index+<span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> maxIndex = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= len &amp;&amp; heap[r] &gt; heap[l])&#123;</span><br><span class="line">            maxIndex = r;</span><br><span class="line">        &#125;<span class="comment">//判断左右孩子谁大</span></span><br><span class="line">        <span class="keyword">if</span>(heap[index] &gt;= heap[maxIndex])&#123;<span class="comment">//如果双亲更大</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(heap, index, maxIndex);</span><br><span class="line">        index = maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的维护操作（这里以大堆为例子），其实就是让某个结点index和左右孩子结点比较，若双亲节点大则不用维护，若双亲节点小，交换双亲节点和值较大的那个孩子节点，之后有index 的节点继续作为双亲节点和他的孩子节点比较，直到叶子结点，或者双亲节点大。</p><h3 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapCreate</span><span class="params">(<span class="type">int</span> heap[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">correctHeap</span>(heap, index, len);</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的建立其实就是，把每个节点（叶子外）全都做一遍堆的维护，而且要自下而上（i—就可以实现)。这样做就能保证每个节点的左右孩子均比这个节点小。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> heap[], <span class="type">int</span> len)</span></span>&#123;<span class="comment">//堆排序，从小到大</span></span><br><span class="line">    <span class="type">int</span> s = len;</span><br><span class="line">    <span class="keyword">while</span>(s &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap,<span class="number">1</span>,s);</span><br><span class="line">        s--;</span><br><span class="line">        <span class="built_in">correctHeap</span>(heap, <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序，其实就是将堆顶元素一个一个取出来的操作，将堆顶元素和堆底元素交换，然后堆的大小减一，然后再把缩小后的堆维护一下，最后原先的那个堆，从堆底到堆顶，就是从大到小排序的数了，正着输出就是从小到大排序。</p><h2 id="0x06-P1449-后缀表达式"><a href="#0x06-P1449-后缀表达式" class="headerlink" title="0x06 P1449 后缀表达式"></a>0x06 P1449 后缀表达式</h2><p>这是一道用栈（stack）模拟算术的题，非常经典，故记录。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_code</span><span class="params">(<span class="type">char</span> code)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fir,sec;</span><br><span class="line">    fir = sta.<span class="built_in">top</span>();</span><br><span class="line">    sta.<span class="built_in">pop</span>();</span><br><span class="line">    sec = sta.<span class="built_in">top</span>();</span><br><span class="line">    sta.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">switch</span>(code)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            sec += fir;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            sec -= fir;   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            sec *= fir;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            sec /= fir; </span><br><span class="line">            <span class="keyword">break</span>;      </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sta.<span class="built_in">push</span>(sec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            num = <span class="number">10</span>*num + (c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            sta.<span class="built_in">push</span>(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">run_code</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sta.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x07-P1996-约瑟夫问题"><a href="#0x07-P1996-约瑟夫问题" class="headerlink" title="0x07 P1996 约瑟夫问题"></a>0x07 P1996 约瑟夫问题</h2><p>刚开始学C语言时碰到的难题，现在看来豁然开朗，记录一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans,<span class="built_in">people</span>(<span class="number">101</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,m,cnt = <span class="number">0</span>,i=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(ans.<span class="built_in">size</span>()!=n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(cnt == m)&#123;<span class="comment">//假如数到m了</span></span><br><span class="line">            cnt =<span class="number">0</span>;</span><br><span class="line">            people[i] = <span class="number">1</span>;<span class="comment">//赋值1代表出局</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;  </span><br><span class="line">        i = (i%n) + <span class="number">1</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=ans.<span class="built_in">begin</span>();it!=ans.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我用了模拟的方法，模拟这个过程进行。</p><h2 id="0x08-P1160-队列安排"><a href="#0x08-P1160-队列安排" class="headerlink" title="0x08 P1160 队列安排"></a>0x08 P1160 队列安排</h2><p>我真没想到我写的这一坨式能跑过，记录留念一下。</p><p>这题用链表查找，跑的内存真大，我以后看能不能优化一下这个思路。</p><p>内存爆满，有一说一，处理得不太好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; student;</span><br><span class="line">map&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;::iterator&gt; id; </span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="type">int</span> n,m,loc,stu_id;<span class="comment">//学生数，去掉学生数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    student.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    id[<span class="number">1</span>] = student.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stu_id &gt;&gt; loc;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">0</span>)&#123;<span class="comment">//插入左边</span></span><br><span class="line">            id[i] = student.<span class="built_in">insert</span>(id[stu_id],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">1</span>)&#123;<span class="comment">//插入右边</span></span><br><span class="line">            it = <span class="built_in">next</span>(id[stu_id]);</span><br><span class="line">            id[i] = student.<span class="built_in">insert</span>(it,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stu_id;</span><br><span class="line">        <span class="keyword">if</span>(*id[stu_id]!=<span class="number">0</span>)&#123;</span><br><span class="line">            *id[stu_id] = <span class="number">0</span>;</span><br><span class="line">            student.<span class="built_in">erase</span>(id[stu_id]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(it = student.<span class="built_in">begin</span>();it!=student.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空容器</span></span><br><span class="line">    id.<span class="built_in">clear</span>();</span><br><span class="line">    map&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;::iterator&gt;().<span class="built_in">swap</span>(id);</span><br><span class="line">    student.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来我写着写着发现，这题感觉根本就不用map这个东西，map容器id下标是int，完全用普通数组就可以胜任这个记录的工作。</p><p>后面看别人写的才发现insert操作会返回插入值位置的迭代器。。。。我还一直在搞什么it++，it—操作，搞得像个啥乱一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; student;</span><br><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;::iterator&gt; id;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="type">int</span> n,m,loc,stu_id;<span class="comment">//学生数，去掉学生数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    id.<span class="built_in">resize</span>(<span class="number">100005</span>);</span><br><span class="line">    student.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    id[<span class="number">1</span>] = student.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stu_id &gt;&gt; loc;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">0</span>)&#123;<span class="comment">//插入左边</span></span><br><span class="line">            id[i] = student.<span class="built_in">insert</span>(id[stu_id],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">1</span>)&#123;<span class="comment">//插入右边</span></span><br><span class="line">            it = <span class="built_in">next</span>(id[stu_id]);</span><br><span class="line">            id[i] = student.<span class="built_in">insert</span>(it,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stu_id;</span><br><span class="line">        <span class="keyword">if</span>(*id[stu_id]!=<span class="number">0</span>)&#123;</span><br><span class="line">            *id[stu_id] = <span class="number">0</span>;</span><br><span class="line">            student.<span class="built_in">erase</span>(id[stu_id]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(it = student.<span class="built_in">begin</span>();it!=student.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空容器</span></span><br><span class="line">    id.<span class="built_in">clear</span>();</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;::iterator&gt;().<span class="built_in">swap</span>(id);</span><br><span class="line">    student.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化了一下，不使用map，而使用vector存取，内存消耗减少了一倍。</p><h2 id="0x09-P1540-NOIP2010-提高组-机器翻译"><a href="#0x09-P1540-NOIP2010-提高组-机器翻译" class="headerlink" title="0x09 P1540 [NOIP2010 提高组] 机器翻译"></a>0x09 P1540 [NOIP2010 提高组] 机器翻译</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,n;<span class="comment">//m是内存容量，n是单词个数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>, word;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; mem;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    mem.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; word;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(mem.<span class="built_in">begin</span>(),mem.<span class="built_in">end</span>(),word) == mem.<span class="built_in">end</span>())&#123;</span><br><span class="line">            mem.<span class="built_in">push_back</span>(word);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mem.<span class="built_in">size</span>() &gt; m)&#123;</span><br><span class="line">            mem.<span class="built_in">erase</span>(mem.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mem.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(mem);</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列问题，不过需要常常遍历这个队列，所以不用queue而用vector代替了。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++容器初识和string容器</title>
      <link href="/2024/02/19/c-%E5%AE%B9%E5%99%A8%E5%88%9D%E8%AF%86%E5%92%8Cstring%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/02/19/c-%E5%AE%B9%E5%99%A8%E5%88%9D%E8%AF%86%E5%92%8Cstring%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-vector容器"><a href="#0x01-vector容器" class="headerlink" title="0x01 vector容器"></a>0x01 vector容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建vector容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//存入数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过迭代器遍历</span></span><br><span class="line"><span class="comment">//it可看成指针，begin()是起始迭代器，存放容器第一个数据的地址</span></span><br><span class="line"><span class="keyword">for</span>(std::vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();it ++)&#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：0 1 2 3 4 5 6 7 8 9 </span></span><br></pre></td></tr></table></figure><p>简单的使用方法。。</p><p>vector类模板，除了int以外还能定义其他数据类型。</p><p>容器是可以嵌套容器的，可以将内层的容器看成一个数据类型，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; V;</span><br></pre></td></tr></table></figure><h2 id="0x02-string容器"><a href="#0x02-string容器" class="headerlink" title="0x02 string容器"></a>0x02 string容器</h2><p>string 的初始化构造。</p><p>我们常用的c++风格的字符串数据类型string本质也是一个容器。</p><p>先介绍一个string容器的构造方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空的字符串</span></span><br><span class="line">string str;</span><br><span class="line"><span class="comment">//用c类型的字符串初始化</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"><span class="comment">//用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;</span><br><span class="line"><span class="comment">//用n个字符c初始化</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>string内部实际上也是维护着一个c语言的字符串的数据类型。</p><h2 id="0x03-string赋值操作"><a href="#0x03-string赋值操作" class="headerlink" title="0x03 string赋值操作"></a>0x03 string赋值操作</h2><p><img src="/Images/image-20240219003258861.png" alt="image-20240219003258861"></p><h2 id="0x04-string字符串拼接"><a href="#0x04-string字符串拼接" class="headerlink" title="0x04 string字符串拼接"></a>0x04 string字符串拼接</h2><p><img src="/Images/image-20240219004951406.png" alt="image-20240219004951406"></p><h2 id="0x05-string的查找和替换"><a href="#0x05-string的查找和替换" class="headerlink" title="0x05 string的查找和替换"></a>0x05 string的查找和替换</h2><p><img src="/Images/image-20240219133011947.png" alt="image-20240219133011947"></p><h2 id="0x06-字符串比较"><a href="#0x06-字符串比较" class="headerlink" title="0x06 字符串比较"></a>0x06 字符串比较</h2><p><img src="/Images/image-20240219135705055.png" alt="image-20240219135705055"></p><h2 id="0x07-string字符存取"><a href="#0x07-string字符存取" class="headerlink" title="0x07 string字符存取"></a>0x07 string字符存取</h2><p><img src="/Images/image-20240219140111418.png" alt="image-20240219140111418"></p><p>第一种方法类似于数组下标的索引法</p><h2 id="0x08-string的插入和删除"><a href="#0x08-string的插入和删除" class="headerlink" title="0x08 string的插入和删除"></a>0x08 string的插入和删除</h2><p><img src="/Images/image-20240219140235034.png" alt="image-20240219140235034"></p><h2 id="0x09-string子串获取"><a href="#0x09-string子串获取" class="headerlink" title="0x09 string子串获取"></a>0x09 string子串获取</h2><p><img src="/Images/image-20240219141407201.png" alt="image-20240219141407201"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF2024</title>
      <link href="/2024/02/19/VNCTF%E7%9A%84%E7%AD%BE%E5%88%B0%E9%A2%98/"/>
      <url>/2024/02/19/VNCTF%E7%9A%84%E7%AD%BE%E5%88%B0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-TBXO"><a href="#0x01-TBXO" class="headerlink" title="0x01 TBXO"></a>0x01 TBXO</h2><p>只会看了这一道，应该也只会这一道了。</p><p><img src="../Images/5eabd65659bf0b96f62a129e0a95673.png" alt="5eabd65659bf0b96f62a129e0a95673"></p><p>打开后f5，发现全是这种无意义的也不是函数的东西，感觉是经过防止反汇编的处理，无奈只能看汇编代码。</p><p>shift+f12找有用的字符串，发现有一个welcome 和wrong right等字眼的字符，点进去查找引用看看，能很快定位到main函数，当然是没法f5的，动调一步一步调试看会去哪里</p><p><img src="../Images/image-20240218134920902.png" alt="image-20240218134920902"></p><p>发现这个是scanf函数，要输入flag，不知道flag是多少位，发现输入错误后程序会直接中断。当时在调试的时候无意间发现了一些类似加密函数的汇编代码，因为就在这个scanf函数下面，也是多看了几眼，然后发现是一个tea加密，不过f5后的代码是有问题的，不够全面，而且有很多差错。</p><p><img src="../Images/image-20240218135144035.png" alt="image-20240218135144035"></p><p>如图，首先先不谈这些v1，v4，v2的是什么东西，关是这个a1 什么什么的就反汇编得很糟糕了，点进去这个unk_CC3004，发现是一个长度40char的数据，盲猜是enc密文，再动调试一下输入长度40 的flag，发现能调试到这一个函数了，直接看汇编。</p><p><img src="../Images/image-20240218135524860.png" alt="image-20240218135524860"></p><p>不难发现这个v1 就是 <em>(a - 1)，v4就是 </em>a，然后edi是存储sum 的 寄存器，每次循环加上 -0x61C88647，动调发现循环0x20轮，很典型的tea加密，就是多异或了一次0x33，这些信息看f5伪代码肯定是看不出来的，所以还是建议看汇编代码，比较准确。</p><p>解密的逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__int32 key1 = <span class="number">0x67626463</span>, key2 = <span class="number">0x696D616E</span>, key3 = <span class="number">0x79645F65</span>, key4 = <span class="number">0x6B696C69</span>;</span><br><span class="line">__int32 delta = <span class="number">-0x61c88647</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span><span class="params">(<span class="type">unsigned</span> __int32 &amp;esi,<span class="type">unsigned</span> __int32 &amp;eax)</span></span>&#123;</span><br><span class="line">__int32 sum = delta *<span class="number">32</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">eax -= (esi + sum) ^ (key3 + (esi &lt;&lt; <span class="number">4</span>)) ^ (key4 + (esi &gt;&gt; <span class="number">5</span>)) ^ <span class="number">0x33</span>;</span><br><span class="line">esi -= (eax + sum) ^ (key1 + (eax &lt;&lt; <span class="number">4</span>)) ^ (key2 + (eax &gt;&gt; <span class="number">5</span>)) ^ <span class="number">0x33</span>;</span><br><span class="line">sum -= delta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整脚本，只要把40位密文分成10份然后两两加密就好了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">__int32 key1 = <span class="number">0x67626463</span>, key2 = <span class="number">0x696D616E</span>, key3 = <span class="number">0x79645F65</span>, key4 = <span class="number">0x6B696C69</span>;</span><br><span class="line">__int32 delta = <span class="number">-0x61c88647</span>;</span><br><span class="line"><span class="type">unsigned</span> __int32 enc[<span class="number">40</span>] = &#123;<span class="number">0x10</span>, <span class="number">0x30</span>, <span class="number">0x36</span>, <span class="number">0x31</span>, <span class="number">0x23</span>, <span class="number">0x86</span>, <span class="number">0x93</span>, <span class="number">0xAD</span>, <span class="number">0xC5</span>, <span class="number">0xD4</span>, </span><br><span class="line">  <span class="number">0x92</span>, <span class="number">0x84</span>, <span class="number">0x66</span>, <span class="number">0xE3</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x6B</span>, <span class="number">0x69</span>, <span class="number">0x86</span>, <span class="number">0xC7</span>, </span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x2E</span>, <span class="number">0x09</span>, <span class="number">0xA0</span>, <span class="number">0x33</span>, <span class="number">0x57</span>, <span class="number">0x69</span>, <span class="number">0xDB</span>, <span class="number">0x93</span>, <span class="number">0xA8</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0xDD</span>, <span class="number">0x3E</span>, <span class="number">0xA5</span>, <span class="number">0xD8</span>, <span class="number">0x88</span>, <span class="number">0x37</span>, <span class="number">0x54</span>, <span class="number">0x84</span>, <span class="number">0x7E</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> __int32 enc2[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//解密逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span><span class="params">(<span class="type">unsigned</span> __int32 &amp;esi,<span class="type">unsigned</span> __int32 &amp;eax)</span></span>&#123;</span><br><span class="line">__int32 sum = delta *<span class="number">32</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">eax -= (esi + sum) ^ (key3 + (esi &lt;&lt; <span class="number">4</span>)) ^ (key4 + (esi &gt;&gt; <span class="number">5</span>)) ^ <span class="number">0x33</span>;</span><br><span class="line">esi -= (eax + sum) ^ (key1 + (eax &lt;&lt; <span class="number">4</span>)) ^ (key2 + (eax &gt;&gt; <span class="number">5</span>)) ^ <span class="number">0x33</span>;</span><br><span class="line">sum -= delta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并密文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">enc2[i] = (enc[<span class="number">4</span> * i]) | (enc[<span class="number">4</span> * i + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | (enc[<span class="number">4</span> * i + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (enc[<span class="number">4</span> * i + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆分密文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">enc[<span class="number">4</span> * i] = enc2[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">enc[<span class="number">4</span> * i + <span class="number">1</span>] = (enc2[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">enc[<span class="number">4</span> * i + <span class="number">2</span>] = (enc2[i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">enc[<span class="number">4</span> * i + <span class="number">3</span>] = (enc2[i] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">trans</span>();</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">decrypt</span>(enc2[i],enc2[i+<span class="number">1</span>]);</span><br><span class="line">i = i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trans2</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,enc[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//VNCTF&#123;Box_obfuscation_and_you_ar_socool&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广义表和二叉树的性质</title>
      <link href="/2024/02/15/%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2024/02/15/%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-广义表的定义"><a href="#0x01-广义表的定义" class="headerlink" title="0x01 广义表的定义"></a>0x01 广义表的定义</h2><p>广义表是n（n&gt;=0）个元素的有限序列，其中每一个元素或者是原子，或者是一个广义表。</p><p>广义表通常记为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LS = (a1,a2,...,an)</span><br></pre></td></tr></table></figure><p>其中LS为表名，n为表的长度，每一个ai为表的元素</p><p>习惯上用大写字母表示广义表，小写字母表示原子</p><p>表头：若LS非空，则其中第一个元素a1就是表头，记为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(LS) = a1</span><br></pre></td></tr></table></figure><p>表头可以是原子也可以是子表</p><p>表尾：除表头之外的其他元素组成的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail(LS) = (a2,...,an)</span><br></pre></td></tr></table></figure><p>表尾表示最后一个元素，而是一个子表</p><h2 id="0x02-广义表的性质"><a href="#0x02-广义表的性质" class="headerlink" title="0x02 广义表的性质"></a>0x02 广义表的性质</h2><p>广义表中的数据有相对次序，一个直接前驱和一个直接后继</p><p>广义表的长度定义位最外层所包含的元素的个数</p><p>广义表的深度定义为该广义表展开后所含括号的重数</p><p>广义表可以为其他广义表共享</p><p>广义表可以是一个递归的表，递归表的深度是无穷值</p><p>广义表是多层次结构，可以用图形象地表示</p><h2 id="0x03-树的定义"><a href="#0x03-树的定义" class="headerlink" title="0x03 树的定义"></a>0x03 树的定义</h2><p>树(Tree) 是n (n≥0) 个结点的有限集。</p><p>若n=0，称为空树</p><p>若n&gt;0，则它满足如下两个条件：</p><p>​    有且仅有一个特定的称为根(Root)的结点</p><p>​    其余结点可分为 m(m≥0)个互不相交的有限集 T1,T2,T3,…,Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)</p><p><img src="/Images/image-20240215140407003.png" alt="image-20240215140407003"></p><p>由图可见，显然，树是一个递归的定义</p><h2 id="0x04-树的基本术语"><a href="#0x04-树的基本术语" class="headerlink" title="0x04 树的基本术语"></a>0x04 树的基本术语</h2><p><img src="/Images/image-20240215141325521.png" alt="image-20240215141325521"></p><p>根结点：非空树中无前驱结点的结点（第一个）</p><p>结点的度：结点拥有的子树数</p><p>树的度：树内各结点的度的最大值</p><p>叶子：该结点的度为0，也叫作终端结点</p><p>分支结点：度不为0（非终端结点）</p><p>内部结点：根结点以外的分支结点</p><p>孩子和双亲：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲</p><p>堂兄弟和兄弟：双亲在同一层的结点是堂兄弟，有同一个双亲的结点是兄弟</p><p>结点的祖先：从根到该结点所经分支上的所有结点</p><p>结点的子孙：以某结点为根的子树中的任一结点</p><p>树的深度（高度）：树中结点的最大层次</p><p><img src="/Images/image-20240215142127761.png" alt="image-20240215142127761"></p><p>森林：是m棵互不相交的树的集合，把根结点删除树就变成了森林，一棵树可以看成是一个特殊的森林，反过来，给森林的各子树加上一个双亲结点，森林就变成了树。</p><p>归纳得出，树一定是森林，森林不一定是树</p><h2 id="0x05-二叉树的定义"><a href="#0x05-二叉树的定义" class="headerlink" title="0x05 二叉树的定义"></a>0x05 二叉树的定义</h2><h3 id="为什么要研究二叉树"><a href="#为什么要研究二叉树" class="headerlink" title="为什么要研究二叉树"></a>为什么要研究二叉树</h3><p>普通树（多叉树）若不转化为二叉树，则运算很难实现，因为</p><p>​    二叉树的结构最简单，规律性最强</p><p>​    可以证明，所有树都能转化为唯一对应的二叉树</p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是n(n≥0)个结点的有限集，它或者是空集(n = 0)或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二又树组成。</p><h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><p>每个结点最多有俩孩子(二又树中不存在度大于 2 的结点)</p><p>子树有左右之分，其次序不能颠倒。</p><p>二叉树可以是空集合，根可以有空的左子树或空的右子树</p><h3 id="二叉树和树的区别"><a href="#二叉树和树的区别" class="headerlink" title="二叉树和树的区别"></a>二叉树和树的区别</h3><p>二叉树不是数的特殊情，他们是两个概念</p><p>二叉树结点的子树要区分左子树和右子树，即使只有一颗子树也要进行区分，说明它是左子树还是右子树</p><p>树当结点只有一个孩子时，就无须区分左右次序，这是二叉树和树最主要的区别。</p><p><img src="/Images/image-20240215144243805.png" alt="image-20240215144243805"></p><p><img src="/Images/image-20240215144313378.png" alt="image-20240215144313378"></p><p>也就是二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时，它就无所谓左右了</p><p><img src="/Images/image-20240215144622162.png" alt="image-20240215144622162"></p><h2 id="0x06-二叉树的性质"><a href="#0x06-二叉树的性质" class="headerlink" title="0x06 二叉树的性质"></a>0x06 二叉树的性质</h2><h3 id="三个普遍性质"><a href="#三个普遍性质" class="headerlink" title="三个普遍性质"></a>三个普遍性质</h3><p>性质1：在二叉树的第 i 层上至多有 2的i-1次方个结点（i&gt;=1)</p><p>性质2：深度为k的二叉树至多有 2的k次方 - 1 个结点（k&gt;=1）</p><p>性质3：对于任意一颗二叉树，如果其叶子数为n0，度为2的结点数为n2，则n0 = n2 + 1</p><p>推导性质3：</p><p>每一个二叉树，记边数为B。</p><p><img src="/Images/image-20240215152429945.png" alt="image-20240215152429945"></p><p>联立两个式子，n = 2 * n2 + n1 + 1，其中n = n0 + n1 + n2</p><p>化简得 n0 = n2 + 1</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>根据性质二，一颗深度为k且有2的k次方 - 1 个结点的二叉树称为满二叉树</p><p>特点：每一层的结点数都是最大结点数，叶子结点全部在最底层（同一层）</p><p>对满二叉树结点位置进行编号，从根结点开始，从上到下，从左到右，每一个结点位置都有元素。</p><p><img src="/Images/image-20240215153337883.png" alt="image-20240215153337883"></p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>深度为k的具有 n 个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，成为完全二叉树。</p><p><img src="/Images/image-20240215154257860.png" alt="image-20240215154257860"></p><p>叶子只可能分布在层次最大的两层上。对于任一结点，如果其右子树的最大层次为 i ，则其左子树的最大层次必定为 i 或 i + 1 。</p><h3 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h3><p>性质4：具有n个结点的完全二叉树深度为[log2 n] + 1 （[ ]是高斯函数）</p><p><img src="/Images/image-20240215162726370.png" alt="image-20240215162726370"></p><p>性质4表明了完全二叉树结点数n与深度k的关系</p><p>性质5：如图，阐述了完全二叉树中双亲结点编号与孩子结点编号之间的关系</p><p><img src="/Images/image-20240215163131554.png" alt="image-20240215163131554"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame_wp</title>
      <link href="/2024/02/14/hagme-week2/"/>
      <url>/2024/02/14/hagme-week2/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-babyre"><a href="#0x01-babyre" class="headerlink" title="0x01 babyre"></a>0x01 babyre</h2><p>这个程序的关键在于几个线程的调用，和key的值。</p><p>首先key 的值在主函数的异或前是先赋值过的，不是原本静态存储的那个值，可以通过动调得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x77, 0x74, 0x78, 0x66, 0x65, 0x69</span><br></pre></td></tr></table></figure><p>然后关于这个线程的调用我也不是很懂，大概就是创建四个线程，每个线程里存有各自的函数的地址，然后按顺序依次调用，调用了一个线程后该线程对应的信号量减一（wait），下一个线程的信号量加一（post），这时就调用下一个线程的函数，依次循环，直到全局变量 i 为31停止，最后退出线程，四个线程总共循环8次（按理来说，因为flag是32位，全部加密一轮需要8*4=32次），按照这个思路写出逆向脚本，结果也是没问题的。</p><p>一开始做题的时候是通过调试发现四个线程一轮只调用一次，于是猜测是逐个逐个进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">__int32 enc[<span class="number">33</span>] = &#123;<span class="number">12052</span>,<span class="number">78</span>,<span class="number">20467</span>,<span class="number">109</span>,<span class="number">13016</span>,<span class="number">109</span>,<span class="number">27467</span>,<span class="number">-110</span>,</span><br><span class="line">        <span class="number">9807</span>,<span class="number">91</span>,<span class="number">21243</span>,<span class="number">-100</span>,<span class="number">11121</span>,<span class="number">20</span>,<span class="number">10863</span>,<span class="number">-107</span>,<span class="number">10490</span>,<span class="number">29</span>,<span class="number">10633</span>,<span class="number">-101</span>,</span><br><span class="line">        <span class="number">10420</span>,<span class="number">78</span>,<span class="number">17670</span>,<span class="number">-38</span>,<span class="number">6011</span>,<span class="number">-4</span>,<span class="number">16590</span>,<span class="number">125</span>,<span class="number">10723</span>,</span><br><span class="line">        <span class="number">15</span>,<span class="number">7953</span>,<span class="number">255</span> , <span class="number">250</span>&#125;;</span><br><span class="line">__int32 key[<span class="number">6</span>] = &#123;<span class="number">0x77</span>, <span class="number">0x74</span>, <span class="number">0x78</span>, <span class="number">0x66</span>, <span class="number">0x65</span>, <span class="number">0x69</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        enc[i] ^= (enc[i + <span class="number">1</span>] - key[(i + <span class="number">1</span>) % <span class="number">6</span>]);</span><br><span class="line">        i--;</span><br><span class="line">        enc[i] /= (enc[i + <span class="number">1</span>] + key[(i + <span class="number">1</span>) % <span class="number">6</span>]);</span><br><span class="line">        i--;</span><br><span class="line">        enc[i] += (key[(i + <span class="number">1</span>) % <span class="number">6</span>] ^ enc[i + <span class="number">1</span>]);</span><br><span class="line">        i--;</span><br><span class="line">        enc[i] -= (key[(i + <span class="number">1</span>) % <span class="number">6</span>] * enc[i + <span class="number">1</span>]);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,enc[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hgame{you_are_3o_c1ever2_3Olve!}</p><h2 id="0x02-ezcpp"><a href="#0x02-ezcpp" class="headerlink" title="0x02 ezcpp"></a>0x02 ezcpp</h2><p>一进去看了一眼就是TEA加密，不过这个TEA加密和普通的不太一样，他是依次分别取input（char类型）（用户输入值）的下标为0和4,1和5,2和6,3和7的首地址，然依此地址为最低位，向后取3个char值和自己本身拼合成32位的int数，比如0x11,0x22，0x33，0x44，就以小端序存储成0x44332211。</p><p>在这个加密里，取flag[0]的地址解引用，然后传入某个变量v，其实就是将flag0,1,2,3 的值以上述方式拼合成int类型然后传入变量v，知道这个后，其实不难发现该加密只加密了前11个字符（因为以flag[7]的地址加密，最多拼合7到10，总共4个字符成int，也就是最多加密到flag[10]也就是第11的字符）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//密文flag</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">32</span>] = &#123;<span class="number">0x88</span>, <span class="number">0x6A</span>, <span class="number">0xB0</span>, <span class="number">0xC9</span>, <span class="number">0xAD</span>, <span class="number">0xF1</span>, <span class="number">0x33</span>, <span class="number">0x33</span>, <span class="number">0x94</span>, <span class="number">0x74</span>, </span><br><span class="line">                <span class="number">0xB5</span>, <span class="number">0x69</span>, <span class="number">0x73</span>, <span class="number">0x5F</span>, <span class="number">0x30</span>, <span class="number">0x62</span>, <span class="number">0x4A</span>, <span class="number">0x33</span>, <span class="number">0x63</span>, <span class="number">0x54</span>, </span><br><span class="line">                <span class="number">0x5F</span>, <span class="number">0x30</span>, <span class="number">0x72</span>, <span class="number">0x31</span>, <span class="number">0x65</span>, <span class="number">0x6E</span>, <span class="number">0x54</span>, <span class="number">0x65</span>, <span class="number">0x44</span>, <span class="number">0x3F</span>, </span><br><span class="line">                <span class="number">0x21</span>, <span class="number">0x7D</span>&#125;;</span><br><span class="line"><span class="type">int</span> v20,v21,v18,v19,v10,v9,v5,v6,sum,delta;</span><br><span class="line"><span class="comment">//四个密钥</span></span><br><span class="line"><span class="type">int</span> key1 = <span class="number">2341</span>, key2 = <span class="number">1234</span>, key3 = <span class="number">4123</span>, key4 = <span class="number">3412</span>;</span><br><span class="line"><span class="comment">//将int类型拆分成字符的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    flag[i] = v &amp; <span class="number">0xff</span>;</span><br><span class="line">    flag[i+<span class="number">1</span>] = (v&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    flag[i+<span class="number">2</span>] = (v&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    flag[i+<span class="number">3</span>] = (v&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//按照原加密的顺序逆过来</span></span><br><span class="line">    delta = <span class="number">-559038737</span>;</span><br><span class="line">    <span class="comment">//first</span></span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    <span class="comment">//将字符拼合成int的整数</span></span><br><span class="line">    v20 = flag[<span class="number">3</span>]|(flag[<span class="number">4</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">5</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">6</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    v21 = flag[<span class="number">7</span>]|(flag[<span class="number">8</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">9</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">10</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="comment">//TEA加密的部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        v21 -= (sum + v20) ^ (key3 + <span class="number">32</span> * v20) ^ (key4 + <span class="number">16</span> * v20);</span><br><span class="line">        v20 -= (sum + v21) ^ (key1 + <span class="number">32</span> * v21) ^ (key2 + <span class="number">16</span> * v21);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用函数将int拆分成原来的字符</span></span><br><span class="line">    <span class="built_in">trans</span>(v20,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">trans</span>(v21,<span class="number">7</span>);</span><br><span class="line">    <span class="comment">//second</span></span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    v18 = flag[<span class="number">2</span>]|(flag[<span class="number">3</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">4</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">5</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    v19 = flag[<span class="number">6</span>]|(flag[<span class="number">7</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">8</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">9</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        v19 -= (sum + v18) ^ (key3 + <span class="number">32</span> * v18) ^ (key4 + <span class="number">16</span> * v18);</span><br><span class="line">        v18 -= (sum + v19) ^ (key1 + <span class="number">32</span> * v19) ^ (key2 + <span class="number">16</span> * v19);  </span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">trans</span>(v18,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">trans</span>(v19,<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//third</span></span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    v9 = flag[<span class="number">1</span>]|(flag[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">3</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">4</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    v10 = flag[<span class="number">5</span>]|(flag[<span class="number">6</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">7</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">8</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        v10 -= (sum + v9) ^ (key3 + <span class="number">32</span> * v9) ^ (key4 + <span class="number">16</span> * v9);</span><br><span class="line">        v9 -= (sum + v10) ^ (key1 + <span class="number">32</span> * v10) ^ (key2 + <span class="number">16</span> * v10);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">trans</span>(v9,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">trans</span>(v10,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//forth</span></span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    v5 = flag[<span class="number">0</span>]|(flag[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">3</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    v6 = flag[<span class="number">4</span>]|(flag[<span class="number">5</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">6</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">7</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        v6 -= (sum + v5) ^ (<span class="number">16</span> * v5 + key4) ^ (<span class="number">32</span> * v5 + key3);</span><br><span class="line">        v5 -= (sum + v6) ^ (<span class="number">16</span> * v6 + key2) ^ (<span class="number">32</span> * v6 + key1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">trans</span>(v5,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">trans</span>(v6,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//print</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hgame&#123;#Cpp_is_0bJ3cT_0r1enTeD?!&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-arithmetic"><a href="#0x03-arithmetic" class="headerlink" title="0x03 arithmetic"></a>0x03 arithmetic</h2><p>先upx脱壳，由于被改了特征值导致没法用工具upx -d脱壳，用010editor打开，然后修改，将3E0h行的首四个十六进制数改成55 50  58 21，对应字符UPX！，若没有这个特征值将无法upx -d脱壳。</p><p><a href="https://blog.csdn.net/whatday/article/details/99709317">关于upx加壳的文章</a></p><p>之后便是求解数塔问题了，根据提示是求最大路径和，左1右2，在大佬朋友的帮助下也是把脚本弄出来了。</p><p>out里面存着数塔的数据，500行，粘贴到崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//dp数塔</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//存放着最大路径</span></span><br><span class="line"><span class="type">int</span> step[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//原数塔</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//读取数塔</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">b[i][j] = a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算最大和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">a[i][j] += <span class="built_in">max</span>(a[i + <span class="number">1</span>][j], a[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最长路径</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//根据a数组来求，a数组是已经被修改过的数组，每一层的值是从底层开始求和的最优解</span></span><br><span class="line">step[<span class="number">0</span>] = b[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="comment">//若左边大时</span></span><br><span class="line"><span class="keyword">if</span> (a[x + <span class="number">1</span>][y] &gt; a[x + <span class="number">1</span>][y + <span class="number">1</span>])&#123;</span><br><span class="line">step[i + <span class="number">1</span>] = b[x + <span class="number">1</span>][y];</span><br><span class="line">x++;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右边的数据较大时</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">step[i + <span class="number">1</span>] = b[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出1，2串后，再去在线网站md5加密一下就是flag值了</p><p><a href="https://www.cmd5.org/">在线md5加密解密网站</a></p><p>hgame{934f7f68145038b3b81482b3d9f3a355}</p><h2 id="0x04-findme"><a href="#0x04-findme" class="headerlink" title="0x04 findme"></a>0x04 findme</h2><p>文件用ida打开，两个fake_flag，然后就不知道该怎么做了，经过式神的hint，才知道put（buffer）的端倪。</p><p>上网查MZ，出现dos头和pe文件等的东西，可以找这篇文件了解一下，讲的很好：<a href="https://www.cnblogs.com/liert/p/17089779.html">PE文件详解</a></p><p>用010editor打开文件，果不其然，文件的前面果然有mz头等数据文件</p><p><img src="/Images/image-20240217012122559.png" alt="image-20240217012122559"></p><p>记住这些东西对接下来的逆向有很大的帮助。</p><p>上文提到buffer，从这个地址开始，有M…Z等字符，猜测是把一个可执行PE文件用某些方式藏在了数据段里，在010editor里查找4D 00 00 00 5A 00 00 00，果不其然，确实有这样一个东西。</p><p><img src="/Images/image-20240217012417034.png" alt="image-20240217012417034"></p><p>而且我惊喜地发现，这些数据文件竟然就是dos头的那些数据，只不过把原本8位的数据用32位的方式存储了，也就是这里显示出来的，一个有用十六进制数再加6个0。从上往下，搜寻一下这种存储方式的所有数据，把他们全部复制到新的文件里（注意要复制直到没有这种存储规则的数据），我这里命名为 1 。（随便名的），接下来就是用个脚本删去这些无意义的00 00 00了。</p><p>由于不会写修改二进制文件的脚本，我干脆用python把他读取出来，然后再把读出来的文件粘贴到一个十六进制文本文件里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\28382\Desktop\1&quot;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">        <span class="comment">#用这个方法筛掉00 00 00</span></span><br><span class="line">        <span class="keyword">if</span> cnt % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])</span><br><span class="line">        cnt += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行后的十六进制数直接粘贴到010editor里新建的十六进制文本文件就好了。</p><p>注意：粘贴十六进制数要用shift+ctrl+V，不然就会粘贴成文本</p><p>然后保存，用die查一下文件类型，</p><p><img src="/Images/image-20240217013008652.png" alt="image-20240217013008652"></p><p>真是非常amazing啊，变成了应该PE文件，这下就可以用ida开始逆向了。</p><p>打开后去除一堆花指令，（这里只有jz和jnz），然后f5看看伪代码。有两个函数，看着像是rc4加密。</p><p>直到我发现有负数下标的数组，我就知道这东西不简单，</p><p><img src="/Images/51bb215441e3538249c21cd3da60511.png" alt="51bb215441e3538249c21cd3da60511"></p><p>以input的首地址为基准，负数代表向后取地址，调试后发现input后面存放的便是key数组，由此推断result的取值和你input什么东西是没有任何关系的，因为result 的值都来自于key数组，而且向后取地址的多少也取决于key，也就是这个-(v4+ key[v1]) 的值，只和key数组有关系。动调把result 的值都跑出来，然后用enc减去他就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> enc[<span class="number">32</span>] = &#123;<span class="number">0x7D</span>, <span class="number">0x2B</span>, <span class="number">0x43</span>, <span class="number">0xA9</span>, <span class="number">0xB9</span>, <span class="number">0x6B</span>, <span class="number">0x93</span>, <span class="number">0x2D</span>, <span class="number">0x9A</span>, <span class="number">0xD0</span>,</span><br><span class="line">       <span class="number">0x48</span>, <span class="number">0xC8</span>, <span class="number">0xEB</span>, <span class="number">0x51</span>, <span class="number">0x59</span>, <span class="number">0xE9</span>, <span class="number">0x74</span>, <span class="number">0x68</span>, <span class="number">0x8A</span>, <span class="number">0x45</span>,</span><br><span class="line">       <span class="number">0x6B</span>, <span class="number">0xBA</span>, <span class="number">0xA7</span>, <span class="number">0x16</span>, <span class="number">0xF1</span>, <span class="number">0x10</span>, <span class="number">0x74</span>, <span class="number">0xD5</span>, <span class="number">0x41</span>, <span class="number">0x3C</span>,</span><br><span class="line">       <span class="number">0x67</span>, <span class="number">0x7D</span>&#125;;</span><br><span class="line"><span class="type">int</span> result[<span class="number">32</span>] = &#123;<span class="number">0x15</span>,<span class="number">0xC4</span>,<span class="number">0xe2</span>,<span class="number">0x3c</span>,<span class="number">0x54</span>,<span class="number">0xf0</span>,<span class="number">0x4d</span>,<span class="number">0xc1</span>,</span><br><span class="line"><span class="number">0x6a</span>,<span class="number">0x59</span>,<span class="number">0x15</span>,<span class="number">0x56</span>,<span class="number">0x78</span>,<span class="number">0xf2</span>,<span class="number">0x18</span>,<span class="number">0x77</span>,<span class="number">0x41</span>,<span class="number">0x09</span>,</span><br><span class="line"><span class="number">0x34</span>,<span class="number">0xe0</span>,<span class="number">0xf9</span>,<span class="number">0x41</span>,<span class="number">0x48</span>,<span class="number">0xb0</span>,<span class="number">0x7f</span>,<span class="number">0xdc</span>,<span class="number">0xd</span>,<span class="number">0x63</span>,<span class="number">0xe0</span>,</span><br><span class="line"><span class="number">0xce</span>,<span class="number">0xf3</span>,<span class="number">0x0</span>&#125;;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">temp = enc[i] - result[i];</span><br><span class="line"><span class="keyword">if</span>(temp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">temp += <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hgame&#123;Fl0w3rs_Ar3_Very_fr4grant&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x05-mystery"><a href="#0x05-mystery" class="headerlink" title="0x05 mystery"></a>0x05 mystery</h2><p>这题一打开就发现是个RC4加密。</p><p><img src="/Images/image-20240222132959481.png" alt="image-20240222132959481"></p><p>这里的key实际上被修改过，按x查找引用，</p><p><img src="/Images/image-20240222133036979.png" alt="image-20240222133036979"></p><p>这些全都不管，反正大概知道这么个事情，然后直接点开sub_1500 的加密函数，和rc4相差的地方在于最后一步是减法而不是异或，原理一样，直接开虚拟机动调把每一轮的result跑出来，然后直接和密文相加就能得到flag了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">result = [<span class="number">0x18</span>,<span class="number">0x25</span>,<span class="number">0x29</span>,<span class="number">0x20</span>,<span class="number">0x19</span>,</span><br><span class="line">          <span class="number">0x27</span>,<span class="number">0xb9</span>,<span class="number">0xc9</span>,<span class="number">0x34</span>,<span class="number">0xc7</span>,</span><br><span class="line">          <span class="number">0x71</span>,<span class="number">0xc9</span>,<span class="number">0xac</span>,<span class="number">0x17</span>,<span class="number">0xb4</span>,</span><br><span class="line">          <span class="number">0x1e</span>,<span class="number">0xe5</span>,<span class="number">0xe9</span>,<span class="number">0xfc</span>,<span class="number">0x2a</span>,</span><br><span class="line">          <span class="number">0x4a</span>,<span class="number">0x01</span>,<span class="number">0xea</span>,<span class="number">0x79</span>,<span class="number">0xc7</span>,</span><br><span class="line">          <span class="number">0x82</span>,<span class="number">0xfe</span>,<span class="number">0x51</span>,<span class="number">0xe7</span>,<span class="number">0xb1</span>,</span><br><span class="line">          <span class="number">0xae</span>,<span class="number">0x28</span>]</span><br><span class="line">enc = [<span class="number">0x50</span>, <span class="number">0x42</span>, <span class="number">0x38</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>, <span class="number">0x54</span>, <span class="number">0x90</span>, <span class="number">0x6F</span>, <span class="number">0xFE</span>, <span class="number">0x6F</span>,</span><br><span class="line">       <span class="number">0xBC</span>, <span class="number">0x69</span>, <span class="number">0xB9</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x16</span>, <span class="number">0x8F</span>, <span class="number">0x44</span>, <span class="number">0x38</span>, <span class="number">0x4A</span>,</span><br><span class="line">       <span class="number">0xEF</span>, <span class="number">0x37</span>, <span class="number">0x43</span>, <span class="number">0xC0</span>, <span class="number">0xA2</span>, <span class="number">0xB6</span>, <span class="number">0x34</span>, <span class="number">0x2C</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">28</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>((enc[i] + result[i]) &amp; <span class="number">0xff</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#hgame&#123;I826-2e904t-4t98-9i82&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x06-change"><a href="#0x06-change" class="headerlink" title="0x06 change"></a>0x06 change</h2><p>其实这题挺简单的，但是加了很多混淆视听的东西。</p><p><img src="/Images/image-20240226163834401.png" alt="image-20240226163834401"></p><p>题目里有大量的这种函数，一开始看着懵懵的，后面调试才发现这是一个取地址的函数，第一个参数是地址，第二个参数是偏移量，返回偏移后的地址，实际上就是一个数组enc[i]。</p><p><img src="/Images/image-20240226164002861.png" alt="image-20240226164002861" style="zoom: 80%;" /></p><p>加密函数里也一堆这种逻辑的函数，这里简化后就是分别取input[i]和key[i%key_len]，然后进去beep加密，对，按理来说应该是这样的，不过不知道为什么，这个beep函数里面调用的那个函数里面啥也没有，静态上是一个变量，没有被赋值。这里猜测是使用了函数指针，在之前给这个beep里面的变量赋值了一个函数指针，向上查找还真有，这里的sub_7FF7A…的函数，点进去，将传入的函数指针，也就是这个sub…443650，赋值给了beep里面的变量，然后通过函数指针调用这个加密函数。</p><p><img src="/Images/image-20240226164656792.png" alt="image-20240226164656792"></p><p>点进sub…443650就能发现是什么了，另外一个是a2 ^ a1，没有加10，判断一下i的奇偶就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">0x13</span>, <span class="number">0x0A</span>, <span class="number">0x5D</span>, <span class="number">0x1C</span>, <span class="number">0x0E</span>, <span class="number">0x08</span>, <span class="number">0x23</span>, <span class="number">0x06</span>, <span class="number">0x0B</span>, <span class="number">0x4B</span>,</span><br><span class="line">       <span class="number">0x38</span>, <span class="number">0x22</span>, <span class="number">0x0D</span>, <span class="number">0x1C</span>, <span class="number">0x48</span>, <span class="number">0x0C</span>, <span class="number">0x66</span>, <span class="number">0x15</span>, <span class="number">0x48</span>, <span class="number">0x1B</span>,</span><br><span class="line">       <span class="number">0x0D</span>, <span class="number">0x0E</span>, <span class="number">0x10</span>, <span class="number">0x4F</span>]</span><br><span class="line">key = <span class="string">&quot;am2qasl&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">       <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">              enc[i] -= <span class="number">10</span></span><br><span class="line">       flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[i%<span class="number">7</span>])^enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#hgame&#123;ugly_Cpp_and_hook&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>picoCTF</title>
      <link href="/2024/02/14/picoCTF/"/>
      <url>/2024/02/14/picoCTF/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-packer"><a href="#0x01-packer" class="headerlink" title="0x01 packer"></a>0x01 packer</h2><p>elf的upx打包，我用windows的upx解不出来，开了个虚拟机在linux下就可以解包了，一开始就有flag串，十六进制转一下字符串就得到了。</p><p>picoCTF{U9X_UnP4ck1N6_B1n4Ri3S_1a5a3f39}</p><h2 id="0x02-FactCheck"><a href="#0x02-FactCheck" class="headerlink" title="0x02 FactCheck"></a>0x02 FactCheck</h2><p>cpp程序，反编译出来很多很长，看了一下逻辑就是创建很多个字符变量，然后根据最后的逻辑按一定顺序的将这些字符append到半成品flag上，耐心看看就好了。</p><p>picoCTF{wELF_d0N3_mate_2394047a}</p><h2 id="0x03-WinAntiDbg0x100"><a href="#0x03-WinAntiDbg0x100" class="headerlink" title="0x03 WinAntiDbg0x100"></a>0x03 WinAntiDbg0x100</h2><p>介绍说是一个反调试，点进去我感觉是这个阻碍我调试了，被调试时这个函数返回result=1，外部有个if接收了这个1后会导致程序退出，我们单步调试时在外部那个if前停下，然后修改ZF标志位，就能使程序跑向解密的二进制文件的代码了，直接查看内存里的密文就能得到flag。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314112708882.png" alt="image-20240314112708882"></p><p>picoCTF{d3bug_for_th3_Win_0x100_e70398c9}</p><h2 id="0x04-Classic-Crackme-0x100"><a href="#0x04-Classic-Crackme-0x100" class="headerlink" title="0x04 Classic Crackme 0x100"></a>0x04 Classic Crackme 0x100</h2><p>elf程序用ida打开后是一串50个字符串的有与运算和位移运算的加密代码，总共加密三轮，每轮算出一个参数，我在脚本里命名为temp，是random2和secret3得出来的，然后每轮明文加这个temp再模26，我在脚本里直接写成加3倍temp模26，等价的。</p><p>代码里用0-25代替a-z，得先把密文转化成数字格式，最后再转化成字母格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enc = <span class="string">&quot;mpknnphjngbhgzydttvkahppevhkmpwgdzxsykkokriepfnrdm&quot;</span></span><br><span class="line">enc1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc1.append(<span class="built_in">ord</span>(enc[i])-<span class="number">97</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">secret1 = <span class="number">0x55</span></span><br><span class="line">secret2 = <span class="number">0x33</span></span><br><span class="line">secret3 = <span class="number">0xF</span></span><br><span class="line">fix = <span class="number">97</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc1)):</span><br><span class="line">    random1 = (secret1 &amp; (j % <span class="number">255</span>)) + (secret1 &amp; ((j % <span class="number">255</span>) &gt;&gt; <span class="number">1</span>))</span><br><span class="line">    random2 = (random1 &amp; secret2) + (secret2 &amp; (random1 &gt;&gt; <span class="number">2</span>))</span><br><span class="line">    temp = (random2 &amp; secret3) + (secret3 &amp; (random2 &gt;&gt; <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">3</span>*temp) % <span class="number">26</span> == enc1[j]:</span><br><span class="line">            flag += <span class="built_in">chr</span>(k+<span class="number">97</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#mmhhkjbakavyaqprqnpbuygdymyyddkratrjsbbceizsgtbcxd</span></span><br></pre></td></tr></table></figure><p>开个kali虚拟机连接靶机，就能得到flag了。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/e7addc20847c375ec7ee3b052729983.png" alt="e7addc20847c375ec7ee3b052729983"></p><p>picoCTF{s0lv3_angry_symb0ls_ddcc130f}</p><h2 id="0x05-weirdSnake"><a href="#0x05-weirdSnake" class="headerlink" title="0x05 weirdSnake"></a>0x05 weirdSnake</h2><p>这题打开是一个二进制文件，然后用010editor打开发现是python字节码，python字节码类似于在python的虚拟机里执行的代码，各种操作码的详情可以见<a href="https://docs.python.org/zh-cn/3.8/library/dis.html">中文官网</a></p><p>LOAD_CONST是入栈，然后STORE_NAME是把栈顶元素赋值给key_str，LOAD _NAME是把key_str入栈。分析下图的过程，尝试翻译成简单的过程。（这里的BINARY_ADD均指str重载的加法，即字符串拼接）</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314201406973.png" alt="image-20240314201406973" style="zoom: 67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&quot;t_Jo3&quot;</span> </span><br><span class="line">enc = [<span class="number">4</span>,<span class="number">54</span>,<span class="number">41</span>,<span class="number">0</span>,<span class="number">112</span>,<span class="number">32</span>,<span class="number">25</span>,<span class="number">49</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">57</span>,<span class="number">32</span>,<span class="number">108</span>,<span class="number">23</span>,<span class="number">48</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">70</span>,<span class="number">7</span>,</span><br><span class="line">       <span class="number">110</span>,<span class="number">36</span>,<span class="number">8</span>,<span class="number">108</span>,<span class="number">7</span>,<span class="number">49</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">86</span>,<span class="number">43</span>,<span class="number">106</span>,<span class="number">123</span>,<span class="number">89</span>,<span class="number">87</span>,<span class="number">18</span>,<span class="number">62</span>,<span class="number">47</span>,<span class="number">10</span>,<span class="number">78</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">       flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[i % <span class="number">5</span>]) ^ enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#picoCTF&#123;N0t_sO_coNfus1ng_sn@ke_516dfaee&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x06-WinAntiDbg0x200"><a href="#0x06-WinAntiDbg0x200" class="headerlink" title="0x06 WinAntiDbg0x200"></a>0x06 WinAntiDbg0x200</h2><p>和第一题dbg一样的做法，直接调试进去就好了。</p><p>picoCTF{0x200_debug_f0r_Win_c6db2768}</p><h2 id="0x07-WinAntiDbg0x300"><a href="#0x07-WinAntiDbg0x300" class="headerlink" title="0x07 WinAntiDbg0x300"></a>0x07 WinAntiDbg0x300</h2><p>升级版，进入主程序，在开头处下个断点一步步调试，进如图下面的函数，f7进入，这个是判断你有没有用管理员启动该程序的函数，进去后通过改ZF标志位绕过检测。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314194216397.png" alt="image-20240314194216397" style="zoom: 50%;" /></p><p>接着往下调试，这里有个创建线程的函数，进去下个断点，f9跑进去。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314194347174.png" alt="image-20240314194347174" style="zoom:50%;" /></p><p>进去后发现下面有个You got flag的字符串，直接跑进去！！！！！看看图形化界面就弹出了flag窗口。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314194444698.png" alt="image-20240314194444698"></p><p>picoCTF{Wind0ws_antid3bg_0x300_09b94ee8}</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类模板</title>
      <link href="/2024/02/08/%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/02/08/%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h2><p>和函数模板的写法一样，在template<class T>的下一行紧跟一个类，就是类模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">typeAge</span>,<span class="keyword">class</span> <span class="title class_">typeName</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(typeAge age,typeName name)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        typeAge _age;</span><br><span class="line">        typeName _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;<span class="type">int</span>, string&gt; <span class="title">p</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板特点"><a href="#类模板特点" class="headerlink" title="类模板特点"></a>类模板特点</h2><p>类模板没有自动类型推导的使用方式。</p><p>类模板在模板参数列表中可以有默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">typeAge</span>,<span class="keyword">class</span> <span class="title class_">typeName</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(typeAge age,typeName name = string)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        typeAge _age;</span><br><span class="line">        typeName _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中，name的默认参数是string。（默认参数的设置和函数默认参数的规则类似，默认参数必须要在非默认参数后面出现）</p><h2 id="类模板中成员函数的创建时机"><a href="#类模板中成员函数的创建时机" class="headerlink" title="类模板中成员函数的创建时机"></a>类模板中成员函数的创建时机</h2><p>类模板中的成员函数在调用时才创建，一开始无法确定成员变量的数据类型，只有当调用了类模板后才能确定成员变量的数据类型，类模板中的成员函数在这个时机，才创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T obj;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">            obj.<span class="built_in">showPerson</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test&lt;Person&gt; m;</span><br><span class="line">    <span class="comment">//这个时候才创建fun()</span></span><br><span class="line">    m.<span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出show</span></span><br></pre></td></tr></table></figure><p>例子中类模板class中的fun( )只有当接收了T的数据类型才能创建，若数据类型T不是Person，无法调用fun( )函数，还会报错。创建的时机是被调用后。</p><h2 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h2><p>一共有三种传入方式：</p><p>1、指定传入的类型： 直接显示对象的数据类型</p><p>事先定义好函数要传入的类型，如这里的<int，string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">test</span>(T1 age, T2 name)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        T1 age;</span><br><span class="line">        T2 name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">(test&lt;<span class="type">int</span>, string&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">test&lt;<span class="type">int</span>, string&gt; <span class="title">person</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showfunc</span>(person);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、参数模板化：将对象中的参数变为模板进行传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">(test&lt;T1, T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、整个类模板化：将这个对象类型 模板化进行传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">(T &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种比较实用</p><h2 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h2><p>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</p><p>如果不指定，编译器无法给子类分配内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指定父类里T的类型为int</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想灵活指定出父类中T的类型，子类也需变为类模板‘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指定父类里T的类型为int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&lt;T2&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T1 one;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里的int经过子类T2传递到父类的T</span></span><br><span class="line">    <span class="comment">//父类char m，子类中int one</span></span><br><span class="line">    Son&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h2><p>假设有一个类Person</p><p>构造函数类外实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1,T2&gt;::<span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数的类外实现（假设Person类存在）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1,T2&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h2><p>讲.h和.cpp 中的内容写到一起，再将后缀名改为.hpp（约定俗成的）</p><p>将类模板和调用编写到一起，否则会导致链接不到类模板中的成员函数（因为该函数是在被调用时才生成）</p><p>解决方法：将声明和实现写到同一个.hpp文件中。</p><h2 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h2><p>全局函数 类内实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//类内直接用friend关键字声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1,T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;p.name&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;p.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        T1 name;</span><br><span class="line">        T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局函数 类外实现（比较复杂）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提前让编译器知道Person类的存在</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="comment">//类外实现全局函数（模板函数）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="function"><span class="keyword">class</span> T2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1,T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;p.name&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;p.age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//加空模板参数列表让编译器知道这是一个模板函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> printPerson&lt;&gt;(Person&lt;T1,T2&gt; &amp;p)</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        T1 name;</span><br><span class="line">        T2 age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：建议写类内实现</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数模板</title>
      <link href="/2024/02/08/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/02/08/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h2><p>模板就是建立通用的模具，大大提高复用性。</p><p>模板不可以直接使用，他只是一个框架，模板的通用并不是万能的。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板的作用：建立一个通用函数，其返回值和形参类型可以不具体制定，用一个虚拟的类型来代表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><p>template ：声明创建模板</p><p>typename：表示其后面的符号是一种数据类型，可以用class替代</p><p>T ：通用的数据类型，名称可以替换，通常大写字母</p><p>写一个swap的函数模板</p><p>1、自动推导类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">MySwap</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自动推导类型</span></span><br></pre></td></tr></table></figure><p>2、显示指定类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">MySwap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示指定类型</span></span><br></pre></td></tr></table></figure><h2 id="函数模板的注意事项"><a href="#函数模板的注意事项" class="headerlink" title="函数模板的注意事项"></a>函数模板的注意事项</h2><p>使用自动类型推导时，必须推导出一致的数据类型T,才可以使用，T的数据类型只有一种</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//错误的案例!!!!!!!</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="built_in">fun</span>(a,b);</span><br><span class="line">    <span class="comment">//T的数据类型不一致!!!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板必须要确定出T的数据类型，才可以使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里必须要确定出T的数据类型，由于不传入参数没法自动类型推导</span></span><br><span class="line"><span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h2><p>普通函数与函数模板区别：</p><p>​    普通函数调用时可以发生自动类型转换(隐式类型转换)</p><p>​    函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</p><p>​    如果利用显示指定类型的方式，可以发生隐式类型转换</p><p>（有关隐式类型转化的异同）</p><h2 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h2><p>1、如果函数模板和普通函数都可以调用，优先调用普通函数</p><p>2、可以通过空模板参数列表 强制调用 函数模板</p><p>通过空模板  &lt;&gt;  实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用模板&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用普通&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//强制优先调用模板函数</span></span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    Print&lt;&gt;(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、函数模板可以发生函数重载</p><p>4、如果函数模板可以产生更好的匹配，优先调用函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;muban&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;putong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//强制优先调用模板函数</span></span><br><span class="line">    <span class="type">char</span> a,b;</span><br><span class="line">    <span class="built_in">Print</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出muban</span></span><br></pre></td></tr></table></figure><p>这里传入char类型，编译器优先调用模板，省去了类型转换的步骤。</p><p>注意：提供了函数模板后最好不要提供普通函数，否则容易出现二义性</p><h2 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h2><p>模板不是万能的，有些特定数据类型，需要用具体化方式做特殊实现</p><p>举个例子，写了一个bool类型的比较模板函数，当传入入int，double等的单个数据的数据类型时能正常使用，可是当传入自定义数据类型，如类时，模板无法正常使用，这时用具体化某个特定数据类型的版本实现代码，具体化会优先调用。</p><p>具体化，以template&lt;&gt;开头，通过名称来指出类型，优先于普通模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(<span class="type">int</span> age,string name)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> _age;</span><br><span class="line">        string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通用实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;a,Person &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习模板是为了在STL中能够运用系统提供的模板</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态和文件读写</title>
      <link href="/2024/02/08/%E5%A4%9A%E6%80%81%E5%92%8C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>/2024/02/08/%E5%A4%9A%E6%80%81%E5%92%8C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态是C++面向对象三大特效之一</p><h2 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h2><p>多态分为两类：</p><p>​    静态多态：如函数重载，运算符重载</p><p>​    动态多态：派生类和虚函数实现运行时多态</p><p>静态多态和动态多态的区别：</p><p>​    静态多态的函数地址早绑定，编译阶段确定函数地址</p><p>​    动态多态的函数地址晚绑定，运行阶段确定函数地址</p><p>补充：子类可以成为父类的引用，例如当一个函数传入父类的引用时，在调用函数时可以传入子类。</p><p>举个例子讲讲什么是动态多态，什么又是地址晚绑定。例如，当我们创建一个动物类（父类）时，在类内写了一个void函数void what( )，输出I am animal，这时我们再写一个子类猫，在猫类内也写一个同名的函数输出I am cat。这时写一个传入父类引用的函数，调用函数时传入子类猫。正常来说，此时函数会输出I am animal，这个属于静态多态，函数what 的地址早在编译阶段就绑定animal.what( )里的I am animal了。</p><p>我们自然是想要输出I am cat 的，这时候就要用动态多态，让地址晚绑定，在运行阶段时绑定地址，根据具体的子类执行对应的函数。</p><p>要满足动态多态的条件有：</p><p>有继承关系    </p><p>子类重写父类的虚函数（函数返回值，函数名，参数列表都完全相同）</p><p>父类的指针或者引用执行子类对象，例如例子里的cat子类对象，由父类的引用对象animal执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//加上virtual关键字</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am animal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//子类的重写函数的virtual可写可不写</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am cat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowWhat</span><span class="params">(Animal &amp;animal)</span></span>&#123;</span><br><span class="line">    animal.<span class="built_in">what</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">ShowWhat</span>(cat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I am cat</p><h2 id="多态的原理剖析"><a href="#多态的原理剖析" class="headerlink" title="多态的原理剖析"></a>多态的原理剖析</h2><p><img src="/Images/image-20240207234523854.png" alt="image-20240207234523854"></p><p>如图，当类内定义虚函数时，会产生一个虚函数指针和虚函数表，指针指向表，子类会继承父类的虚函数指针，但是当子类重写父类虚函数时，子类的虚函数地址会覆盖继承下来的虚函数表里面的父类的虚函数地址，这时当父类的指针或引用指向子类对象时，会发生多态。若对象是cat（子类），vfptr（从父类继承下来的）就指向Cat类（子类）的vftable。</p><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类的重写的内容</p><p>因此可以将虚函数改为纯虚函数</p><p>纯虚函数语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名 (参数列表) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当类中有了纯虚函数，这个类称为抽象类，有以下特点：</p><p>​    无法实例化对象</p><p>​    子类必须重写抽象类中的纯虚函数，否则子类也属于抽象类</p><h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式 :  将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性：</p><p>​    可以解决父类指针释放子类对象</p><p>​    都需要有具体的函数实现</p><p>虚析构和纯虚析构区别：</p><p>​    如果是纯虚析构，该类属于抽象类，无法实例化对象</p><p>纯虚析构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animal::~<span class="built_in">Animal</span>()&#123;</span><br><span class="line">    <span class="comment">//纯虚析构函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Cat</span>(string name)&#123;</span><br><span class="line">            <span class="comment">//Cat构造函数</span></span><br><span class="line">            Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Cat is saying!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Cat</span>()&#123;</span><br><span class="line">            <span class="comment">//Cat的析构函数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> Name;</span><br><span class="line">                Name = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string *Name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虚析构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>()&#123;</span><br><span class="line">            <span class="comment">//虚析构调用</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Cat</span>(string name)&#123;</span><br><span class="line">            <span class="comment">//Cat构造函数</span></span><br><span class="line">            Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Cat is saying!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Cat</span>()&#123;</span><br><span class="line">            <span class="comment">//Cat的析构函数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> Name;</span><br><span class="line">                Name = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string *Name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态的案例"><a href="#多态的案例" class="headerlink" title="多态的案例"></a>多态的案例</h2><p>多态的优点：</p><p>​    代码组织结构清晰</p><p>​    可读性强</p><p>​    利于前期和后期的扩展以及维护</p><h3 id="案例1-计算机类"><a href="#案例1-计算机类" class="headerlink" title="案例1 计算机类"></a>案例1 计算机类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先实现一个计算机抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span>: <span class="keyword">public</span> Calculator&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num1 + num2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>: <span class="keyword">public</span> Calculator&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num1 - num2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以此类推，能一直扩展计算器的运算功能，以此创建一个对象试着计算一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现加法运算</span></span><br><span class="line">Calculator *ptr = <span class="keyword">new</span> Add;</span><br><span class="line">ptr-&gt;num1 = <span class="number">100</span>;</span><br><span class="line">ptr-&gt;num2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ptr-&gt;<span class="built_in">result</span>());</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"><span class="comment">//输出200</span></span><br></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过文件可以将数据持久化</p><p>C++中对文件操作需要包含头文件 <fstream></p><p>文件类型分为两种!：</p><p>​    文本文件：文件以文本的ASCII码形式存储在计算机中</p><p>​    二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p><p>操作文件的三大类：<br>    ofstream：写操作</p><p>​    ifstream：读操作</p><p>​    fstream：读写操作</p><h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建流对象</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>，打开方式);</span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;写入的数据&quot;</span>;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件打开方式"><a href="#文件打开方式" class="headerlink" title="文件打开方式"></a>文件打开方式</h3><p><img src="/Images/image-20240208014845434.png" alt="image-20240208014845434"></p><p>注意：文件打开方式可以配合使用，利用  |  操作符</p><p>例如：用二进制方式写文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::binary|ios::out</span><br></pre></td></tr></table></figure><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建流对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//打开文件并判断文件是否打开成功</span></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>，打开方式);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//读数据（四种方式）</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读数据的四种方式（介绍一下常见的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs,buf))&#123;</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs.<span class="built_in">getline</span>(buf, <span class="built_in">sizeof</span>(buf)))&#123;</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs&gt;&gt;buf)&#123;</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个一个读</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span>((c = ifs.<span class="built_in">get</span>()) != EOF)&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>打开方式要指定ios: :binary</p><h3 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h3><p>二进制方式写文件主要是利用流对象调用成员函数write</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>buffer指向内存中的一段存储空间，len是读取的字节数</p><h3 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h3><p>二进制方式读文件主要利用流对象调用成员函数read</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>beginCTF</title>
      <link href="/2024/02/06/beingCTF-WP/"/>
      <url>/2024/02/06/beingCTF-WP/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次不太好评价，感觉对我来说是降维打击，首先感谢队里的所有朋友们，是你们的陪伴和互助我才能坚持下去。</p><h2 id="0x01红白机"><a href="#0x01红白机" class="headerlink" title="0x01红白机"></a>0x01红白机</h2><p>看文件标题，猜测是6052汇编语言，作为上世纪的古老汇编，我自然是看不懂的，这里有个网址能运行<a href="https://codediy.github.io/nes-zh/easy6502/index.html">6052汇编</a></p><p>如果感兴趣还有教学，该博客对6052汇编的介绍还是有理有据的。</p><p><img src="/Images/ec51921f958fc86b6271cd70b5f3152.png" alt="ec51921f958fc86b6271cd70b5f3152"></p><p>flag{6502_I_LOVE_u}</p><h2 id="0x02xor"><a href="#0x02xor" class="headerlink" title="0x02xor"></a>0x02xor</h2><p>出题人说是简单的异或，我点进去一看一坨，不想看了，既然说是异或那就用异或试试看。</p><p><img src="/Images/f67244fb95a69b6dbc8707cf453fb9d.png" alt="f67244fb95a69b6dbc8707cf453fb9d"></p><p>找到这个极其可疑的字符串</p><p><img src="/Images/image-20240201132103590.png" alt="image-20240201132103590"></p><p>点进去打个断点调试，要你输入flag时，就把这串字符串输入进去，结果肯定是错的，但是由于异或的可逆性，这时候查看enc的值，就是正确的flag，手抄下来得到答案（偷懒取巧的做法，不可取:( ）</p><p><img src="/Images/image-20240201132331372.png" alt="image-20240201132331372"></p><p>flag{Virus_gonna_be_terminated!}</p><h2 id="0x03real-checkin-xor"><a href="#0x03real-checkin-xor" class="headerlink" title="0x03real checkin xor"></a>0x03real checkin xor</h2><p>借这又一道异或题记录一下静态做法，这题的函数相比之下就人性化许多了，一眼能看出加密过程</p><p>记录一下源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify_func</span>(<span class="params">ciper,key</span>):</span><br><span class="line">    encrypted = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ciper)):</span><br><span class="line">        encrypted.append(<span class="built_in">ord</span>(ciper[i])^<span class="built_in">ord</span>(key[i%<span class="built_in">len</span>(key)]))</span><br><span class="line">    <span class="keyword">return</span> encrypted</span><br><span class="line"></span><br><span class="line">secret = [<span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>, <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, <span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这是一个保险箱,你能输入相关的key来进行解密吗?&quot;</span>)</span><br><span class="line">input_line = <span class="built_in">input</span>(<span class="string">&quot;请输入key &gt; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> verify_func(input_line,<span class="string">&quot;ez_python_xor_reverse&quot;</span>) == secret:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码正确&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码错误&quot;</span>)</span><br></pre></td></tr></table></figure><p>根据这个verify_func函数，复制过来改一下，就能得到解密脚本了捏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">secret = [<span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>,</span><br><span class="line">          <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>,</span><br><span class="line">          <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, <span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>,</span><br><span class="line">          <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span>]</span><br><span class="line">key = <span class="string">&quot;ez_python_xor_reverse&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decry</span>(<span class="params">enc, key</span>):</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">        ans.append(enc[i] ^ <span class="built_in">ord</span>(key[i%<span class="built_in">len</span>(key)]))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> decry(secret ,key):</span><br><span class="line">    flag += <span class="built_in">chr</span>(i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>begin{3z_PY7hoN_r3V3rSE_For_TH3_Be9inNEr!}</p><h2 id="0x04俄语学习"><a href="#0x04俄语学习" class="headerlink" title="0x04俄语学习"></a>0x04俄语学习</h2><p>先找到主要的逻辑函数，观察后发现这个程序的主要逻辑是，先答对30道俄语题目然后输入flag并验证，为了便捷地动态调试这个程序，我先把前面三十道题目关于正误的判断全patch，变成答错能前进。</p><p><img src="/Images/image-20240202002450710.png" alt="image-20240202002450710"></p><p>if 判断里有个主要的函数，这个函数接收input（不是原本输入的），然后和encry后的enc比较，这里的enc能直接调试得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enc = [ <span class="number">0x38</span>, <span class="number">0x9A</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x5B</span>, <span class="number">0x89</span>, <span class="number">0xA5</span>, <span class="number">0xE6</span>, <span class="number">0xD0</span>, <span class="number">0xAB</span>,</span><br><span class="line">        <span class="number">0x42</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0xAB</span>, <span class="number">0x33</span>, <span class="number">0x2F</span>, <span class="number">0x98</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x2E</span>, <span class="number">0x59</span>, <span class="number">0x6D</span>, <span class="number">0x41</span>]</span><br></pre></td></tr></table></figure><p>然后按X查看input的引用</p><p><img src="/Images/image-20240202002718359.png" alt="image-20240202002718359"></p><p>发现这样一个函数，input是put和need_shuzu计算得到的（这些数组都被我改过名字），最后再encry。查找put 的引用不难发现是输入的用来验证的flag，encry函数的逻辑很简单，key可以直接调试得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">key = [ <span class="number">0x35</span>, <span class="number">0xF1</span>, <span class="number">0xDA</span>, <span class="number">0x19</span>, <span class="number">0x7A</span>, <span class="number">0xF6</span>, <span class="number">0x31</span>, <span class="number">0x9C</span>, <span class="number">0xD9</span>, <span class="number">0x2C</span>,</span><br><span class="line">  <span class="number">0xC1</span>, <span class="number">0xFC</span>, <span class="number">0xE2</span>, <span class="number">0xD8</span>, <span class="number">0x1D</span>, <span class="number">0x8D</span>, <span class="number">0x4F</span>, <span class="number">0x97</span>, <span class="number">0x81</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0xC0</span>, <span class="number">0xB8</span>, <span class="number">0x96</span>, <span class="number">0x27</span>, <span class="number">0xD5</span>, <span class="number">0x5B</span>, <span class="number">0xAA</span>, <span class="number">0x18</span>, <span class="number">0x85</span>, <span class="number">0xFA</span>,</span><br><span class="line">  <span class="number">0x61</span>, <span class="number">0xE4</span>, <span class="number">0xA1</span>, <span class="number">0xBC</span>, <span class="number">0xF8</span>, <span class="number">0xA4</span>, <span class="number">0x56</span>, <span class="number">0x37</span>, <span class="number">0x43</span>, <span class="number">0x58</span>,</span><br><span class="line">  <span class="number">0x2B</span>, <span class="number">0xC9</span>, <span class="number">0x77</span>, <span class="number">0x64</span>, <span class="number">0xCC</span>, <span class="number">0x6B</span>, <span class="number">0x98</span>, <span class="number">0x65</span>, <span class="number">0x75</span>, <span class="number">0x38</span>,</span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0x09</span>, <span class="number">0x11</span>, <span class="number">0x3D</span>, <span class="number">0xD0</span>, <span class="number">0xE6</span>, <span class="number">0x8F</span>, <span class="number">0xA9</span>, <span class="number">0x57</span>, <span class="number">0x99</span>,</span><br><span class="line">  <span class="number">0x06</span>, <span class="number">0x10</span>, <span class="number">0x5D</span>, <span class="number">0xC5</span>, <span class="number">0x69</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x68</span>, <span class="number">0x7E</span>, <span class="number">0xE3</span>,</span><br><span class="line">  <span class="number">0x67</span>, <span class="number">0xD1</span>, <span class="number">0xFF</span>, <span class="number">0x5E</span>, <span class="number">0xF9</span>, <span class="number">0xF5</span>, <span class="number">0x41</span>, <span class="number">0x8C</span>, <span class="number">0xDD</span>, <span class="number">0x21</span>,</span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0xA7</span>, <span class="number">0x47</span>, <span class="number">0x86</span>, <span class="number">0x6D</span>, <span class="number">0xC3</span>, <span class="number">0x2A</span>, <span class="number">0x9A</span>, <span class="number">0x9F</span>, <span class="number">0x20</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0xBB</span>, <span class="number">0x94</span>, <span class="number">0xB9</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0x02</span>, <span class="number">0x74</span>, <span class="number">0x7D</span>, <span class="number">0x1B</span>,</span><br><span class="line">  <span class="number">0x1E</span>, <span class="number">0x5F</span>, <span class="number">0xBA</span>, <span class="number">0x49</span>, <span class="number">0xD6</span>, <span class="number">0xE7</span>, <span class="number">0x53</span>, <span class="number">0x04</span>, <span class="number">0xCB</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xE8</span>, <span class="number">0x33</span>, <span class="number">0x3E</span>, <span class="number">0x00</span>, <span class="number">0x9B</span>, <span class="number">0x6A</span>, <span class="number">0xFD</span>, <span class="number">0xBE</span>, <span class="number">0x1C</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0xED</span>, <span class="number">0xDF</span>, <span class="number">0x4D</span>, <span class="number">0x25</span>, <span class="number">0x6F</span>, <span class="number">0xB5</span>, <span class="number">0x13</span>, <span class="number">0x70</span>, <span class="number">0x3C</span>,</span><br><span class="line">  <span class="number">0x9E</span>, <span class="number">0x16</span>, <span class="number">0x0C</span>, <span class="number">0x05</span>, <span class="number">0x4A</span>, <span class="number">0x73</span>, <span class="number">0xDE</span>, <span class="number">0xB1</span>, <span class="number">0x8A</span>, <span class="number">0x51</span>,</span><br><span class="line">  <span class="number">0x3B</span>, <span class="number">0x54</span>, <span class="number">0x14</span>, <span class="number">0xE0</span>, <span class="number">0x5A</span>, <span class="number">0xDC</span>, <span class="number">0x91</span>, <span class="number">0x62</span>, <span class="number">0xA3</span>, <span class="number">0x95</span>,</span><br><span class="line">  <span class="number">0xD3</span>, <span class="number">0x3A</span>, <span class="number">0x17</span>, <span class="number">0xEE</span>, <span class="number">0x32</span>, <span class="number">0xF2</span>, <span class="number">0x7C</span>, <span class="number">0xAF</span>, <span class="number">0xB3</span>, <span class="number">0x88</span>,</span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x0E</span>, <span class="number">0xAE</span>, <span class="number">0x9D</span>, <span class="number">0x5C</span>, <span class="number">0x0D</span>, <span class="number">0x55</span>, <span class="number">0x4E</span>, <span class="number">0xFB</span>, <span class="number">0x46</span>,</span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0xBF</span>, <span class="number">0x52</span>, <span class="number">0x12</span>, <span class="number">0x66</span>, <span class="number">0x07</span>, <span class="number">0xD2</span>, <span class="number">0x36</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x6E</span>, <span class="number">0x42</span>, <span class="number">0x1A</span>, <span class="number">0x0F</span>, <span class="number">0xE9</span>, <span class="number">0x60</span>, <span class="number">0xCA</span>, <span class="number">0xB2</span>, <span class="number">0x6C</span>,</span><br><span class="line">  <span class="number">0x83</span>, <span class="number">0xF0</span>, <span class="number">0x03</span>, <span class="number">0x76</span>, <span class="number">0xA8</span>, <span class="number">0x1F</span>, <span class="number">0x63</span>, <span class="number">0xEF</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>,</span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x0A</span>, <span class="number">0x0B</span>, <span class="number">0xAB</span>, <span class="number">0xDB</span>, <span class="number">0xD4</span>, <span class="number">0x7F</span>, <span class="number">0x01</span>, <span class="number">0x34</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x59</span>, <span class="number">0xE1</span>, <span class="number">0x29</span>, <span class="number">0xC6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>, <span class="number">0x40</span>, <span class="number">0xC8</span>, <span class="number">0xAD</span>,</span><br><span class="line">  <span class="number">0xC4</span>, <span class="number">0x89</span>, <span class="number">0xC2</span>, <span class="number">0xB6</span>, <span class="number">0x71</span>, <span class="number">0xA0</span>, <span class="number">0xEB</span>, <span class="number">0x2F</span>, <span class="number">0x78</span>, <span class="number">0xF3</span>,</span><br><span class="line">  <span class="number">0xB0</span>, <span class="number">0xFE</span>, <span class="number">0xCE</span>, <span class="number">0xF7</span>, <span class="number">0x84</span>, <span class="number">0x72</span>, <span class="number">0xF4</span>, <span class="number">0xCF</span>, <span class="number">0xC7</span>, <span class="number">0xD7</span>,</span><br><span class="line">  <span class="number">0xB7</span>, <span class="number">0x8E</span>, <span class="number">0x4C</span>, <span class="number">0x82</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x2E</span>, <span class="number">0x24</span>, <span class="number">0x87</span>, <span class="number">0x08</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0xE5</span>, <span class="number">0xEA</span>, <span class="number">0xA6</span>, <span class="number">0x8B</span>, <span class="number">0x15</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decry</span>(<span class="params">key, enc</span>):</span><br><span class="line">        v7 = <span class="number">0</span></span><br><span class="line">        v6 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(enc)):</span><br><span class="line">                v7 = (v7+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">                v6 = (v6 + key[v7])%<span class="number">256</span></span><br><span class="line">                key[v7], key[v6] = key[v6], key[v7]</span><br><span class="line">                enc[i] ^= key[(key[v6]+key[v7]) % <span class="number">256</span>]</span><br><span class="line">        <span class="keyword">return</span> enc</span><br></pre></td></tr></table></figure><p>这下只需知道need_shuzu，就能写出逆向脚本解了。</p><p>查找一下need_shuzu 的引用</p><p><img src="/Images/image-20240202002957047.png" alt="image-20240202002957047"></p><p><img src="/Images/image-20240202003018010.png" alt="image-20240202003018010"></p><p>不难发现，need_shuzu定义于这个sub_C4B4B4( )函数，且从未被修改，那么这就好办了，直接调试进去找到need_shuzu的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">need = [<span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x8E</span>]</span><br></pre></td></tr></table></figure><p>最终脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">key1 = [ <span class="number">0x35</span>, <span class="number">0xF1</span>, <span class="number">0xDA</span>, <span class="number">0x19</span>, <span class="number">0x7A</span>, <span class="number">0xF6</span>, <span class="number">0x31</span>, <span class="number">0x9C</span>, <span class="number">0xD9</span>, <span class="number">0x2C</span>,</span><br><span class="line">  <span class="number">0xC1</span>, <span class="number">0xFC</span>, <span class="number">0xE2</span>, <span class="number">0xD8</span>, <span class="number">0x1D</span>, <span class="number">0x8D</span>, <span class="number">0x4F</span>, <span class="number">0x97</span>, <span class="number">0x81</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0xC0</span>, <span class="number">0xB8</span>, <span class="number">0x96</span>, <span class="number">0x27</span>, <span class="number">0xD5</span>, <span class="number">0x5B</span>, <span class="number">0xAA</span>, <span class="number">0x18</span>, <span class="number">0x85</span>, <span class="number">0xFA</span>,</span><br><span class="line">  <span class="number">0x61</span>, <span class="number">0xE4</span>, <span class="number">0xA1</span>, <span class="number">0xBC</span>, <span class="number">0xF8</span>, <span class="number">0xA4</span>, <span class="number">0x56</span>, <span class="number">0x37</span>, <span class="number">0x43</span>, <span class="number">0x58</span>,</span><br><span class="line">  <span class="number">0x2B</span>, <span class="number">0xC9</span>, <span class="number">0x77</span>, <span class="number">0x64</span>, <span class="number">0xCC</span>, <span class="number">0x6B</span>, <span class="number">0x98</span>, <span class="number">0x65</span>, <span class="number">0x75</span>, <span class="number">0x38</span>,</span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0x09</span>, <span class="number">0x11</span>, <span class="number">0x3D</span>, <span class="number">0xD0</span>, <span class="number">0xE6</span>, <span class="number">0x8F</span>, <span class="number">0xA9</span>, <span class="number">0x57</span>, <span class="number">0x99</span>,</span><br><span class="line">  <span class="number">0x06</span>, <span class="number">0x10</span>, <span class="number">0x5D</span>, <span class="number">0xC5</span>, <span class="number">0x69</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x68</span>, <span class="number">0x7E</span>, <span class="number">0xE3</span>,</span><br><span class="line">  <span class="number">0x67</span>, <span class="number">0xD1</span>, <span class="number">0xFF</span>, <span class="number">0x5E</span>, <span class="number">0xF9</span>, <span class="number">0xF5</span>, <span class="number">0x41</span>, <span class="number">0x8C</span>, <span class="number">0xDD</span>, <span class="number">0x21</span>,</span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0xA7</span>, <span class="number">0x47</span>, <span class="number">0x86</span>, <span class="number">0x6D</span>, <span class="number">0xC3</span>, <span class="number">0x2A</span>, <span class="number">0x9A</span>, <span class="number">0x9F</span>, <span class="number">0x20</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0xBB</span>, <span class="number">0x94</span>, <span class="number">0xB9</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0x02</span>, <span class="number">0x74</span>, <span class="number">0x7D</span>, <span class="number">0x1B</span>,</span><br><span class="line">  <span class="number">0x1E</span>, <span class="number">0x5F</span>, <span class="number">0xBA</span>, <span class="number">0x49</span>, <span class="number">0xD6</span>, <span class="number">0xE7</span>, <span class="number">0x53</span>, <span class="number">0x04</span>, <span class="number">0xCB</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xE8</span>, <span class="number">0x33</span>, <span class="number">0x3E</span>, <span class="number">0x00</span>, <span class="number">0x9B</span>, <span class="number">0x6A</span>, <span class="number">0xFD</span>, <span class="number">0xBE</span>, <span class="number">0x1C</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0xED</span>, <span class="number">0xDF</span>, <span class="number">0x4D</span>, <span class="number">0x25</span>, <span class="number">0x6F</span>, <span class="number">0xB5</span>, <span class="number">0x13</span>, <span class="number">0x70</span>, <span class="number">0x3C</span>,</span><br><span class="line">  <span class="number">0x9E</span>, <span class="number">0x16</span>, <span class="number">0x0C</span>, <span class="number">0x05</span>, <span class="number">0x4A</span>, <span class="number">0x73</span>, <span class="number">0xDE</span>, <span class="number">0xB1</span>, <span class="number">0x8A</span>, <span class="number">0x51</span>,</span><br><span class="line">  <span class="number">0x3B</span>, <span class="number">0x54</span>, <span class="number">0x14</span>, <span class="number">0xE0</span>, <span class="number">0x5A</span>, <span class="number">0xDC</span>, <span class="number">0x91</span>, <span class="number">0x62</span>, <span class="number">0xA3</span>, <span class="number">0x95</span>,</span><br><span class="line">  <span class="number">0xD3</span>, <span class="number">0x3A</span>, <span class="number">0x17</span>, <span class="number">0xEE</span>, <span class="number">0x32</span>, <span class="number">0xF2</span>, <span class="number">0x7C</span>, <span class="number">0xAF</span>, <span class="number">0xB3</span>, <span class="number">0x88</span>,</span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x0E</span>, <span class="number">0xAE</span>, <span class="number">0x9D</span>, <span class="number">0x5C</span>, <span class="number">0x0D</span>, <span class="number">0x55</span>, <span class="number">0x4E</span>, <span class="number">0xFB</span>, <span class="number">0x46</span>,</span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0xBF</span>, <span class="number">0x52</span>, <span class="number">0x12</span>, <span class="number">0x66</span>, <span class="number">0x07</span>, <span class="number">0xD2</span>, <span class="number">0x36</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x6E</span>, <span class="number">0x42</span>, <span class="number">0x1A</span>, <span class="number">0x0F</span>, <span class="number">0xE9</span>, <span class="number">0x60</span>, <span class="number">0xCA</span>, <span class="number">0xB2</span>, <span class="number">0x6C</span>,</span><br><span class="line">  <span class="number">0x83</span>, <span class="number">0xF0</span>, <span class="number">0x03</span>, <span class="number">0x76</span>, <span class="number">0xA8</span>, <span class="number">0x1F</span>, <span class="number">0x63</span>, <span class="number">0xEF</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>,</span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x0A</span>, <span class="number">0x0B</span>, <span class="number">0xAB</span>, <span class="number">0xDB</span>, <span class="number">0xD4</span>, <span class="number">0x7F</span>, <span class="number">0x01</span>, <span class="number">0x34</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x59</span>, <span class="number">0xE1</span>, <span class="number">0x29</span>, <span class="number">0xC6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>, <span class="number">0x40</span>, <span class="number">0xC8</span>, <span class="number">0xAD</span>,</span><br><span class="line">  <span class="number">0xC4</span>, <span class="number">0x89</span>, <span class="number">0xC2</span>, <span class="number">0xB6</span>, <span class="number">0x71</span>, <span class="number">0xA0</span>, <span class="number">0xEB</span>, <span class="number">0x2F</span>, <span class="number">0x78</span>, <span class="number">0xF3</span>,</span><br><span class="line">  <span class="number">0xB0</span>, <span class="number">0xFE</span>, <span class="number">0xCE</span>, <span class="number">0xF7</span>, <span class="number">0x84</span>, <span class="number">0x72</span>, <span class="number">0xF4</span>, <span class="number">0xCF</span>, <span class="number">0xC7</span>, <span class="number">0xD7</span>,</span><br><span class="line">  <span class="number">0xB7</span>, <span class="number">0x8E</span>, <span class="number">0x4C</span>, <span class="number">0x82</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x2E</span>, <span class="number">0x24</span>, <span class="number">0x87</span>, <span class="number">0x08</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0xE5</span>, <span class="number">0xEA</span>, <span class="number">0xA6</span>, <span class="number">0x8B</span>, <span class="number">0x15</span>]</span><br><span class="line"></span><br><span class="line">enc = [ <span class="number">0x38</span>, <span class="number">0x9A</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x5B</span>, <span class="number">0x89</span>, <span class="number">0xA5</span>, <span class="number">0xE6</span>, <span class="number">0xD0</span>, <span class="number">0xAB</span>,</span><br><span class="line">        <span class="number">0x42</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0xAB</span>, <span class="number">0x33</span>, <span class="number">0x2F</span>, <span class="number">0x98</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x2E</span>, <span class="number">0x59</span>, <span class="number">0x6D</span>, <span class="number">0x41</span>]</span><br><span class="line">need = [<span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x8E</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decry</span>(<span class="params">key, enc</span>):</span><br><span class="line">        v7 = <span class="number">0</span></span><br><span class="line">        v6 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(enc)):</span><br><span class="line">                v7 = (v7+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">                v6 = (v6 + key[v7])%<span class="number">256</span></span><br><span class="line">                key[v7], key[v6] = key[v6], key[v7]</span><br><span class="line">                enc[i] ^= key[(key[v6]+key[v7]) % <span class="number">256</span>]</span><br><span class="line">        <span class="keyword">return</span> enc</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        flag = []</span><br><span class="line">        <span class="built_in">input</span> = decry(key1, enc)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">              flag.append(<span class="built_in">input</span>[i] + <span class="number">112</span> - need[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">chr</span>(i), end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>主要逻辑就是，由enc，反推回去input，然后input再反推回去put，很好理解，其中的need_shuzu，和key通过调试能得到。这个做法看起来挺冗杂的，应该有更好的办法</p><p>flag{Russian_is_so_easy}</p><h2 id="0x05-stick-game"><a href="#0x05-stick-game" class="headerlink" title="0x05 stick game"></a>0x05 stick game</h2><p>一个网页小游戏，根据之前搭载博客时对网页的一点点理解，觉得主要的逻辑函数应该在js文件里面。</p><p>先看看游戏，说达到1337427分就能获得flag，当然正常是不能去玩的，如果js文件没有加变量名字混淆的话，存储着分数的变量应该叫score，打开文件ctrl+F找一下score变量</p><p><img src="/Images/d3ac6c2abfae882ecb8eed2305f1165.png" alt="d3ac6c2abfae882ecb8eed2305f1165"></p><p>喜报，代码没有经过格式化，一坨。后面请教大佬朋友在vscode扩展下载了一个插件Prettier - Code formatter ，下载后选中格式化。</p><p><img src="/Images/image-20240204182828372.png" alt="image-20240204182828372"></p><p>继续查找score，发现有个疑似修改分数的代码，这里的_0x3c8400作为一个变量名暂存分数，然后这个0x3a2009是一个判断是否双倍得分的参数，若为True就加2分，false就加1分，那一坨0x10a5….计算出来是2，下面-0x257…算出来是1，手动给他们后面加上1337426，这样一来，如果加一分，就相当于加了1337427分。不过这些都是建立在这个代码就是控制得分的代码的基础上的假设。</p><p><img src="/Images/image-20240204183632727.png" alt="image-20240204183632727"></p><p>下面还有一个疑似修改分数的代码，不过这个算出来score = 0，应该不太可能是加分的代码，更像是重置分数的代码。修改完后打开游戏试试，果然成功一次就加了1337427分，这时候直接跳崖，让游戏在1337427分结束，网页弹窗显示出了flag。</p><p>完全不懂javascript，静态分析对我来说太难了，如果懂的话找下弹窗函数，和其他flag的加密函数或许能解出来，不过由于代码变量名混淆，我也看不出flag在js文件里到底长什么样。</p><p>begin{y0u_re4l1y_g07_1337427_66f1ebde263de1e039063aa402d22977}</p><h2 id="0x06-ezpython"><a href="#0x06-ezpython" class="headerlink" title="0x06 ezpython"></a>0x06 ezpython</h2><p>这题真的坑，题干一直在说key有问题，我也尝试过去找有没有函数修改了key，没想到竟然是gmssl库的sm4加密解密函数里，一个叫set_key的函数被修改了，key在填入前先做了和37的异或，确实搞到我了，flag也搞我，唉，采购。除了这个就是正常的py解包反编译，不过要用3.8python解包，不然会丢失文件（因为这题是3.8python写的）（<a href="https://www.beihaihaihai.top/2024/01/29/GeekChallenge/">py解包反编译梗概</a>）。</p><p>反编译出他的ezpython文件，加以修改就能出flag了，早该如此，key 的错误一直卡死我了，唉。</p><p>ezpython.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 3.8</span></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> enc,key</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad_pkcs7</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;PKCS#7填充&#x27;&#x27;&#x27;</span></span><br><span class="line">    padding_len = <span class="number">16</span> - <span class="built_in">len</span>(data) % <span class="number">16</span></span><br><span class="line">    padding = <span class="built_in">bytes</span>([</span><br><span class="line">        padding_len] * padding_len)</span><br><span class="line">    <span class="keyword">return</span> data + padding</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unpad_pkcs7</span>(<span class="params">padded_data</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;PKCS#7去填充&#x27;&#x27;&#x27;</span></span><br><span class="line">    padding_len = padded_data[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> padded_data[:-padding_len]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SM4</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.gmsm4 = sm4.CryptSM4()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encryptSM4</span>(<span class="params">self, encrypt_key, value</span>):</span><br><span class="line">        gmsm4 = self.gmsm4</span><br><span class="line">        gmsm4.set_key(encrypt_key.encode(), sm4.SM4_ENCRYPT)</span><br><span class="line">        padded_value = pad_pkcs7(value.encode())</span><br><span class="line">        encrypt_value = gmsm4.crypt_ecb(padded_value)</span><br><span class="line">        <span class="keyword">return</span> base64.b64encode(encrypt_value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decryptSM4</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        gmsm4 = self.gmsm4</span><br><span class="line">        gmsm4.set_key(key.encode(), sm4.SM4_DECRYPT)</span><br><span class="line">        padded_value = base64.b64decode(value)</span><br><span class="line">        decrypted_data = gmsm4.crypt_ecb(padded_value)</span><br><span class="line">        <span class="keyword">return</span> unpad_pkcs7(decrypted_data).decode()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># decrypted_data = unpad_pkcs7(value.decode())</span></span><br><span class="line">        <span class="comment"># decrypted_data = gmsm4.crypt_ecb(decrypted_data)</span></span><br><span class="line">        <span class="comment"># return base64.b64decode(decrypted_data)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># print(&#x27;请输入你的flag:&#x27;)</span></span><br><span class="line">    <span class="comment"># flag = input()</span></span><br><span class="line">    <span class="comment"># sm4_instance = SM4()</span></span><br><span class="line">    <span class="comment"># flag_1 = sm4_instance.encryptSM4(key, flag)</span></span><br><span class="line">    <span class="comment"># if flag_1 != enc:</span></span><br><span class="line">    <span class="comment">#     print(&#x27;flag错误!!&#x27;)</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     print(&#x27;恭喜你获得flag😊😀&#x27;)</span></span><br><span class="line">    key2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">        key2 += <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[i]) ^ <span class="number">37</span>)</span><br><span class="line">    sm4_instance = SM4()</span><br><span class="line">    flag_1 = sm4_instance.decryptSM4(key2, enc)</span><br><span class="line">    <span class="built_in">print</span>(flag_1)</span><br></pre></td></tr></table></figure><p>secret.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&#x27;BeginCTFBeginCTF&#x27;</span></span><br><span class="line">enc = <span class="string">b&#x27;JmjJEAJGMT6F9bmC+Vyxy8Z1lpfaJzdEX6BGG/qgqUjUpQaYSON1CnZyX9YXTEClSRYm7PFZtGxmJw6LPuw1ww==&#x27;</span></span><br></pre></td></tr></table></figure><p>flag{Pay_M0re_@ttention_to_th3_key!!}</p><h2 id="0x07-出题人的密码"><a href="#0x07-出题人的密码" class="headerlink" title="0x07 出题人的密码"></a>0x07 出题人的密码</h2><p>一开始做的时候被一坨看不懂的东西卡住了，后面才发现那个是没用的，引以为戒。</p><p>程序点进去无法f5，一步一步看，后面才发现是有花指令，把那些call的脏字节和无意义的jnz和jn全部都nop掉，然后反编译就能看到main函数了。</p><p><img src="/Images/image-20240207152800382.png" alt="image-20240207152800382"></p><p>正常来说这里有很多sub函数，混淆我们找加密函数，我做的时候直接找了最后拿来比较的input和enc（input 是我自己命名的）中input 的引用，反解回去两个加密函数的</p><p>encry1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_C98090</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  result = __CheckForDebuggerJustMyCode(&amp;unk_D0D0F4);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">48</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    input[i] = (put[i] + <span class="number">5</span>) ^ <span class="number">0x25</span>;</span><br><span class="line">    result = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>encry2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_C97F10</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  __int64 v2; <span class="comment">// [esp+D0h] [ebp-58h]</span></span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// [esp+ECh] [ebp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+F8h] [ebp-30h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+104h] [ebp-24h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [esp+110h] [ebp-18h]</span></span><br><span class="line">  <span class="type">char</span> *v7; <span class="comment">// [esp+120h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_D0D0F4);</span><br><span class="line">  v3 = j__strlen(Buffer);                       <span class="comment">// 612995005</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    j__srand(byte_D09FD7[v3]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    j__srand(<span class="number">0x123456</span>u);</span><br><span class="line">  v0 = j__rand() % <span class="number">7</span>;</span><br><span class="line">  result = unk_D09000[<span class="number">2</span> * v0];</span><br><span class="line">  LODWORD(v2) = result;</span><br><span class="line">  HIDWORD(v2) = dword_D09004[<span class="number">2</span> * v0];           <span class="comment">// 0x33077D</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = &amp;put[<span class="number">8</span> * i];</span><br><span class="line">    v6 = *v7;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v6 &lt; <span class="number">0</span> )</span><br><span class="line">        v6 = v2 ^ (<span class="number">2</span> * v6);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v6 *= <span class="number">2</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    *v7 = v6;</span><br><span class="line">    result = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中encry1不多讲了，encry2是一个主要的加密函数，他的主要逻辑就是，将enc（48个字节），按小端序存储分为6个8字节大小的长整形，然后判断整形是否为负数（其实就是看最高位是否为1），若为负数，在左移一位的基础上再异或v2（v2是用魔法得到的），若不为负数，则就只是左移1位。</p><p>这个加密的难点在于根据加密后的数才判断加密前的数是正数还是负数，因为符号位在左移一位后已经丢失了。但是由此同时左移一位后的数的最低位变成了 0，恰v2的最低位也是0。因此，若加密后的数最低位是1，说明最低位经过0 ^ 0 =1 的异或，说明加密前的数是负数（因为经过异或），若加密后的数最低位是0，说明左移后没有和v2异或过，加密前是正数。</p><p>有了这个思路，逆向思路就很明了了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> enc[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0xB4</span>, <span class="number">0xBB</span>, <span class="number">0xD8</span>, <span class="number">0xEB</span>, <span class="number">0xD0</span>, <span class="number">0x6E</span>, <span class="number">0xAB</span>, <span class="number">0xCA</span>, <span class="number">0x65</span>, <span class="number">0x8E</span>, </span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0xE9</span>, <span class="number">0x4D</span>, <span class="number">0xD4</span>, <span class="number">0x4A</span>, <span class="number">0xF3</span>, <span class="number">0x7D</span>, <span class="number">0x29</span>, <span class="number">0xC2</span>, <span class="number">0xF9</span>, </span><br><span class="line">  <span class="number">0x95</span>, <span class="number">0x89</span>, <span class="number">0xA4</span>, <span class="number">0x85</span>, <span class="number">0x9D</span>, <span class="number">0xCD</span>, <span class="number">0xDF</span>, <span class="number">0x77</span>, <span class="number">0xFD</span>, <span class="number">0x45</span>, </span><br><span class="line">  <span class="number">0xCB</span>, <span class="number">0x5D</span>, <span class="number">0x7D</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x4B</span>, <span class="number">0xBC</span>, <span class="number">0xF6</span>, <span class="number">0x7C</span>, <span class="number">0xF3</span>, </span><br><span class="line">  <span class="number">0x24</span>, <span class="number">0x42</span>, <span class="number">0xF5</span>, <span class="number">0xD2</span>, <span class="number">0xDD</span>, <span class="number">0xE3</span>, <span class="number">0x56</span>, <span class="number">0xAE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> enc1[<span class="number">48</span>];  </span><br><span class="line"><span class="type">unsigned</span> __int64 enc2[<span class="number">6</span>];</span><br><span class="line">__int64 v2 = <span class="number">0x000000000033077D</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//encry1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">48</span>; i++)&#123;</span><br><span class="line">        enc1[i] = (enc[i] ^ <span class="number">0x25</span>) - <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//encry2</span></span><br><span class="line">    <span class="comment">//小端序合并字节</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        enc2[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">            enc2[i] |= (__int64)enc1[<span class="number">8</span> * i + j] &lt;&lt; (<span class="number">8</span> * j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">64</span> ; k++)&#123;</span><br><span class="line">            <span class="comment">//如果enc2[i] &amp; 1为1，说明最后一位是1，说明被异或过了，因为</span></span><br><span class="line">            <span class="comment">//移位后最后一位是0，而v2的最后一位也是0，若没有异或过，最后</span></span><br><span class="line">            <span class="comment">//一位应该是0，所以看最后一位判断之前有无异或过</span></span><br><span class="line">            <span class="keyword">if</span>(enc2[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                enc2[i] ^= v2;</span><br><span class="line">                enc2[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//由于题目里的判断是小于0，即第一位是1时异或v2，这时左移</span></span><br><span class="line">                <span class="comment">//会丢失数据1，应该右移后补上</span></span><br><span class="line">                enc2[i] |= <span class="number">0x8000000000000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                enc2[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小端序分离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">            enc[<span class="number">8</span> * i + j] = (enc2[i] &gt;&gt; (<span class="number">8</span> * j)) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出flag</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">48</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,enc[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于涉及到数据的溢出和大小长度，建议还是用C写脚本</p><p>begin{Th1s_reverse_pr0blem_may_t@ke_some_time#!}</p><h2 id="0x08-superguesser"><a href="#0x08-superguesser" class="headerlink" title="0x08 superguesser"></a>0x08 superguesser</h2><p>其实这题我动调了半天都不知道意义何在，一来随便点点就看到了疑似加密的主函数</p><p><img src="/Images/image-20240207161553428.png" alt="image-20240207161553428"></p><p>这里的静态代码真的看不懂，不过大概率是while循环那里，给明文依次加密，最后再比较，把一大坨密文抄一下，（v0-48）就是输入input开始的地址，长度为（v0-24）=37；然后(v0-20)=0（类似于循环里的i），(v0-25)=0x33（调试出来的）。下面那个loc_46EEF4猜测就是cmp函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( *(v0 - <span class="number">20</span>) &lt; *(v0 - <span class="number">24</span>) )</span><br><span class="line">  *(*(v0 - <span class="number">48</span>) + (*(v0 - <span class="number">20</span>))++) ^= *(v0 - <span class="number">20</span>) + *(v0 - <span class="number">25</span>) + <span class="number">17</span> * *(v0 - <span class="number">26</span>);</span><br></pre></td></tr></table></figure><p>这里有个疑点，就是这个(v0-26)动调出来是1，但是实际计算根据这个1算不出来。</p><p>动调研究一下原本的汇编代码，看看哪里是有问题的。看完汇编代码发现计算时找不到这个17 *(v0-26)的操作，反而 +0x33 的操作变成了 +0x44，原因是(v0-26) = 1这一步经过位移操作后变成0x11与0x33相加，导致结果变成了0x44，感觉被反调试过了，动调出来的东西不太可信。</p><p>一位一位爆破试出来(v0-26) = 0，写出脚本就很简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">81</span>,<span class="number">81</span>,<span class="number">82</span>,<span class="number">95</span>,<span class="number">89</span>,<span class="number">67</span>,<span class="number">93</span>,<span class="number">95</span>,<span class="number">89</span>,<span class="number">73</span>,</span><br><span class="line">       <span class="number">90</span>,<span class="number">89</span>,<span class="number">86</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">29</span>,<span class="number">42</span>,<span class="number">55</span>,<span class="number">26</span>,<span class="number">39</span>,</span><br><span class="line">       <span class="number">41</span>,<span class="number">23</span>,<span class="number">40</span>,<span class="number">36</span>,<span class="number">42</span>,<span class="number">56</span>,<span class="number">37</span>,<span class="number">33</span>,<span class="number">61</span>,<span class="number">15</span>,</span><br><span class="line">       <span class="number">50</span>,<span class="number">58</span>,<span class="number">60</span>,<span class="number">61</span>,<span class="number">54</span>,<span class="number">51</span>,<span class="number">42</span>]</span><br><span class="line">d = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">37</span>):</span><br><span class="line">    enc[i] ^= (i + <span class="number">0x33</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc[i]),end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>begin{debugging_is_an_anathor_choice}</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="/2024/01/30/C-%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/01/30/C-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++继承"></a>C++继承</h1><p>本节介绍C++的继承和多态的语法</p><h2 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h2><p>一图解</p><p><img src="Images/20200221123718539.png" alt="20200221123718539"></p><h2 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h2><p>一句话，在继承中，父类的私有成员只是被隐藏了，占存储空间，还是会被继承下去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">sizeof</span>(Son)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出16 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造和析构的顺序"><a href="#构造和析构的顺序" class="headerlink" title="构造和析构的顺序"></a>构造和析构的顺序</h2><p>构造和析构的顺序，先构造父类，再构造子类；先析构子类，最后再析构父类</p><h2 id="同名成员处理"><a href="#同名成员处理" class="headerlink" title="同名成员处理"></a>同名成员处理</h2><p>当子类和父类出现同名的成员时：</p><p>若访问子类同名成员，直接访问即可；若访问父类同名成员，需要加作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()&#123;</span><br><span class="line">a=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()&#123;</span><br><span class="line">a=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">std::cout&lt;&lt;s.a&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出200</span></span><br><span class="line">std::cout&lt;&lt;s.Base::a&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出100 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子父类同名函数调用也是同理，但需要注意的是：</p><p>当子类中出现与父类同名的成员函数时，子类的同名成员会隐藏掉父类中所有的同名成员函数（各种重载函数），如果想访问到父类中被隐藏的同名成员函数，需要加作用域（作用域原理同同名成员变量）</p><h2 id="同名静态成员处理方式"><a href="#同名静态成员处理方式" class="headerlink" title="同名静态成员处理方式"></a>同名静态成员处理方式</h2><p>静态成员和非静态成员出现同名，处理方式一致</p><p>若访问子类同名成员，直接访问即可；若访问父类同名成员，需要加作用域。</p><p>静态成员能够通过类名访问，详细语法在之前的CPP类的基础中的静态成员已经提及过，——-&gt;<a href="https://www.beihaihaihai.top/2024/01/29/cpp%E7%B1%BB%E5%9F%BA%E7%A1%80/">传送门</a></p><p>(类名: :成员名，来访问静态成员)</p><h2 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h2><p>C++允许一个类继承多个类</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类 : 继承方式 父类<span class="number">1</span> , 继承方式 父类<span class="number">2</span> ...</span><br></pre></td></tr></table></figure><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p>（C++实际开发中不建议使用多继承）</p><p>总而言之，多继承中如果父类中出现了同名情况，子类使用时候要加作用域加以区分</p><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><h3 id="菱形继承概念"><a href="#菱形继承概念" class="headerlink" title="菱形继承概念"></a>菱形继承概念</h3><p>两个派生类继承同一个基类，某个类同时继承这两个派生类，这种继承称为菱形继承，又称钻石继承。</p><h3 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h3><p><img src="Images/1706619988650.jpg" alt="1706619988650"></p><p>举个例子：</p><p>在这张图里面，羊继承了动物的数据，同意驼也继承了一份同样的数据，当羊驼使用数据时，就会产生二义性，解决这个问题的关键在于羊驼取动物的数据时，只从羊或者驼中之一取一份。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bc</span> :<span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Bc s;</span><br><span class="line">s.B::age=<span class="number">18</span>;</span><br><span class="line">s.C::age=<span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察这个代码，虽然可以通过多继承的作用域加以区分，两个父类相同的数据，但是这样会在实际开发中产生歧义，浪费存储空间，如例子中的羊驼（Bc）的年龄是继承18还是28呢？</p><p>实际上，也应该是，这份数据，我们只要有一份就可以。</p><h3 id="解决菱形继承"><a href="#解决菱形继承" class="headerlink" title="解决菱形继承"></a>解决菱形继承</h3><p>利用虚继承，解决菱形继承的问题</p><p>继承之前加上关键字virtual，变为虚继承</p><p>在这个例子中，A类称为 虚基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bc</span> :<span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Bc s;</span><br><span class="line">s.B::age=<span class="number">18</span>;</span><br><span class="line">s.C::age=<span class="number">28</span>;</span><br><span class="line">s.age=<span class="number">38</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用虚继承后，age只有一份。在上面代码的例子中，age先后被赋值为18，28，最后再被改为38，数据只有一份。虚基础是怎么实现只继承一份数据的？其实是用了虚基类指针和虚基类表</p><h3 id="虚基础原理"><a href="#虚基础原理" class="headerlink" title="虚基础原理"></a>虚基础原理</h3><p><img src="Images/3c6066e66608a29a50657a7cffc0d26.png" alt="3c6066e66608a29a50657a7cffc0d26"></p><p>在这张表中，ST从S和T类中继承了vbptr（virtual base pointer）虚基类指针，然后只有一份从虚基类（A）继承的值age。</p><p><img src="Images/c38ffa6b96452d3575201a5b78f25a4.png" alt="c38ffa6b96452d3575201a5b78f25a4"></p><p>vbptr指向vbtable（虚基类表），在这个例子中S的vbptr指向的vbtable里的偏移量为8，从vbptr地址处偏移8就能取到age的值，同理，T的vbptr指向的vbtable里的偏移量为4，从该vbptr地址处偏移4就同样能取到age的值，age的值唯一且是共享。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GeekChallenge 2023 re wp</title>
      <link href="/2024/01/29/GeekChallenge/"/>
      <url>/2024/01/29/GeekChallenge/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感觉有点尴尬，这个wp并不全，因为本人打算在比赛结束后写出此文，然后发现靶场的题全下完了，然后自己也没有备份，呃呃怎么办呢？只能凭印象了，想到哪道题就写哪道题罢，然后Ida的界面的东西也没有（因为题目被我删了）只剩解密脚本了凑合着看。。。</p><h2 id="0x01-shiftjmp"><a href="#0x01-shiftjmp" class="headerlink" title="0x01 shiftjmp"></a>0x01 shiftjmp</h2><p><img src="Images/5847d3c5041d4cc9bbe0c4965dbe7367.png" alt="5847d3c5041d4cc9bbe0c4965dbe7367"></p><p>die查壳，发现是无壳的ELF64文件，直接拖入ida64</p><p><img src="Images/4f36ff36fa3d479ab15b23445ba8a9ca.png" alt="4f36ff36fa3d479ab15b23445ba8a9ca"></p><p>按tab发现无法生存伪代码，发现这里有两处错误。</p><p>这两处错误是花指令，花指令详情见<a href="https://ctf-wiki.org/reverse/obfuscate/junk-code/">花指令 - CTF Wiki (ctf-wiki.org)</a></p><p>第一处是无意义跳转，第二处是jmp造成的脏字节。</p><p>把jz和imp都nop掉。</p><p><img src="Images/5a7233f2ea1a4f72a7e4741ecb515f8c.png" alt="5a7233f2ea1a4f72a7e4741ecb515f8c"></p><p>undefine （U）然后按 c生存代码 按p生存函数main</p><p><img src="Images/23badc126cdd4ee5b8ebe570748b8172.png" alt="23badc126cdd4ee5b8ebe570748b8172"></p><p>非常简单的异或加密，写个python脚本解密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enc=<span class="string">&#x27;SXAxS6jd8doTxBQ&#123;x&quot;Ma&#x27;</span>+<span class="built_in">chr</span>(<span class="number">0x27</span>)+<span class="string">r&quot;csE-|El,o/&#123;^\\&quot;</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">34</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(enc[i])^i^<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>flag：SYC{W3lc0me_tO_th3_r3veR5e_w0r1d~}</p><h2 id="0x02-点击就送的逆向题"><a href="#0x02-点击就送的逆向题" class="headerlink" title="0x02 点击就送的逆向题"></a>0x02 点击就送的逆向题</h2><p>没什么好说的，Linux.s文件编译，打开虚拟机按照下面步骤手动编译就好了</p><p>gcc -c test.s -o test.o</p><p>gcc test.o -o test</p><p>这里补充一下c语言编译步骤：</p><p>1、预处理                                               </p><p>gcc -E test.c -o test.i</p><p>2、用intel汇编代码来编译</p><p>gcc -s -masm=intel test.i -o test.s</p><p>3、汇编器将汇编代码转化为机器码</p><p>gcc -c test.s -o test.o</p><p>4、链接调用输出</p><p>gcc test.o -o test.out</p><p>之后拖到ida分析编译好的test文件，简单位移加密逆向后可以解出来。</p><h2 id="0x03-AES！！AES？"><a href="#0x03-AES！！AES？" class="headerlink" title="0x03 AES！！AES？"></a>0x03 AES！！AES？</h2><p>简化版的AES加密，没有列混合和生成多个子密钥进行轮密钥加</p><p><a href="https://www.bilibili.com/video/BV1i341187fK/?spm_id_from=333.337.search-card.all.click">【AES加密算法】| AES加密过程详解| 对称加密| Rijndael-128| 密码学| 信息安全_哔哩哔哩_  bilibili  </a>AES算法详细见这个视频）</p><p>照着ida里面的加密步骤逆出解密脚本就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">S=[<span class="number">0x63</span>, <span class="number">0x7C</span>, <span class="number">0x77</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x6B</span>, <span class="number">0x6F</span>, <span class="number">0xC5</span>, <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xD7</span>, <span class="number">0xAB</span>,</span><br><span class="line">   <span class="number">0x76</span>, <span class="number">0xCA</span>, <span class="number">0x82</span>, <span class="number">0xC9</span>, <span class="number">0x7D</span>, <span class="number">0xFA</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, <span class="number">0xAD</span>, <span class="number">0xD4</span>, <span class="number">0xA2</span>, <span class="number">0xAF</span>, <span class="number">0x9C</span>,</span><br><span class="line">   <span class="number">0xA4</span>, <span class="number">0x72</span>, <span class="number">0xC0</span>, <span class="number">0xB7</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3F</span>, <span class="number">0xF7</span>, <span class="number">0xCC</span>, <span class="number">0x34</span>, <span class="number">0xA5</span>, <span class="number">0xE5</span>,</span><br><span class="line">   <span class="number">0xF1</span>, <span class="number">0x71</span>, <span class="number">0xD8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>, <span class="number">0x04</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0xC3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9A</span>,<span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>,</span><br><span class="line">   <span class="number">0xE2</span>, <span class="number">0xEB</span>, <span class="number">0x27</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>, <span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2C</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x6E</span>, <span class="number">0x5A</span>, <span class="number">0xA0</span>, <span class="number">0x52</span>, <span class="number">0x3B</span>,</span><br><span class="line">   <span class="number">0xD6</span>, <span class="number">0xB3</span>,<span class="number">0x29</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0x84</span>, <span class="number">0x53</span>, <span class="number">0xD1</span>, <span class="number">0x00</span>, <span class="number">0xED</span>, <span class="number">0x20</span>, <span class="number">0xFC</span>, <span class="number">0xB1</span>, <span class="number">0x5B</span>, <span class="number">0x6A</span>,</span><br><span class="line">   <span class="number">0xCB</span>, <span class="number">0xBE</span>, <span class="number">0x39</span>, <span class="number">0x4A</span>, <span class="number">0x4C</span>, <span class="number">0x58</span>,<span class="number">0xCF</span>, <span class="number">0xD0</span>, <span class="number">0xEF</span>, <span class="number">0xAA</span>, <span class="number">0xFB</span>, <span class="number">0x43</span>, <span class="number">0x4D</span>, <span class="number">0x33</span>,</span><br><span class="line">   <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x02</span>, <span class="number">0x7F</span>, <span class="number">0x50</span>, <span class="number">0x3C</span>, <span class="number">0x9F</span>, <span class="number">0xA8</span>, <span class="number">0x51</span>, <span class="number">0xA3</span>,<span class="number">0x40</span>, <span class="number">0x8F</span>, <span class="number">0x92</span>, <span class="number">0x9D</span>,</span><br><span class="line">   <span class="number">0x38</span>, <span class="number">0xF5</span>, <span class="number">0xBC</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>, <span class="number">0xF3</span>, <span class="number">0xD2</span>, <span class="number">0xCD</span>, <span class="number">0x0C</span>, <span class="number">0x13</span>,</span><br><span class="line">   <span class="number">0xEC</span>,<span class="number">0x5F</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, <span class="number">0xC4</span>, <span class="number">0xA7</span>, <span class="number">0x7E</span>, <span class="number">0x3D</span>, <span class="number">0x64</span>, <span class="number">0x5D</span>, <span class="number">0x19</span>, <span class="number">0x73</span>, <span class="number">0x60</span>, <span class="number">0x81</span>,</span><br><span class="line">   <span class="number">0x4F</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x2A</span>, <span class="number">0x90</span>,<span class="number">0x88</span>, <span class="number">0x46</span>, <span class="number">0xEE</span>, <span class="number">0xB8</span>, <span class="number">0x14</span>, <span class="number">0xDE</span>, <span class="number">0x5E</span>, <span class="number">0x0B</span>, <span class="number">0xDB</span>,</span><br><span class="line">   <span class="number">0xE0</span>, <span class="number">0x32</span>, <span class="number">0x3A</span>, <span class="number">0x0A</span>, <span class="number">0x49</span>, <span class="number">0x6</span>, <span class="number">0x24</span>, <span class="number">0x5C</span>, <span class="number">0xC2</span>, <span class="number">0xD3</span>,<span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xE4</span>,</span><br><span class="line">   <span class="number">0x79</span>, <span class="number">0xE7</span>, <span class="number">0xC8</span>, <span class="number">0x37</span>, <span class="number">0x6D</span>, <span class="number">0x8D</span>, <span class="number">0xD5</span>, <span class="number">0x4E</span>, <span class="number">0xA9</span>, <span class="number">0x6C</span>, <span class="number">0x56</span>, <span class="number">0xF4</span>, <span class="number">0xEA</span>,<span class="number">0x65</span>,</span><br><span class="line">   <span class="number">0x7A</span>, <span class="number">0xAE</span>, <span class="number">0x08</span>, <span class="number">0xBA</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2E</span>, <span class="number">0x1C</span>, <span class="number">0xA6</span>, <span class="number">0xB4</span>, <span class="number">0xC6</span>, <span class="number">0xE8</span>, <span class="number">0xDD</span>, <span class="number">0x74</span>,</span><br><span class="line">   <span class="number">0x1F</span>, <span class="number">0x4B</span>, <span class="number">0xBD</span>, <span class="number">0x8B</span>,<span class="number">0x8A</span>, <span class="number">0x70</span>, <span class="number">0x3E</span>, <span class="number">0xB5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xF6</span>, <span class="number">0x0E</span>, <span class="number">0x61</span>, <span class="number">0x35</span>,</span><br><span class="line">   <span class="number">0x57</span>, <span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0xC1</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>, <span class="number">0xE1</span>, <span class="number">0xF8</span>,<span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xD9</span>, <span class="number">0x8E</span>, <span class="number">0x94</span>,</span><br><span class="line">   <span class="number">0x9B</span>, <span class="number">0x1E</span>, <span class="number">0x87</span>, <span class="number">0xE9</span>, <span class="number">0xCE</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xDF</span>, <span class="number">0x8C</span>, <span class="number">0xA1</span>, <span class="number">0x89</span>, <span class="number">0x0D</span>, <span class="number">0xBF</span>,<span class="number">0xE6</span>,</span><br><span class="line">   <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x54</span>, <span class="number">0xBB</span>, <span class="number">0x16</span>]</span><br><span class="line"><span class="comment">#字节代换S表</span></span><br><span class="line">key=[<span class="number">110</span>,<span class="number">121</span>,<span class="number">105</span>,-<span class="number">125</span>,<span class="number">121</span>,</span><br><span class="line">     <span class="number">127</span>,<span class="number">105</span>,<span class="number">117</span>,<span class="number">121</span>,<span class="number">120</span>,</span><br><span class="line">     -<span class="number">127</span>,<span class="number">105</span>,<span class="number">93</span>,<span class="number">99</span>,<span class="number">77</span>,<span class="number">73</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    key[i]-=<span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> key[i]&lt;<span class="number">0</span>:</span><br><span class="line">        key[i]+=<span class="number">256</span></span><br><span class="line">    key[i] = key[i] &amp; <span class="number">0xff</span></span><br><span class="line"><span class="comment">#密钥：do_you_konw_SYC?</span></span><br><span class="line">key1=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    key1.append(key[i] ^ S[key[i]] &amp; <span class="number">0xff</span>)</span><br><span class="line"><span class="comment">#密钥扩展</span></span><br><span class="line">enc=[<span class="number">0xe0</span>,<span class="number">0x05</span>,<span class="number">0x6e</span>,<span class="number">0xc2</span>,<span class="number">0x6e</span>,</span><br><span class="line">     <span class="number">0x99</span>,<span class="number">0x68</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0x1f</span>,</span><br><span class="line">     <span class="number">0x3f</span>,<span class="number">0xf9</span>,<span class="number">0x97</span>,<span class="number">0x76</span>,<span class="number">0x3b</span>,</span><br><span class="line">     <span class="number">0x92</span>,<span class="number">0x2f</span>,<span class="number">0x44</span>,<span class="number">0x06</span>,<span class="number">0x67</span>,</span><br><span class="line">     <span class="number">0xa8</span>,<span class="number">0xeb</span>,<span class="number">0xec</span>,<span class="number">0x4a</span>,<span class="number">0x6f</span>,</span><br><span class="line">     <span class="number">0xe8</span>,<span class="number">0x35</span>,<span class="number">0xf9</span>,<span class="number">0xac</span>,<span class="number">0xa7</span>,</span><br><span class="line">     <span class="number">0x8c</span>,<span class="number">0x71</span>]</span><br><span class="line"><span class="comment">#逆向行位移</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re_shiftrow</span>(<span class="params">flag</span>):<span class="comment">#右移动</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                flag[<span class="number">4</span> * i + <span class="number">3</span> - k], flag[<span class="number">4</span> * i + <span class="number">3</span> - k - <span class="number">1</span>] = flag[<span class="number">4</span> * i + <span class="number">3</span> - k - <span class="number">1</span>], flag[<span class="number">4</span> * i + <span class="number">3</span> - k]</span><br><span class="line">                flag[<span class="number">16</span>+<span class="number">4</span> * i + <span class="number">3</span> - k], flag[<span class="number">16</span>+<span class="number">4</span> * i + <span class="number">3</span> - k - <span class="number">1</span>] = flag[<span class="number">16</span>+<span class="number">4</span> * i + <span class="number">3</span> - k - <span class="number">1</span>], flag[<span class="number">16</span>+<span class="number">4</span> * i + <span class="number">3</span> - k]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re_tansform</span>(<span class="params">flag</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        flag[i] = S.index(flag[i])</span><br><span class="line">    v = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">        v.append(i)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            flag[n] = v[<span class="number">4</span> * k + j]</span><br><span class="line">            flag[n + <span class="number">16</span>] = v[<span class="number">16</span> + <span class="number">4</span> * k + j]</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_xor</span>(<span class="params">flag,key</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        flag[i] ^= key[i % <span class="number">0x10</span>]</span><br><span class="line"><span class="comment">#异或密钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_trans</span>(<span class="params">flag</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        flag[i] = S.index(flag[i])</span><br><span class="line"><span class="comment">#字节代换</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#下面是主函数</span></span><br><span class="line">byte_xor(enc,key1)</span><br><span class="line">re_shiftrow(enc)</span><br><span class="line">byte_trans(enc)</span><br><span class="line">byte_xor(enc,key)</span><br><span class="line">re_tansform(enc)</span><br><span class="line">re_shiftrow(enc)</span><br><span class="line">byte_trans(enc)</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">5</span>:</span><br><span class="line">        enc[i]=<span class="number">46</span></span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">10</span>:</span><br><span class="line">        enc[i]=<span class="number">108</span></span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">17</span>:</span><br><span class="line">        enc[i]=<span class="number">48</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>（s表是手打的，当时不知道ida能快捷键Shift+E提取文本数据）</p><p>SYC{0.o_Thls_1s_n0t_A3s_(q^_^p)}</p><h2 id="0x04-miku"><a href="#0x04-miku" class="headerlink" title="0x04 miku"></a>0x04 miku</h2><p>这是一道golang逆向题，评价是完全看不懂，发现main函数里有一个叫rc4加密的函数，盲猜是rc4加密。传入的key通过静态分析很难找，直接Linux远程动调，运行程序后有一个输入初音未来色，经过百度查找是39c5bb，正确输入后经过动态调试发现生成了正确的key 0x43，手搓一个rc4对称解密脚本直接逆出flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rc4对称加密流程</span></span><br><span class="line"></span><br><span class="line">enc=[<span class="number">0x25</span>,<span class="number">0x6f</span>,<span class="number">0x3d</span>,<span class="number">0x6c</span>,<span class="number">0xf9</span>,<span class="number">0xe0</span>,<span class="number">0xcf</span>,<span class="number">0x3f</span>,</span><br><span class="line">     <span class="number">0x2e</span>,<span class="number">0x24</span>,<span class="number">0xc6</span>,<span class="number">0x7b</span>,<span class="number">0x81</span>,<span class="number">0xbf</span>,<span class="number">0x55</span>,<span class="number">0x4f</span>,</span><br><span class="line">     <span class="number">0x0d</span>,<span class="number">0x99</span>,<span class="number">0x87</span>,<span class="number">0x47</span>,<span class="number">0x48</span>,<span class="number">0xf7</span>,<span class="number">0xb9</span>,<span class="number">0x98</span>,</span><br><span class="line">     <span class="number">0xfb</span>,<span class="number">0x1b</span>,<span class="number">0x22</span>,<span class="number">0xec</span>,<span class="number">0x84</span>,<span class="number">0x23</span>,<span class="number">0xfd</span>,<span class="number">0xb2</span>]</span><br><span class="line"><span class="comment">#key长度为18</span></span><br><span class="line"><span class="comment">#flag长度为32</span></span><br><span class="line">key=[<span class="number">0x43</span>]</span><br><span class="line"><span class="comment">#填充一个s_box,0到255</span></span><br><span class="line"><span class="comment">#key表待定</span></span><br><span class="line">s=[]</span><br><span class="line">k=[]</span><br><span class="line">xor=[<span class="number">0</span>]*<span class="number">32</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     s.append(i)</span><br><span class="line">     k.append(key[i%<span class="number">1</span>])</span><br><span class="line"><span class="comment">#初始化s_box</span></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     j=(j+s[i]+k[i])%<span class="number">256</span></span><br><span class="line"></span><br><span class="line">     temp=s[i]</span><br><span class="line">     s[i]=s[j]</span><br><span class="line">     s[j]=temp</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line">t=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">     i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">     j=(j+s[i])%<span class="number">256</span></span><br><span class="line"></span><br><span class="line">     temp = s[i]</span><br><span class="line">     s[i] = s[j]</span><br><span class="line">     s[j] = temp</span><br><span class="line"></span><br><span class="line">     t=(s[i]+s[j])%<span class="number">256</span></span><br><span class="line">     xor[k]=s[t]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">     flag+=<span class="built_in">chr</span>(xor[i]^enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{N0thing_1s_sEriOus_But_MIku}</p><h2 id="0x05-幸运数字"><a href="#0x05-幸运数字" class="headerlink" title="0x05 幸运数字"></a>0x05 幸运数字</h2><p>感觉没啥好说的，题目说0到999有存在幸运数字，经过分析只要找出任意一个luck丢进逆向脚本就能出flag，由于幸运数字的范围小，直接爆破出来就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#前n项求和公式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">if</span> key!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> result(key-<span class="number">1</span>)+key</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">enc=[<span class="number">0x0d</span>,<span class="number">7</span>,<span class="number">0x1d</span>,<span class="number">0x25</span>,<span class="number">0x1d</span>,<span class="number">0x6e</span>,<span class="number">0x30</span>,<span class="number">0x39</span>,<span class="number">0x2c</span>,<span class="number">0x3f</span>,<span class="number">0x2a</span>,</span><br><span class="line">     <span class="number">0x2b</span>,<span class="number">0x32</span>,<span class="number">0x3f</span>,<span class="number">0x2a</span>,<span class="number">0x37</span>,<span class="number">0x6e</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x2d</span>,</span><br><span class="line">     <span class="number">1</span>,<span class="number">7</span>,<span class="number">0x31</span>,<span class="number">0x2b</span>,<span class="number">1</span>,<span class="number">0x39</span>,<span class="number">0x1f</span>,<span class="number">0x3b</span>,<span class="number">0x2d</span>,<span class="number">0x2d</span>,<span class="number">0x1b</span>,<span class="number">0x3a</span>,<span class="number">1</span>,</span><br><span class="line">     <span class="number">0x0c</span>,<span class="number">0x6f</span>,<span class="number">0x39</span>,<span class="number">0x36</span>,<span class="number">0x2a</span>,<span class="number">0x23</span>]</span><br><span class="line">key=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">999</span>):</span><br><span class="line">    <span class="keyword">if</span> result(i)%<span class="number">0xd3</span>==<span class="number">94</span>:</span><br><span class="line">        key.append(i)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> key:</span><br><span class="line">    flag=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">41</span>):</span><br><span class="line">        v4=enc[i]</span><br><span class="line">        v5=result(j)</span><br><span class="line">        flag+=<span class="built_in">chr</span>(v4^(v5%<span class="number">0xd3</span>))</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{C0ngratulati0nnnns_You_gAessEd_R1ght}</p><h2 id="0x06-黄鸭"><a href="#0x06-黄鸭" class="headerlink" title="0x06 黄鸭"></a>0x06 黄鸭</h2><p>丢进die发现是PyInstaller封装的exe，py逆向，用pyinstxtractor 进行反编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py test.exe</span><br></pre></td></tr></table></figure><p><a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor脚本主页</a></p><p>之后根据python的版本更改关键pyc文件的魔术头（PyObject_HEAD）魔术头的版本号可以通过查看struct文件了解。（不知道为什么我的pyin……弄出来后的pyc魔术头总是对不上号，这时可以用010editor去更改）</p><p><img src="Images/004bd73cd7694932bb6ce9353711dfd7.png" alt="004bd73cd7694932bb6ce9353711dfd7"></p><p>转自独奏の小屋</p><p>在线网站可以反编译pyc，<a href="https://tool.lu/pyc/">python反编译 - 在线工具 (tool.lu)</a></p><p>uncompyle也可以，详情见<a href="https://github.com/rocky/python-uncompyle6">uncompyle6</a></p><p><img src="Images/55efa10608db44838bb1f6968d1cf0b5-1706530201413-9.png" alt="55efa10608db44838bb1f6968d1cf0b5">找到关键的加密代码，看不懂是什么语法。。但也可以猜出来是一个向右移动13位的凯撒加密了，之后再将其他细节补全，逆出解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">enc = <span class="string">&#x27;~h|p4gs`gJdN`thPwR`jDn`te1w`2|RNH&#x27;</span></span><br><span class="line">enc = enc[::-<span class="number">1</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enc:</span><br><span class="line">    <span class="keyword">if</span> i&gt;=<span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> i&lt;=<span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) - <span class="number">2</span>)</span><br><span class="line">        i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">13</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(i) &lt; <span class="number">97</span>:</span><br><span class="line">            i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)+<span class="number">26</span>)</span><br><span class="line">        flag += i</span><br><span class="line">    <span class="keyword">elif</span> i&gt;=<span class="string">&#x27;A&#x27;</span> <span class="keyword">and</span> i&lt;=<span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">        i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) - <span class="number">2</span>)</span><br><span class="line">        i=<span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">13</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(i) &lt; <span class="number">65</span>:</span><br><span class="line">            i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)+<span class="number">26</span>)</span><br><span class="line">        flag += i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#手动将倒数第三个的 &#x27;&#125;&#x27; 替换成 &#x27;m&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{1_h0pe_yOu_ChAse_YoUr_dr3ams}</p><h2 id="0x07-砍树"><a href="#0x07-砍树" class="headerlink" title="0x07 砍树"></a>0x07 砍树</h2><p>砍树是一道安卓逆向题，但本质感觉还是ida。考察了apk文件的本质是一个压缩包，将.apk改成.zip后解压就能发现里面的函数library，找到一个像颜文字一样的函数。这个函数在jadx静态分析界面里面是找不到的，是调用了某个外部库，然后是此题的关键加密函数。</p><p>找到这个函数后，拖到ida里面分析出来是个什么玩意，找到key=“Sycloverforerver”，逆出解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enc=[<span class="number">0</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x17</span>,<span class="number">0x1b</span>,<span class="number">0x36</span>,<span class="number">0x0e</span>,<span class="number">0x36</span>,<span class="number">0x26</span>,</span><br><span class="line">      <span class="number">0x17</span>,<span class="number">4</span>,<span class="number">0x2a</span>,<span class="number">0x29</span>,<span class="number">7</span>,<span class="number">0x26</span>,<span class="number">0x15</span>,<span class="number">0x52</span>,<span class="number">0x33</span>,<span class="number">0x2d</span>,</span><br><span class="line">      <span class="number">0x0f</span>,<span class="number">0x3a</span>,<span class="number">0x27</span>,<span class="number">0x11</span>,<span class="number">6</span>,<span class="number">0x33</span>,<span class="number">7</span>,<span class="number">0x46</span>,<span class="number">0x17</span>,<span class="number">0x3d</span>,</span><br><span class="line">      <span class="number">0x0a</span>,<span class="number">0x3c</span>,<span class="number">0x38</span>,<span class="number">0x2e</span>,<span class="number">0x22</span>,<span class="number">0x18</span>]</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line">key=<span class="string">&quot;Sycloverforerver&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">35</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(key[i%<span class="number">7</span>])^enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{t@ke_thE_bul1_By_the_h0rns_TAT}</p><h2 id="0x08-扎针游戏"><a href="#0x08-扎针游戏" class="headerlink" title="0x08 扎针游戏"></a>0x08 扎针游戏</h2><p>此题是一个unity引擎的游戏，源自见缝插针。游戏引导玩家去扎30根针，可是扎完后发现还要再扎到40根。受不了这鸟气，在附带文件里面找到Assemble-Csharp.dll，丢进c#反汇编工具ILspy里面查看，查找相关字符串就可以定位到关键代码了，一个游戏流程控制代码，这里经过分析后会检测你鼠标点击的次数和扎针扎的分数，要达到100分。但是看不出解密方法。</p><p>问过大佬1k0ct后，他说用CE可以来修改score，改到100分。直接炫了一个Cheat Engine，找了一下修改方法将分数改到100，发现解出了错误flag。</p><p>后面分析发现前30次每次扎完针都会通过异或加密刷新一次密文，之后在score达到100时在游戏左上角显示出来。</p><p>之后手动扎30次针，再将score改到100，就出现了正确的flag。</p><h2 id="0x09-rainbow"><a href="#0x09-rainbow" class="headerlink" title="0x09 rainbow"></a>0x09 rainbow</h2><p>控制流平坦化，在ida里面导入了一个D-810的插件，可以将消去控制流平坦化，什么是控制流平坦化呢？？？？<a href="https://security.tencent.com/index.php/blog/msg/112">利用符号执行去除控制流平坦化 - 博客 - 腾讯安全应急响应中心 </a></p><p>自己看看吧，我也不知道。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">0x65</span>,<span class="number">0x58</span>,<span class="number">0x41</span>,<span class="number">0x8e</span>,<span class="number">0x50</span>,<span class="number">0x44</span>,<span class="number">0x7b</span>,<span class="number">0x62</span>,</span><br><span class="line">       <span class="number">0x57</span>,<span class="number">0x4a</span>,<span class="number">0x7e</span>,<span class="number">0x54</span>,<span class="number">0x49</span>,<span class="number">0x6c</span>,<span class="number">0x7d</span>,<span class="number">0x84</span>,</span><br><span class="line">       <span class="number">0x4f</span>,<span class="number">0x5b</span>,<span class="number">0x95</span>,<span class="number">0x60</span>,<span class="number">0x60</span>,<span class="number">0x64</span>,<span class="number">0x77</span>,<span class="number">0x48</span>,</span><br><span class="line">       <span class="number">0x7d</span>,<span class="number">0x4d</span>,<span class="number">0x7b</span>,<span class="number">0x9f</span>,<span class="number">0x68</span>,<span class="number">0x3c</span>,<span class="number">0x2d</span>,<span class="number">0x62</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    enc[i] ^= i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> i%<span class="number">3</span>:</span><br><span class="line">        enc[i] -= <span class="number">18</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>(enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{TAke_1t_3asy_Just_a_STart!!}</p><h2 id="0x0A-TEA"><a href="#0x0A-TEA" class="headerlink" title="0x0A TEA"></a>0x0A TEA</h2><p>这是一道安卓逆向TEA，flag根据下标的奇数和偶数被分为两部分，偶数部分经过一次变种TEA加密后得到密文enc，奇数部分与enc异或得到密文enc1。</p><p>除了变种TEA外，本题的字符存储为int32位数据是是大端序存储的，注意这两点关键后就可以解出题目了（jadx里面的密文enc1被putExtra了，需要查找一个getExtra函数找到获取这个密文的代码文件，跳转过去后就能看到上面所说的enc1和异或加密操作了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enc2=[-<span class="number">107</span>, -<span class="number">106</span>, -<span class="number">95</span>, -<span class="number">115</span>, -<span class="number">119</span>, <span class="number">127</span>, <span class="number">26</span>, <span class="number">121</span>, -<span class="number">62</span>, -<span class="number">20</span>, <span class="number">86</span>, <span class="number">9</span>]<span class="comment">#奇数部分的密文</span></span><br><span class="line">enc=[-<span class="number">91</span>, -<span class="number">8</span>, -<span class="number">110</span>, -<span class="number">55</span>, -<span class="number">49</span>, <span class="number">75</span>, <span class="number">115</span>, <span class="number">13</span>, -<span class="number">76</span>, -<span class="number">113</span>, <span class="number">102</span>, <span class="number">80</span>]<span class="comment">#偶数部分经过TEA后的密文</span></span><br><span class="line">e=[]</span><br><span class="line"><span class="comment">#两者异或之后得到奇数部分的明文</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    enc2[i] &amp;= <span class="number">0xff</span></span><br><span class="line">    e.append(enc[i]^enc2[i])</span><br><span class="line">arr=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">if</span> enc[i]&lt;<span class="number">0</span>:</span><br><span class="line">        enc[i]+=<span class="number">256</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">12</span>,<span class="number">4</span>):</span><br><span class="line">    arr.append((enc[i]&lt;&lt;<span class="number">24</span>)|(enc[i+<span class="number">1</span>]&lt;&lt;<span class="number">16</span>)|(enc[i+<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)|(enc[i+<span class="number">3</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(arr[i]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> e:</span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="number">0</span>:</span><br><span class="line">        i+=<span class="number">256</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到密文enc的大端序存储数</p><p>0xa5f892c9<br>0xcf4b730d<br>0xb48f6650</p><p>这个是明文的奇数部分<br>0n3DF4itvc0Y</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> byte[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> k0 = <span class="number">2023708229</span>, k1= <span class="number">-158607964</span>, k2= <span class="number">-2120859654</span>, k3 = <span class="number">1167043672</span>;</span><br><span class="line"><span class="comment">//密钥</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> delta = <span class="number">1640531527</span>;</span><br><span class="line"><span class="type">int</span> i10= <span class="number">0xa5f892c9</span>, i11= <span class="number">0xb48f6650</span>, i12= <span class="number">0xcf4b730d</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">-64</span>*delta ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">i11 -= (((i12 &lt;&lt; <span class="number">4</span>) + k2) ^ (i12 + sum)) ^ ((i12 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">i12 -= (((i11 &lt;&lt; <span class="number">4</span>) + k0) ^ (i11 + sum)) ^ ((i11 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">sum += delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">i11 -= (((i10 &lt;&lt; <span class="number">4</span>) + k2) ^ (i10 + sum)) ^ ((i10 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">i10 -= (((i11 &lt;&lt; <span class="number">4</span>) + k0) ^ (i11 + sum)) ^ ((i11 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">sum += delta ;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>] = i10;</span><br><span class="line">arr[<span class="number">1</span>] = i11;</span><br><span class="line">arr[<span class="number">2</span>] = i12;</span><br><span class="line"><span class="type">int</span> i4 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">byte[i] = (arr[i4] &gt;&gt; <span class="number">24</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">byte[i + <span class="number">1</span>] = (arr[i4] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">byte[i + <span class="number">2</span>] = (arr[i4] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">byte[i + <span class="number">3</span>] = (arr[i4]) &amp; <span class="number">0xff</span>;</span><br><span class="line">i4++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *n =  <span class="string">&quot;0n3DF4itvc0Y&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SYC&#123;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, n[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, byte[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>将上述密文enc和奇数部分明文输入脚本，再将密钥key啥的弄好，包裹一下SYC输出就好了</p><p>这里提一嘴int类型和unsigned int类型（简称uint），在做题时我把密文enc的数据类型设为了uint，导致后面输出的结果是错的后面查资料才发现，int类型和uint在按位运算时，前者是算术位移，后置是逻辑位移，举个例子：char a=1111 1111，&gt;&gt;2后是1111 1111，符号位不变</p><p>而uchar 1111 1111 ，&gt;&gt;2后是0011 1111，没有符号位，两者是有区别的，会影响到十六进制数的大小。</p><p>SYC{0Tn03VDtF343iTtnv0ci0tYr}</p><h2 id="0x0B-easymath"><a href="#0x0B-easymath" class="headerlink" title="0x0B easymath"></a>0x0B easymath</h2><p>看起来就像是一个平平无奇的阅读ida代码然后写脚本的题，但是好难逆啊，结合提示整了一个z3库来约束一下条件，正向爆破出flag。</p><p>下载一个z3的库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><p>下载完后我打开pycharm然后发现 怎么都用不了，没办法，只能搞一个vscode来写</p><p><a href="https://zhuanlan.zhihu.com/p/646649819">如何用vscode配置C语言环境？ - 知乎 (zhihu.com)</a>（这里放一个无关紧要的相关文章）</p><p>vscode写蟒蛇只要选个解释器就好了非常的简单。</p><p><img src="Images/082fdef6113444c8bb0faa58ccae7f41.png" alt="082fdef6113444c8bb0faa58ccae7f41"></p><p>ida里红色框框出的是核心的代码，需要爆破的关键。就是一个矩阵的乘法加法啥的，不用管当普通的加法乘法来算就好了。目的是求出last</p><p><img src="C:/Users/28382/Desktop/26e619187dde4933a0f0d20efcb53ebf.png" alt="26e619187dde4933a0f0d20efcb53ebf"></p><p>这里有几个给定的值， 把这些提前约束好，应该是防止爆破出多解的。</p><p><img src="Images/6ec0376b9364473290b5d7469d53cf45.png" alt="6ec0376b9364473290b5d7469d53cf45"></p><p>这几个函数大概的逻辑就是在flag的每一个字符，在table里面找到对应的值，并取下标然后储存到position里面，接着再用这个下标在number里面取值存到last里面，这几个步骤都是很好逆向的，所以只要求出last就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#定义一个last列表[x1,x2,x3......x24]</span></span><br><span class="line">table=<span class="string">&quot;01234_asdzxcpoityumnbAOZWXGMY&quot;</span></span><br><span class="line">matrix=[<span class="number">18</span>,<span class="number">29</span>,<span class="number">16</span>,<span class="number">19</span>,<span class="number">27</span>,</span><br><span class="line">        <span class="number">8</span>,<span class="number">31</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">30</span>,</span><br><span class="line">        <span class="number">29</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">10</span>,<span class="number">21</span>,</span><br><span class="line">        <span class="number">18</span>,<span class="number">29</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">28</span>,</span><br><span class="line">        <span class="number">11</span>,<span class="number">30</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">num=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,</span><br><span class="line">     <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">19</span>,</span><br><span class="line">     <span class="number">22</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">32</span>,</span><br><span class="line">     <span class="number">50</span>,<span class="number">51</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">56</span>]</span><br><span class="line"><span class="comment">#约束限制条件</span></span><br><span class="line">flander_e=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    s=Solver()</span><br><span class="line">    last=IntVector(<span class="string">&#x27;last&#x27;</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">        s.add(last[<span class="number">1</span>]==<span class="number">19</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">        s.add(last[<span class="number">2</span>]==<span class="number">22</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:</span><br><span class="line">        s.add(last[<span class="number">2</span>]==<span class="number">22</span>)</span><br><span class="line">    <span class="comment">#分个组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#for j in range(5):</span></span><br><span class="line">        <span class="comment">#s.add(Or([last[j]==i for i in num]))</span></span><br><span class="line">    s.add(And([Or([last[j]==i <span class="keyword">for</span> i <span class="keyword">in</span> num])<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        flander=IntVal(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            flander=(flander+last[k]*matrix[<span class="number">5</span>*k+j])%<span class="number">0x20</span></span><br><span class="line">            <span class="comment">#%0x20和&amp;0x1f等价的，但是这里的变量是int，不能按位运算</span></span><br><span class="line">        s.add(flander==flander_e[<span class="number">5</span>*i+j])</span><br><span class="line">    result=s.check()</span><br><span class="line">    <span class="keyword">if</span> result == sat:</span><br><span class="line">        m=s.model()</span><br><span class="line">        values=[m[last[w]].as_long() <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(table[num.index(each)],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no solution&quot;</span>)</span><br></pre></td></tr></table></figure><p>记得是之前听1k0ct说一次性爆出last会很慢很慢，我之后就改成了一次出last一行</p><p>i用来取行的序号，然后这里last的19,22,什么的是根据他给的t，y正推出来的，就根据那几个函数的步骤手动推出last 的已知解。然后就是不知道是什么的语法，这些查文档就好了吧（心虚）</p><p>flag已忘，望周知</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nbctf</title>
      <link href="/2024/01/29/nbctf/"/>
      <url>/2024/01/29/nbctf/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-py逆向"><a href="#0x01-py逆向" class="headerlink" title="0x01 py逆向"></a>0x01 py逆向</h2><p>给了一个main.py和out.txt 的文件，打开分析一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line">key1 = random.choices(<span class="built_in">range</span>(<span class="number">256</span>), k=<span class="number">20</span>)  <span class="comment">#0到255里取20个随机数</span></span><br><span class="line">key2 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))  <span class="comment">#0到255的列表</span></span><br><span class="line">random.shuffle(key2) <span class="comment">#随机排列</span></span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()    <span class="comment">#读取flag，设置成input</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">n</span>): <span class="comment">#加密函数</span></span><br><span class="line">    q = key2[n]</span><br><span class="line">    w = key1[q % <span class="number">20</span>]</span><br><span class="line">    n ^= q</span><br><span class="line">    <span class="keyword">return</span> n, w</span><br><span class="line"> </span><br><span class="line">x = <span class="number">0x00000000</span></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(flag):  <span class="comment">#枚举遍历，第一个是下标，第二个是里面的东西</span></span><br><span class="line">    x &lt;&lt;= <span class="number">8</span>  <span class="comment">#x左移动8位，一个字节</span></span><br><span class="line">    n, w = enc(c)  <span class="comment">#根据密钥和flag出两个数</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span>:   <span class="comment">#如果是奇数下标，swap交换</span></span><br><span class="line">        n, w = w, n</span><br><span class="line">    x |= n</span><br><span class="line">    x |= (w &lt;&lt; ((<span class="number">2</span> * i + <span class="number">1</span>) * <span class="number">8</span>) ) <span class="comment">#按位运算的优先级高于赋值运算</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(key1)</span><br><span class="line"><span class="built_in">print</span>(key2)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>然后手动调试一下前几项，很容易发现x 的组成是由w和n交替排列的，大概的规律就是</p><pre><code>         w34n33......w2n1w0n0w1n2......w33n34</code></pre><p>根据output文件里的x的值，转码成十六进制</p><p>(0x)ea0149929a24de3a6ab642ebeaa16a02571f572449b67f1f57c4a4b67fc542027feb6a0eeaab4d9c42ab6a3e5124deab6a045724de244db69a16ea016ab6571f57a1a2fe4290</p><p>总共有70个字符，flag推算出是35位</p><p>根据这坨玩意写个抽象的脚本分离出w和n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">enc=<span class="string">&quot;ea0149929a24de3a6ab642ebeaa16a02571f572449b67f1f57c4a4b67fc542027feb6a0eeaab4d9c42ab6a3e5124deab6a045724de244db69a16ea016ab6571f57a1a2fe4290&quot;</span></span><br><span class="line">enc_l=[]</span><br><span class="line">enc_r=[]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(enc))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">70</span>):</span><br><span class="line">    enc_l.append(enc[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">70</span>,<span class="number">140</span>):</span><br><span class="line">    enc_r.append(enc[i])</span><br><span class="line">n_o=[<span class="number">0xea</span>,<span class="number">0x49</span>,<span class="number">0x9a</span>,<span class="number">0xde</span>,<span class="number">0x6a</span>,<span class="number">0x42</span>,<span class="number">0xea</span>,<span class="number">0x6a</span>,<span class="number">0x57</span>,<span class="number">0x57</span>,<span class="number">0x49</span>,<span class="number">0x7f</span>,<span class="number">0x57</span>,<span class="number">0xa4</span>,<span class="number">0x7f</span>,<span class="number">0x42</span>,<span class="number">0x7f</span>,<span class="number">0x6a</span>]</span><br><span class="line">n_j=[<span class="number">0xea</span>,<span class="number">0x4d</span>,<span class="number">0x42</span>,<span class="number">0x6a</span>,<span class="number">0x51</span>,<span class="number">0xde</span>,<span class="number">0x6a</span>,<span class="number">0x57</span>,<span class="number">0xde</span>,<span class="number">0x4d</span>,<span class="number">0x9a</span>,<span class="number">0xea</span>,<span class="number">0x6a</span>,<span class="number">0x57</span>,<span class="number">0x57</span>,<span class="number">0xa2</span>,<span class="number">0x42</span>]</span><br><span class="line">w_o=[<span class="number">0x0e</span>,<span class="number">0xab</span>,<span class="number">0x9c</span>,<span class="number">0xab</span>,<span class="number">0x3e</span>,<span class="number">0x24</span>,<span class="number">0xab</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0xb6</span>,<span class="number">0x16</span>,<span class="number">0x01</span>,<span class="number">0xb6</span>,<span class="number">0x1f</span>,<span class="number">0xa1</span>,<span class="number">0xfe</span>,<span class="number">0x90</span>]</span><br><span class="line">w_j=[<span class="number">0x01</span>,<span class="number">0x92</span>,<span class="number">0x24</span>,<span class="number">0x3a</span>,<span class="number">0xb6</span>,<span class="number">0xeb</span>,<span class="number">0xa1</span>,<span class="number">0x02</span>,<span class="number">0x1f</span>,<span class="number">0x24</span>,<span class="number">0xb6</span>,<span class="number">0x1f</span>,<span class="number">0xc4</span>,<span class="number">0xb6</span>,<span class="number">0xc5</span>,<span class="number">0x02</span>,<span class="number">0xeb</span>]</span><br><span class="line"><span class="comment">#n的偶数部分，34到0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">70</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_l[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_l[i+<span class="number">1</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment">#n的奇数部分，1到33</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">70</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_r[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_r[i+<span class="number">1</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#w的奇数部分，33到1,</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">70</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_l[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_l[i+<span class="number">1</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#w的偶数部分 ,0到34</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">70</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_r[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_r[i+<span class="number">1</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">n=[]</span><br><span class="line">w=[]</span><br><span class="line">j=<span class="number">17</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">17</span>):</span><br><span class="line">    n.append(n_o[j])</span><br><span class="line">    n.append(n_j[i])</span><br><span class="line">    j-=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line">j=<span class="number">16</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">    w.append(w_o[i])</span><br><span class="line">    w.append(w_j[j])</span><br><span class="line">    j-=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(w)</span><br><span class="line">_n = [<span class="number">106</span>, <span class="number">234</span>, <span class="number">127</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">66</span>, <span class="number">127</span>, <span class="number">106</span>, <span class="number">164</span>, <span class="number">81</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">127</span>,</span><br><span class="line">    <span class="number">106</span>, <span class="number">73</span>, <span class="number">87</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">87</span>, <span class="number">77</span>, <span class="number">106</span>,</span><br><span class="line">    <span class="number">154</span>, <span class="number">234</span>, <span class="number">234</span>, <span class="number">66</span>, <span class="number">106</span>, <span class="number">106</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">87</span>, <span class="number">154</span>, <span class="number">162</span>, <span class="number">73</span>, <span class="number">66</span>,<span class="number">234</span>]</span><br><span class="line">_w = [<span class="number">14</span>, <span class="number">235</span>, <span class="number">171</span>, <span class="number">2</span>, <span class="number">156</span>, <span class="number">197</span>, <span class="number">171</span>, <span class="number">182</span>, <span class="number">62</span>, <span class="number">196</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">171</span>,</span><br><span class="line">    <span class="number">182</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">2</span>, <span class="number">182</span>,</span><br><span class="line">    <span class="number">161</span>, <span class="number">22</span>, <span class="number">235</span>, <span class="number">1</span>, <span class="number">182</span>, <span class="number">182</span>, <span class="number">58</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">144</span>]</span><br></pre></td></tr></table></figure><p>代码有点乱，大概思路就是先把70个字符分成两部分，然后分别从左到右分离出下标奇数部分的n和w，下标偶数部分的w和n，然后把这些n和w排好顺序，分别交替输出得到n和w 的数组。</p><p>这个过程读者可以自行完成，我这个只是参考，而且感觉很慢。最后得到的_n和_w便是结果</p><p>（脚本里输出的n和w有些问题，分别多了一项和少了一项，笔者懒得去修正了然后手动修改了一下得到正确的n和w，然后这个_n和_w也是有些问题的，当时看题时把main.py里的下标是奇数时，n和w替换，看成了偶数时才替换，所以这里得到的_n其实是实际的w，_w是实际上的n，搞反了，不过万幸的是不影响后面的爆破，只要换一下就好了）</p><p>接下来把得到的n和w拿来爆破出c就可以组合成flag了，至福~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">key1=[<span class="number">127</span>, <span class="number">81</span>, <span class="number">241</span>, <span class="number">40</span>, <span class="number">222</span>, <span class="number">128</span>, <span class="number">45</span>, <span class="number">87</span>, <span class="number">27</span>, <span class="number">154</span>,</span><br><span class="line">      <span class="number">66</span>,<span class="number">162</span>, <span class="number">73</span>, <span class="number">176</span>, <span class="number">172</span>, <span class="number">164</span>, <span class="number">106</span>, <span class="number">234</span>, <span class="number">77</span>, <span class="number">5</span>]</span><br><span class="line">key2=[<span class="number">155</span>, <span class="number">117</span>, <span class="number">124</span>, <span class="number">113</span>, <span class="number">104</span>, <span class="number">46</span>, <span class="number">151</span>, <span class="number">71</span>, <span class="number">144</span>, <span class="number">229</span>, <span class="number">152</span>, <span class="number">240</span>,</span><br><span class="line">      <span class="number">199</span>, <span class="number">88</span>, <span class="number">103</span>, <span class="number">105</span>, <span class="number">245</span>, <span class="number">209</span>, <span class="number">13</span>, <span class="number">82</span>, <span class="number">166</span>, <span class="number">9</span>, <span class="number">201</span>, <span class="number">233</span>, <span class="number">228</span>,</span><br><span class="line">      <span class="number">154</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">30</span>, <span class="number">141</span>, <span class="number">81</span>, <span class="number">206</span>, <span class="number">246</span>, <span class="number">232</span>, <span class="number">107</span>, <span class="number">29</span>, <span class="number">208</span>, <span class="number">253</span>,</span><br><span class="line">      <span class="number">187</span>, <span class="number">116</span>, <span class="number">98</span>, <span class="number">160</span>, <span class="number">60</span>, <span class="number">7</span>, <span class="number">220</span>, <span class="number">143</span>, <span class="number">80</span>, <span class="number">239</span>, <span class="number">52</span>, <span class="number">15</span>, <span class="number">94</span>, <span class="number">50</span>,</span><br><span class="line">      <span class="number">149</span>, <span class="number">241</span>, <span class="number">57</span>, <span class="number">92</span>, <span class="number">230</span>, <span class="number">100</span>, <span class="number">31</span>, <span class="number">51</span>, <span class="number">36</span>, <span class="number">24</span>, <span class="number">39</span>, <span class="number">14</span>, <span class="number">25</span>, <span class="number">90</span>, <span class="number">101</span>,</span><br><span class="line">      <span class="number">55</span>, <span class="number">194</span>, <span class="number">225</span>, <span class="number">157</span>, <span class="number">102</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">148</span>, <span class="number">161</span>, <span class="number">180</span>, <span class="number">120</span>, <span class="number">223</span>, <span class="number">165</span>, <span class="number">32</span>,</span><br><span class="line">      <span class="number">146</span>, <span class="number">185</span>, <span class="number">243</span>, <span class="number">119</span>, <span class="number">210</span>, <span class="number">172</span>, <span class="number">244</span>, <span class="number">1</span>, <span class="number">125</span>, <span class="number">44</span>, <span class="number">35</span>, <span class="number">169</span>, <span class="number">179</span>, <span class="number">188</span>,</span><br><span class="line">      <span class="number">64</span>, <span class="number">207</span>, <span class="number">33</span>, <span class="number">137</span>, <span class="number">200</span>, <span class="number">142</span>, <span class="number">182</span>, <span class="number">250</span>, <span class="number">195</span>, <span class="number">28</span>, <span class="number">4</span>, <span class="number">79</span>, <span class="number">191</span>, <span class="number">86</span>, <span class="number">215</span>,</span><br><span class="line">      <span class="number">96</span>, <span class="number">236</span>, <span class="number">91</span>, <span class="number">122</span>, <span class="number">196</span>, <span class="number">87</span>, <span class="number">118</span>, <span class="number">231</span>, <span class="number">126</span>, <span class="number">97</span>, <span class="number">147</span>, <span class="number">67</span>, <span class="number">132</span>, <span class="number">190</span>, <span class="number">234</span>,</span><br><span class="line">      <span class="number">237</span>, <span class="number">43</span>, <span class="number">193</span>, <span class="number">252</span>, <span class="number">18</span>, <span class="number">212</span>, <span class="number">163</span>, <span class="number">56</span>, <span class="number">73</span>, <span class="number">123</span>, <span class="number">176</span>, <span class="number">162</span>, <span class="number">23</span>, <span class="number">192</span>, <span class="number">49</span>,</span><br><span class="line">      <span class="number">21</span>, <span class="number">242</span>, <span class="number">171</span>, <span class="number">112</span>, <span class="number">153</span>, <span class="number">238</span>, <span class="number">203</span>, <span class="number">134</span>, <span class="number">167</span>, <span class="number">93</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">65</span>,</span><br><span class="line">      <span class="number">217</span>, <span class="number">248</span>, <span class="number">168</span>, <span class="number">219</span>, <span class="number">47</span>, <span class="number">211</span>, <span class="number">108</span>, <span class="number">76</span>, <span class="number">129</span>, <span class="number">145</span>, <span class="number">62</span>, <span class="number">156</span>, <span class="number">34</span>, <span class="number">218</span>, <span class="number">135</span>,</span><br><span class="line">      <span class="number">48</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">3</span>, <span class="number">249</span>, <span class="number">72</span>, <span class="number">202</span>, <span class="number">133</span>, <span class="number">183</span>, <span class="number">38</span>, <span class="number">37</span>, <span class="number">227</span>, <span class="number">164</span>, <span class="number">173</span>, <span class="number">159</span>, <span class="number">251</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">174</span>, <span class="number">54</span>, <span class="number">20</span>, <span class="number">136</span>, <span class="number">53</span>, <span class="number">138</span>, <span class="number">99</span>, <span class="number">226</span>, <span class="number">178</span>, <span class="number">42</span>, <span class="number">66</span>, <span class="number">150</span>, <span class="number">205</span>, <span class="number">204</span>, <span class="number">214</span>,</span><br><span class="line">      <span class="number">197</span>, <span class="number">235</span>, <span class="number">110</span>, <span class="number">216</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">184</span>, <span class="number">74</span>, <span class="number">41</span>, <span class="number">177</span>, <span class="number">27</span>, <span class="number">69</span>, <span class="number">130</span>, <span class="number">89</span>, <span class="number">61</span>, <span class="number">247</span>,</span><br><span class="line">      <span class="number">255</span>, <span class="number">17</span>, <span class="number">254</span>, <span class="number">181</span>, <span class="number">131</span>, <span class="number">22</span>, <span class="number">224</span>, <span class="number">83</span>, <span class="number">189</span>, <span class="number">59</span>, <span class="number">114</span>, <span class="number">139</span>, <span class="number">111</span>,</span><br><span class="line">      <span class="number">68</span>, <span class="number">6</span>, <span class="number">84</span>,<span class="number">11</span>, <span class="number">127</span>, <span class="number">221</span>, <span class="number">106</span>, <span class="number">77</span>, <span class="number">109</span>, <span class="number">158</span>,</span><br><span class="line">      <span class="number">170</span>, <span class="number">16</span>, <span class="number">121</span>, <span class="number">222</span>, <span class="number">186</span>, <span class="number">10</span>, <span class="number">58</span>, <span class="number">175</span>, <span class="number">40</span>, <span class="number">128</span>, <span class="number">198</span>, <span class="number">78</span>, <span class="number">85</span>, <span class="number">213</span>, <span class="number">140</span>]</span><br><span class="line">x = <span class="number">3449711664888782790334923396354433085218951813669043815144799745483347584183883892868078716490762334737115401929391994359609927294549975954045314661787321463018287415952</span></span><br><span class="line">w=[<span class="number">106</span>, <span class="number">234</span>, <span class="number">127</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">66</span>, <span class="number">127</span>, <span class="number">106</span>, <span class="number">164</span>, <span class="number">81</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">127</span>,</span><br><span class="line">    <span class="number">106</span>, <span class="number">73</span>, <span class="number">87</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">87</span>, <span class="number">77</span>, <span class="number">106</span>,</span><br><span class="line">    <span class="number">154</span>, <span class="number">234</span>, <span class="number">234</span>, <span class="number">66</span>, <span class="number">106</span>, <span class="number">106</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">87</span>, <span class="number">154</span>, <span class="number">162</span>, <span class="number">73</span>, <span class="number">66</span>,<span class="number">234</span>]</span><br><span class="line">n=[<span class="number">14</span>, <span class="number">235</span>, <span class="number">171</span>, <span class="number">2</span>, <span class="number">156</span>, <span class="number">197</span>, <span class="number">171</span>, <span class="number">182</span>, <span class="number">62</span>, <span class="number">196</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">171</span>,</span><br><span class="line">    <span class="number">182</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">2</span>, <span class="number">182</span>,</span><br><span class="line">    <span class="number">161</span>, <span class="number">22</span>, <span class="number">235</span>, <span class="number">1</span>, <span class="number">182</span>, <span class="number">182</span>, <span class="number">58</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">144</span>]</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">n</span>): <span class="comment">#加密函数</span></span><br><span class="line">    q = key2[n]</span><br><span class="line">    w = key1[q % <span class="number">20</span>]</span><br><span class="line">    n ^= q</span><br><span class="line">    <span class="keyword">return</span> n, w</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">35</span>):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            a , b = enc(j)</span><br><span class="line">            <span class="keyword">if</span> a==n[i] <span class="keyword">and</span> b==w[i]:</span><br><span class="line">                  flag += <span class="built_in">chr</span>(j)</span><br><span class="line">                  <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>nbctf{cr15s_cr0ss_str4wb3rry_s4uz3}</p><h2 id="0x02-sands"><a href="#0x02-sands" class="headerlink" title="0x02 sands"></a>0x02 sands</h2><p>看介绍就知道是迷宫题目，打开ida分析一下</p><p><img src="Images/eb2a67a911f14049a4ce7c18044a2d9f-1706531980127-2.png" alt="eb2a67a911f14049a4ce7c18044a2d9f">个关键的语句，和普通迷宫不同的是，这个迷宫会有‘S’，沙子没回合都会根据step移动来阻挡你的路线，如果沙子移动后正好和你的位置重合，会直接导致游戏失败（逻辑是沙子先动人后动），因为沙子撞人的判断是人移动后的，所以在这个迷宫中，只要你在沙子撞到你后移动走，也是能继续游戏的，这个是关键，知道这个小技巧后走迷宫就简单许多了。</p><p>比赛时为了节省时间可以省去不必要的东西，只保留关键的能帮助解题的判断语句，赛后我把迷宫完善了不少，已经能当做一个小游戏玩了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> map[<span class="number">100</span>]=&#123;<span class="number">38</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>,</span><br><span class="line">            <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>,</span><br><span class="line">          <span class="number">48</span>, <span class="number">83</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">83</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>,</span><br><span class="line">           <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, </span><br><span class="line">           <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">35</span>, </span><br><span class="line">           <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, </span><br><span class="line">            <span class="number">35</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>,</span><br><span class="line">             <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">76</span>, <span class="number">83</span>, </span><br><span class="line">             <span class="number">48</span>, <span class="number">48</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">char</span> step_arr[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//i是横坐标，j是纵坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">10</span>*j+i<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*j+i<span class="number">-1</span>]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i<span class="number">-1</span>]=<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">9</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">10</span>*j+i+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*j+i+<span class="number">1</span>]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i+<span class="number">1</span>]=<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">9</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">10</span>*j+<span class="number">10</span>+i]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*j+<span class="number">10</span>+i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+<span class="number">10</span>+i]=<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">10</span>*j<span class="number">-10</span>+i]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*j+i<span class="number">-10</span>]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j<span class="number">-10</span>+i]=<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,map[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sand_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">switch</span>(step%<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">for</span>(x=<span class="number">9</span>;x&gt;=<span class="number">0</span>;x--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=<span class="number">9</span>;y++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*y+x]==<span class="string">&#x27;S&#x27;</span>&amp;&amp;x!=<span class="number">9</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[<span class="number">10</span>*y+x+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*y+x+<span class="number">1</span>]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                            map[<span class="number">10</span>*y+x+<span class="number">1</span>]=<span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                            map[<span class="number">10</span>*y+x]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=<span class="number">9</span>;y++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;=<span class="number">9</span>;x++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*y+x]==<span class="string">&#x27;S&#x27;</span>&amp;&amp;y!=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[<span class="number">10</span>*y+x<span class="number">-10</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*y+x<span class="number">-10</span>]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                            map[<span class="number">10</span>*y+x<span class="number">-10</span>]=<span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                            map[<span class="number">10</span>*y+x]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;=<span class="number">9</span>;x++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=<span class="number">9</span>;y++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*y+x]==<span class="string">&#x27;S&#x27;</span>&amp;&amp;x!=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[<span class="number">10</span>*y+x<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*y+x<span class="number">-1</span>]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                            map[<span class="number">10</span>*y+x<span class="number">-1</span>]=<span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                            map[<span class="number">10</span>*y+x]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span>(y=<span class="number">9</span>;y&gt;=<span class="number">0</span>;y--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;=<span class="number">9</span>;x++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*y+x]==<span class="string">&#x27;S&#x27;</span>&amp;&amp;y!=<span class="number">9</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[<span class="number">10</span>*y+x+<span class="number">10</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>/y+x+<span class="number">10</span>]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                            map[<span class="number">10</span>*y+x+<span class="number">10</span>]=<span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                            map[<span class="number">10</span>*y+x]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(step&lt;=<span class="number">49</span>&amp;&amp;map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">set_map</span>();</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;step:&quot;</span>&lt;&lt;step;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;sand de is &quot;</span>&lt;&lt;(step%<span class="number">4</span>);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;(0是下移动,1是左移动,2是上移动,3是右移动)&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;enter your direcation:&quot;</span>;</span><br><span class="line">std::cin&gt;&gt;ch;</span><br><span class="line">        <span class="built_in">sand_move</span>();</span><br><span class="line">        step_arr[step]=ch;</span><br><span class="line">        step++;</span><br><span class="line">        <span class="built_in">move</span>(ch);</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">9</span>&amp;&amp;i==<span class="number">6</span>)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;yep&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;step;l++)&#123;</span><br><span class="line">            std::cout&lt;&lt;step_arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样很浪费时间，不过赛后无所谓了。</p><p>然后这题还要连一下官方给的靶机，在linux虚拟机里面的命令行打入</p><p>nc 【ip】【端口】</p><p>连接成功后ls罗列一下文件，cat可以查看文件</p><h2 id="0x03-twostep"><a href="#0x03-twostep" class="headerlink" title="0x03 twostep"></a>0x03 twostep</h2><p>这个题的逻辑就是反复调用两个不同的函数，然后分块加密，函数1中有几个子函数，每个子函数加密一块，函数2同理，然后调用法则是函数1到函数2，函数2再到函数1，每次调用时step（计数器）+1，然后case不同的step分块加密，最后根据一个数组word_404090[]知道这个加密块在整体flag具体的位置</p><p><img src="Images/850be99663a24e22ba85483570b7924e-1706532051009-5.png" alt="850be99663a24e22ba85483570b7924e"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#472036518</span><br><span class="line">#123456789</span><br></pre></td></tr></table></figure><p>下面是步数step，上面是位置。</p><p>函数1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">encry1</span><span class="params">(_BYTE *input)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> one; <span class="comment">// [rsp+19h] [rbp-A7h]</span></span><br><span class="line">  __int16 v3; <span class="comment">// [rsp+1Ah] [rbp-A6h]</span></span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+1Ch] [rbp-A4h]</span></span><br><span class="line">  __int16 v5; <span class="comment">// [rsp+1Eh] [rbp-A2h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 k; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 m; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 j; <span class="comment">// [rsp+28h] [rbp-98h]</span></span><br><span class="line">  _BYTE *v11; <span class="comment">// [rsp+30h] [rbp-90h]</span></span><br><span class="line">  _BYTE *v12; <span class="comment">// [rsp+30h] [rbp-90h]</span></span><br><span class="line">  _BYTE *v13; <span class="comment">// [rsp+30h] [rbp-90h]</span></span><br><span class="line">  __int16 v14[<span class="number">4</span>]; <span class="comment">// [rsp+38h] [rbp-88h]</span></span><br><span class="line">  __int64 v15[<span class="number">6</span>]; <span class="comment">// [rsp+40h] [rbp-80h]</span></span><br><span class="line">  __int64 v16[<span class="number">8</span>]; <span class="comment">// [rsp+70h] [rbp-50h]</span></span><br><span class="line">  __int16 v17; <span class="comment">// [rsp+B6h] [rbp-Ah]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v18; <span class="comment">// [rsp+B8h] [rbp-8h] 472036518</span></span><br><span class="line">                        <span class="comment">//                    123456789</span></span><br><span class="line"> </span><br><span class="line">  v18 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v14[<span class="number">0</span>] = <span class="number">0x4808</span>;</span><br><span class="line">  v14[<span class="number">1</span>] = <span class="number">0xC40</span>;</span><br><span class="line">  v14[<span class="number">2</span>] = <span class="number">0x480C</span>;</span><br><span class="line">  v14[<span class="number">3</span>] = <span class="number">0x408C</span>;</span><br><span class="line">  v16[<span class="number">0</span>] = <span class="number">1LL</span>;</span><br><span class="line">  v16[<span class="number">1</span>] = <span class="number">16LL</span>;</span><br><span class="line">  v16[<span class="number">2</span>] = <span class="number">32LL</span>;</span><br><span class="line">  v16[<span class="number">3</span>] = <span class="number">512LL</span>;</span><br><span class="line">  v16[<span class="number">4</span>] = <span class="number">1024LL</span>;</span><br><span class="line">  v16[<span class="number">5</span>] = <span class="number">2048LL</span>;</span><br><span class="line">  v16[<span class="number">6</span>] = <span class="number">0x2000</span>LL;</span><br><span class="line">  v16[<span class="number">7</span>] = <span class="number">0x4000</span>LL;</span><br><span class="line">  v15[<span class="number">0</span>] = <span class="number">177LL</span>;</span><br><span class="line">  v15[<span class="number">1</span>] = <span class="number">166LL</span>;</span><br><span class="line">  v15[<span class="number">2</span>] = <span class="number">183LL</span>;</span><br><span class="line">  v15[<span class="number">3</span>] = <span class="number">182LL</span>;</span><br><span class="line">  v15[<span class="number">4</span>] = <span class="number">177LL</span>;</span><br><span class="line">  v15[<span class="number">5</span>] = <span class="number">0xAD</span>LL;</span><br><span class="line">  v17 = <span class="number">170</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( step )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0LL</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *input == <span class="string">&#x27;n&#x27;</span> &amp;&amp; input[<span class="number">1</span>] == <span class="string">&#x27;b&#x27;</span> &amp;&amp; input[<span class="number">2</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; input[<span class="number">3</span>] == <span class="string">&#x27;t&#x27;</span> &amp;&amp; input[<span class="number">4</span>] == <span class="string">&#x27;f&#x27;</span> &amp;&amp; input[<span class="number">5</span>] == <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">        result = encry2(input + <span class="number">6</span>);             <span class="comment">// step=0</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">      v11 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">3</span>; ++i )              <span class="comment">// step=2</span></span><br><span class="line">      &#123;</span><br><span class="line">        one = v11[i];</span><br><span class="line">        v4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v4 |= (one &amp; <span class="number">3</span>) &lt;&lt; (<span class="number">4</span> * j + <span class="number">2</span>);</span><br><span class="line">          one &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v4 != v14[i] )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = encry2(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">      v12 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( k = <span class="number">0LL</span>; k &lt;= <span class="number">4</span>; ++k )              <span class="comment">// step=4</span></span><br><span class="line">        v100[k] = v12[k];</span><br><span class="line">      result = encry2(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6LL</span>:</span><br><span class="line">      v3 = *step_change(input);</span><br><span class="line">      v8 = <span class="number">0LL</span>;                                 <span class="comment">// step=7</span></span><br><span class="line">      <span class="keyword">while</span> ( v3 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = v3 &amp; -v3;                          <span class="comment">// 等于1</span></span><br><span class="line">        <span class="keyword">if</span> ( v8 == <span class="number">8</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v16[v8] == v5 )</span><br><span class="line">          ++v8;</span><br><span class="line">        v3 ^= v5;</span><br><span class="line">      &#125;</span><br><span class="line">      result = v8 == <span class="number">8</span> &amp;&amp; encry2(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8LL</span>:</span><br><span class="line">      v13 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( m = <span class="number">0LL</span>; m &lt;= <span class="number">5</span>; ++m )              <span class="comment">// step=9</span></span><br><span class="line">        LOBYTE(v17) = v13[m] ^ v15[m];          <span class="comment">// 去调试找找v17是多少</span></span><br><span class="line">      result = <span class="number">1LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">encry2</span><span class="params">(_BYTE *input)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+18h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 j; <span class="comment">// [rsp+18h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 k; <span class="comment">// [rsp+18h] [rbp-E8h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+20h] [rbp-E0h]</span></span><br><span class="line">  _BYTE *v6; <span class="comment">// [rsp+28h] [rbp-D8h]</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// [rsp+28h] [rbp-D8h]</span></span><br><span class="line">  _BYTE *v8; <span class="comment">// [rsp+28h] [rbp-D8h]</span></span><br><span class="line">  _BYTE *v9; <span class="comment">// [rsp+28h] [rbp-D8h]</span></span><br><span class="line">  __int64 v10[<span class="number">6</span>]; <span class="comment">// [rsp+30h] [rbp-D0h]</span></span><br><span class="line">  __int64 v11[<span class="number">6</span>]; <span class="comment">// [rsp+60h] [rbp-A0h]</span></span><br><span class="line">  __int64 v12[<span class="number">6</span>]; <span class="comment">// [rsp+90h] [rbp-70h]</span></span><br><span class="line">  __int64 v13[<span class="number">8</span>]; <span class="comment">// [rsp+C0h] [rbp-40h] 472036518</span></span><br><span class="line">                  <span class="comment">//                     123456789</span></span><br><span class="line"> </span><br><span class="line">  v13[<span class="number">7</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">54515LL</span>;</span><br><span class="line">  v13[<span class="number">1</span>] = <span class="number">15689LL</span>;</span><br><span class="line">  v13[<span class="number">2</span>] = <span class="number">4219LL</span>;</span><br><span class="line">  v13[<span class="number">3</span>] = <span class="number">50297LL</span>;</span><br><span class="line">  v13[<span class="number">4</span>] = <span class="number">43652LL</span>;</span><br><span class="line">  v13[<span class="number">5</span>] = <span class="number">38919LL</span>;</span><br><span class="line">  v10[<span class="number">0</span>] = <span class="number">14668LL</span>;</span><br><span class="line">  v10[<span class="number">1</span>] = <span class="number">24063LL</span>;</span><br><span class="line">  v10[<span class="number">2</span>] = <span class="number">37349LL</span>;</span><br><span class="line">  v10[<span class="number">3</span>] = <span class="number">50716LL</span>;</span><br><span class="line">  v10[<span class="number">4</span>] = <span class="number">61563LL</span>;</span><br><span class="line">  v11[<span class="number">0</span>] = <span class="number">1843061LL</span>;</span><br><span class="line">  v11[<span class="number">1</span>] = <span class="number">222420LL</span>;</span><br><span class="line">  v11[<span class="number">2</span>] = <span class="number">5184810LL</span>;</span><br><span class="line">  v11[<span class="number">3</span>] = <span class="number">4590105LL</span>;</span><br><span class="line">  v11[<span class="number">4</span>] = <span class="number">2184197LL</span>;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  v12[<span class="number">0</span>] = <span class="number">1073741834LL</span>;</span><br><span class="line">  v12[<span class="number">1</span>] = <span class="number">2415919110LL</span>;</span><br><span class="line">  v12[<span class="number">2</span>] = <span class="number">939524099LL</span>;</span><br><span class="line">  v12[<span class="number">3</span>] = <span class="number">536870913LL</span>;</span><br><span class="line">  v12[<span class="number">4</span>] = <span class="number">1845493760LL</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( step )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0LL</span>:</span><br><span class="line">      v6 = step_change(input);</span><br><span class="line">      <span class="keyword">if</span> ( (*v6 ^ <span class="number">95</span>) == v6[<span class="number">1</span>]                  <span class="comment">// step=1</span></span><br><span class="line">        &amp;&amp; (v6[<span class="number">1</span>] ^ <span class="number">117</span>) == v6[<span class="number">2</span>]</span><br><span class="line">        &amp;&amp; (v6[<span class="number">2</span>] ^ <span class="number">18</span>) == v6[<span class="number">3</span>]</span><br><span class="line">        &amp;&amp; (v6[<span class="number">3</span>] ^ <span class="number">56</span>) == *v6</span><br><span class="line">        &amp;&amp; *v6 == <span class="number">108</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = encry1(input);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">      v7 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">4</span>; ++i )              <span class="comment">// step=3</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v13[i] + v13[i + <span class="number">1</span>] * v7[i] != v11[i] )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = encry1(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">      v8 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j &lt;= <span class="number">4</span>; ++j )              <span class="comment">// step=5</span></span><br><span class="line">      &#123;</span><br><span class="line">        v5 += v100[j] + (v8[j] &lt;&lt; <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v5 != v10[j] )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = encry2(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">      v9 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( k = <span class="number">0LL</span>; k &lt;= <span class="number">4</span>; ++k )              <span class="comment">// step=6</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v12[k] != ((v9[k] &gt;&gt; (k + <span class="number">3</span>)) | (v9[k] &lt;&lt; (<span class="number">32</span> - (k + <span class="number">3</span>)))) )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = encry1(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7LL</span>:</span><br><span class="line">      qword_404308 = *step_change(input);</span><br><span class="line">      result = *&amp;qword_404308 == <span class="number">3.325947034342098e151</span> &amp;&amp; encry1(input);<span class="comment">// step=8</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概思路就是这样，剩下逐个攻破加密块，按照word_404090里一一对应的关系排列组合，就能得出flag了。（调试太痛苦了，最后不调试还不知道，摆了）</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP类的基础</title>
      <link href="/2024/01/29/cpp%E7%B1%BB%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/01/29/cpp%E7%B1%BB%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>函数名和类名相同，有参数，构造函数创建对象时会自动调用且只调用一次，而析构函数在对象销毁前会自动调用一次，这两个函数是必需的，如果不手动设置，编译器会自动设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数 </span></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h2><p>默认无参构造函数，有参构造函数，拷贝构造函数</p><p>调用方法有括号法显示法和隐式转化法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line"><span class="comment">//无参 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a)&#123;</span><br><span class="line"><span class="comment">//有参 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line"><span class="comment">//拷贝 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//括号法 </span></span><br><span class="line"><span class="comment">//默认构造不要加括号()，编译器会误以为是函数的声明 </span></span><br><span class="line">Person p1;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//显示法</span></span><br><span class="line">Person p1;</span><br><span class="line">Person p2=<span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">Person p3=<span class="built_in">Person</span>(p2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="number">10</span>)<span class="comment">//匿名对象，当前行执行完后自动回收</span></span><br><span class="line"><span class="comment">//注意：不要用拷贝构造函数初始化匿名对象 </span></span><br><span class="line"><span class="comment">//编译器会认为Person(p3)===Person p3，对象重定义 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//隐式转化法 </span></span><br><span class="line">Person p4 =<span class="number">10</span>;<span class="comment">//相当于Person p4 =Perosn(10)</span></span><br><span class="line">Person p5 = p4;<span class="comment">//相当于拷贝 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝函数的调用时机"><a href="#拷贝函数的调用时机" class="headerlink" title="拷贝函数的调用时机"></a>拷贝函数的调用时机</h2><p>使用一个已经创建完毕的对象来初始化一个新对象</p><p>值传递的方式给函数参数传值</p><p>值传递的方式返回局部对象</p><h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p>C++至少给一个类添加三个函数</p><p>默认构造函数，默认析构函数，默认拷贝构造函数</p><p>若定义了有参构造函数，则不会默认添加无参构造函数，但有拷贝构造函数</p><p>若定义了拷贝构造函数，c++不会添加其他构造函数</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>构造函数（）：属性1（值1），属性2（值2）…… { … }</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>():<span class="built_in">m_a</span>(<span class="number">10</span>),<span class="built_in">m_b</span>(<span class="number">20</span>),<span class="built_in">m_c</span>(<span class="number">30</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种 </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">m_a</span>(a),<span class="built_in">m_b</span>(b),<span class="built_in">m_c</span>(c)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通的 </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> c)&#123;</span><br><span class="line">ma=a;</span><br><span class="line">mb=b;</span><br><span class="line">mc=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ma,mb,mc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他类对象作为本类的成员"><a href="#其他类对象作为本类的成员" class="headerlink" title="其他类对象作为本类的成员"></a>其他类对象作为本类的成员</h2><p>其他类对象作为本类的成员时，先有其他类对象的构造函数，再有自身的构造函数</p><p>先有自身的析构，再有其他类对象的析构</p><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>加上关键字static</p><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>在编译阶段分配内存，程序还未运行就已经有内存，全局区的内存</p><p>需要在类内声明，然后在类外初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//类内声明 </span></span><br><span class="line"><span class="type">static</span> A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外初始化 </span></span><br><span class="line"><span class="type">int</span> Person::A=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>所有对象共享一份数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量不属于某个对象</span></span><br><span class="line"><span class="comment">//可以通过对象或者类名访问</span></span><br><span class="line">Person p;</span><br><span class="line">std::cout&lt;&lt;p.A&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;Person::A&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>所有对象共享一个函数（与成员变量访问方式一样）</p><p>通过静态成员函数只能访问静态成员变量</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>游戏</title>
      <link href="/games/index.html"/>
      <url>/games/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="兰斯8攻略"><a href="#兰斯8攻略" class="headerlink" title="兰斯8攻略"></a>兰斯8攻略</h2><p><a href="https://www.bilibili.com/read/readlist/rl472073">【攻略】兰斯8完美图文攻略（整理版）</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/*样式页面调节*/:root {  --trans-light: rgba(255, 255, 255, 0.75);  --trans-dark: rgba(25, 25, 25, 0.6);  --border-style: 1px solid rgb(169, 169, 169);  /*blur(5px) saturate(150%)*/  --backdrop-filter: none;}/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }  /* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;  }    /* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[setInterval(() => {  let create_time = Math.round(new Date('2024-01-28 00:00:00').getTime() / 1000); //在此行修改建站时间  let timestamp = Math.round((new Date().getTime()) / 1000);  let second = timestamp - create_time;  let time = new Array(0, 0, 0, 0, 0);  var nol = function(h){    return h>9?h:'0'+h;  }  if (second >= 365 * 24 * 3600) {    time[0] = parseInt(second / (365 * 24 * 3600));    second %= 365 * 24 * 3600;  }  if (second >= 24 * 3600) {    time[1] = parseInt(second / (24 * 3600));    second %= 24 * 3600;  }  if (second >= 3600) {    time[2] = nol(parseInt(second / 3600));    second %= 3600;  }  if (second >= 60) {    time[3] = nol(parseInt(second / 60));    second %= 60;  }  if (second > 0) {    time[4] = nol(second);  }  if ((Number(time[2])<22) && (Number(time[2])>7)){    currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/面包店-营业中-6adea8?style=social&logo=cakephp' title='要买一些新鲜美味的面包吗~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';  }  else{    currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/面包店-打烊了-6adea8?style=social&logo=coffeescript' title='这个点了应该去睡觉啦，熬夜对身体不好哦~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';  }  document.getElementById("workboard").innerHTML = currentTimeHtml;}, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>DIARY</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="2025-1-16-1点15分"><a href="#2025-1-16-1点15分" class="headerlink" title="2025-1-16 1点15分"></a>2025-1-16 1点15分</h2><p>今天早上7点多就被闹钟吵醒了，起来吃了个早餐后又睡到12点多，跟着教程试着学了一下Go语言，配了wsl2和一些Go语言的环境，晚上去烨桐家玩还一起吃了沙县，逆天cyt还玩原神，给对象带坏了（乐。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
